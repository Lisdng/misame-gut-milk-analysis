---
title: "CellHostMicrobe_github"
author: "Lishi"
date: "2025-09-11"
output: html_document
---

# Setup

## Working directory

```{r echo=FALSE}
# set the work directory
knitr::opts_knit$set(
  root.dir = '~/.../...', 
  echo=TRUE
  )
wd <- getwd()
message(paste0("The current working directory is set to: ", wd))
set.seed(123)

COLOR_SCHEME <- c(
  "#00A98F",
  "#FFC000",
  "#1565A9",
  "#C00000",
  "#0D0D0D",
  "#6aa84f",
  "tomato4",
  "#8b7355"
)

```

## Package

```{r message=FALSE}

library(phyloseq)
library(dplyr)
library(ggplot2)
library(tmle)
library(plotly)
library(SuperLearner)
library(ANCOMBC)
library('ComplexHeatmap')
library('hrbrthemes')
library(haven)
library(tibble)
library(tidyr)
library(ggrepel)
library("randomForest")
library(lme4)
library(UpSetR)
library(DESeq2)
library(treeclimbR)
library(permFDP)
library(clusterProfiler)
library(dbarts)
library(ComplexHeatmap)
library(microbiome)
library(microViz)
library(Rmisc)
library(car)
library(stringr)
library(reshape2)
library(tidyverse)
library(psych)
library(vegan)
library(nlme)
library(patchwork)
library(readxl)
library(dendextend)
library(missForest) 
library(Boruta)
library(compositions)
library(parallel)
library(doParallel)
library(xgboost) # xgboost: Extreme Gradient Boosting
library(tidyverse)
library(caret)
library(emmeans)
library(colorspace)
library(openxlsx)
 library(lavaan)
library(semptools)
 library(semPlot)
library(pROC)
library(broom)

```

# Import and wangle data

## Milk

```{r message=FALSE}

metadata <- haven::read_dta("../data/metadata_for_sharing.dta")
hmo_raw <- read.csv("../data/HMO_MISAME.csv")
bio_raw <- read.csv("../data/MSD_MISAME.csv")
mar_raw <- read.csv("../data/Macronutrient_MISAME.csv")
vitb_raw <- read.csv("../data/Allen_Bvit_MISAME.csv")
min_raw <- read.csv("../data/Allen_ICP_MISAME.csv")
fvit_raw <- read.csv("../data/Allen_FSV_MISAME.csv")
metab_raw <- read.csv("../data/M_metabolite_b.csv") %>%
  mutate(X = Unnamed..0) %>%
  dplyr::select(X, where(~ !is.integer(.))) %>%
  dplyr::select(-Unnamed..0)

purge_pn12 <-  haven::read_dta("../pn12e.dta")

merge_wide <-  haven::read_dta("../Merged_wide.dta")

MISAME3_24hr <-  haven::read_dta("../MISAME3_24hr_finaldataset_anonymised.dta")

hmoMeta <- hmo_raw %>%
  dplyr::select(-contains(c("ug.ml", "pct"))) %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  left_join(metadata, by = "idbs")%>%
  mutate(abo = ifelse(lbw == 1 | sga_new == 1 | preterm == 1 | 
         c_stunting0 == 1 | c_wasting0 == 1 | c_underweight0 == 1 | biospe_neonatal_mortality == 1, 1, 0)) %>%
  filter(code_bep_n == 1 | code_bep_n == 4) %>%
  filter(idbs != "619")
hmoMeta$abo <- as.character(hmoMeta$abo)


bioMeta <- bio_raw %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  left_join(metadata, by = "idbs")%>%
  mutate(abo = ifelse(lbw == 1 | sga_new == 1 | preterm == 1 | 
         c_stunting0 == 1 | c_wasting0 == 1 | c_underweight0 == 1 | biospe_neonatal_mortality == 1, 1, 0)) %>%
  filter(code_bep_n == 1 | code_bep_n == 4) %>%
  filter(idbs != "619")

bioMeta$FGF.21 <- as.numeric(bioMeta$FGF.21)
bioMeta$FSH <- as.numeric(bioMeta$FSH)
bioMeta$Insulin <- as.numeric(bioMeta$Insulin)
bioMeta$LH <- as.numeric(bioMeta$LH)
bioMeta$Leptin <- as.numeric(bioMeta$Leptin)
bioMeta$Calprotectin <- as.numeric(bioMeta$Calprotectin)
bioMeta$IgA <- as.numeric(bioMeta$IgA)

bioMeta <- bioMeta %>%
    mutate(Calprotectin = if_else(Calprotectin>3e+09, Calprotectin*0.01, Calprotectin)) %>%
  mutate(IgA = if_else(IgA>1e+16, IgA*0.000001, IgA)) %>%
  mutate(LH = if_else(LH>1000, LH*0.1, LH))

hmo <- hmo_raw %>%
  dplyr::select(-contains(c("ug.ml", "pct"))) %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  filter(timepoint == "1421" | timepoint == "pn12" | timepoint == "pn34")


bio <- bio_raw %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  filter(!is.na(idbs))  %>%
  filter(timepoint == "1421" | timepoint == "pn12" | timepoint == "pn34")

bio$FGF.21 <- as.numeric(bio$FGF.21)
bio$FSH <- as.numeric(bio$FSH)
bio$Insulin <- as.numeric(bio$Insulin)
bio$LH <- as.numeric(bio$LH)
bio$Leptin <- as.numeric(bio$Leptin)
bio$Calprotectin <- as.numeric(bio$Calprotectin)
bio$IgA <- as.numeric(bio$IgA)


marMeta <- mar_raw %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  left_join(metadata, by = "idbs")%>%
  mutate(abo = ifelse(lbw == 1 | sga_new == 1 | preterm == 1 | 
         c_stunting0 == 1 | c_wasting0 == 1 | c_underweight0 == 1 | biospe_neonatal_mortality == 1, 1, 0)) %>%
  filter(code_bep_n == 1 | code_bep_n == 4) %>%
  filter(idbs != "619")

vitbMeta <- vitb_raw %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  left_join(metadata, by = "idbs")%>%
  mutate(abo = ifelse(lbw == 1 | sga_new == 1 | preterm == 1 | 
         c_stunting0 == 1 | c_wasting0 == 1 | c_underweight0 == 1 | biospe_neonatal_mortality == 1, 1, 0)) %>%
  filter(code_bep_n == 1 | code_bep_n == 4) %>%
  filter(idbs != "619")

fvitMeta <- fvit_raw %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  left_join(metadata, by = "idbs")%>%
  mutate(abo = ifelse(lbw == 1 | sga_new == 1 | preterm == 1 | 
         c_stunting0 == 1 | c_wasting0 == 1 | c_underweight0 == 1 | biospe_neonatal_mortality == 1, 1, 0)) %>%
  filter(code_bep_n == 1 | code_bep_n == 4) %>%
  filter(idbs != "619")

minMeta <- min_raw %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  left_join(metadata, by = "idbs")%>%
  mutate(abo = ifelse(lbw == 1 | sga_new == 1 | preterm == 1 | 
         c_stunting0 == 1 | c_wasting0 == 1 | c_underweight0 == 1 | biospe_neonatal_mortality == 1, 1, 0)) %>%
  filter(code_bep_n == 1 | code_bep_n == 4)  %>%
  filter(idbs != "619") %>%
    mutate(Cr = if_else(Cr>2000, Cr*0.1, Cr))

vitbMeta <- vitb_raw %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  left_join(metadata, by = "idbs")%>%
  mutate(abo = ifelse(lbw == 1 | sga_new == 1 | preterm == 1 | 
         c_stunting0 == 1 | c_wasting0 == 1 | c_underweight0 == 1 | biospe_neonatal_mortality == 1, 1, 0)) %>%
  filter(code_bep_n == 1 | code_bep_n == 4) %>%
  filter(idbs != "619")

metabMeta <- metab_raw %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  left_join(metadata, by = "idbs")%>%
  mutate(abo = ifelse(lbw == 1 | sga_new == 1 | preterm == 1 | 
         c_stunting0 == 1 | c_wasting0 == 1 | c_underweight0 == 1 | biospe_neonatal_mortality == 1, 1, 0)) %>%
  filter(code_bep_n == 1 | code_bep_n == 4) %>%
  filter(idbs != "619")
metabMeta$idbs <- as.factor(metabMeta$idbs)



```

bio data: "pg/mL"

hmo data: The data is in three different forms, "nmol/mL", "ug/mL" and "percent" (compositional). There are 19 different HMOs measured, for each we have the various unit attached to the names, with "pct" indicating the compositional ones.

## Metagenomic ps

```{r message=FALSE}
pn12e_se1g <- haven::read_dta("../pn12e.dta")

pn12m_se1g <- haven::read_dta("../pn12m.dta")

pn56e_se1g <- haven::read_dta("../pn56e.dta")

pn56m_se1g <- haven::read_dta("../pn56m.dta")

incl_se1g <- haven::read_dta("../incl.dta")

tri3_se1g <- haven::read_dta("../tri3.dta")


incl_se1g_date <- incl_se1g %>%
  mutate(
    incl_se1g_dadi = na_if(incl_se1g_dadi, ""),
    incl_sa10ab_dtdi = na_if(incl_sa10ab_dtdi, ""),
    incl_sa20ab_dadi = na_if(incl_sa20ab_dadi, ""),
    incl_sapl_dati = na_if(incl_sapl_dati, "")
  ) %>%
  mutate(incl_date = coalesce(substr(incl_se1g_dadi, 1, 8), substr(incl_sa10ab_dtdi, 1, 8), substr(incl_sa20ab_dadi, 1, 8), substr(incl_sapl_dati, 1, 8))) %>%
  mutate(idbs = incl_idbs) %>%
  dplyr::select(idbs, incl_date)

tri3_se1g_date <- tri3_se1g %>%
  mutate(
    tri3_se1g_dadi = na_if(tri3_se1g_dadi, ""),
    tri3_sa10ab_dtdi = na_if(tri3_sa10ab_dtdi, ""),
    tri3_sa20ab_dadi = na_if(tri3_sa20ab_dadi, ""),
    tri3_sapl_dati = na_if(tri3_sapl_dati, "")
  ) %>%
  mutate(tri3_date = coalesce(substr(tri3_se1g_dadi, 1, 8), substr(tri3_sa10ab_dtdi, 1, 8), substr(tri3_sa20ab_dadi, 1, 8), substr(tri3_sapl_dati, 1, 8))) %>%
  mutate(idbs = tri3_idbs) %>%
  dplyr::select(idbs, tri3_date)

pn12m_se1g_date <- pn12m_se1g %>%
  mutate(
    pn12m_se1g_dadi = na_if(pn12m_se1g_dadi, ""),
    pn12m_sapl_dati = na_if(pn12m_sapl_dati, "")
  ) %>%
  mutate(pn12m_date = coalesce(substr(pn12m_se1g_dadi, 1, 8),  substr(pn12m_sapl_dati, 1, 8))) %>%
  mutate(idbs = pn12m_idbs) %>%
  dplyr::select(idbs, pn12m_date)

pn56m_se1g_date <- pn56m_se1g %>%
  mutate(
    pn56m_se1g_dadi = na_if(pn56m_se1g_dadi, ""),
    pn56m_sa10ab_dtdi = na_if(pn56m_sa10ab_dtdi, ""),
    pn56m_sa20ab_dadi = na_if(pn56m_sa20ab_dadi, ""),
    pn56m_sapl_dati = na_if(pn56m_sapl_dati, "")
  ) %>%
  mutate(pn56m_date = coalesce(substr(pn56m_se1g_dadi, 1, 8), substr(pn56m_sa10ab_dtdi, 1, 8), substr(pn56m_sa20ab_dadi, 1, 8), substr(pn56m_sapl_dati, 1, 8))) %>%
  mutate(idbs = pn56m_idbs) %>%
  dplyr::select(idbs, pn56m_date)

pn12e_se1g_date <- pn12e_se1g %>%
  mutate(
    pn12e_se1g_dadi = na_if(pn12e_se1g_dadi, ""),
    pn12e_sa10ab_dtdi = na_if(pn12e_sa10ab_dtdi, ""),
    pn12e_sa20ab_dati = na_if(pn12e_sa20ab_dati, ""),
  ) %>%
  mutate(pn12e_date = coalesce(substr(pn12e_se1g_dadi, 1, 8), substr(pn12e_sa10ab_dtdi, 1, 8), substr(pn12e_sa20ab_dati, 1, 8))) %>%
  mutate(idbs = pn12e_idbs) %>%
  dplyr::select(idbs, pn12e_date)

pn56e_se1g_date <- pn56e_se1g %>%
  mutate(
    pn56e_se1g_dadi = na_if(pn56e_se1g_dadi, ""),
    pn56e_sa10ab_dtdi = na_if(pn56e_sa10ab_dtdi, ""),
    pn56e_sa20ab_dati = na_if(pn56e_sa20ab_dati, ""),
  ) %>%
  mutate(pn56e_date = coalesce(substr(pn56e_se1g_dadi, 1, 8), substr(pn56e_sa10ab_dtdi, 1, 8), substr(pn56e_sa20ab_dati, 1, 8))) %>%
  mutate(idbs = pn56e_idbs) %>%
  dplyr::select(idbs, pn56e_date)


# Convert idbs to character in all data frames before joining
pn12e_se1g_date$idbs <- as.character(pn12e_se1g_date$idbs)
pn56e_se1g_date$idbs <- as.character(pn56e_se1g_date$idbs)
incl_se1g_date$idbs <- as.character(incl_se1g_date$idbs)
tri3_se1g_date$idbs <- as.character(tri3_se1g_date$idbs)
pn12m_se1g_date$idbs <- as.character(pn12m_se1g_date$idbs)
pn56m_se1g_date$idbs <- as.character(pn56m_se1g_date$idbs)

# Now perform the left_join operation
ps_date <- pn12e_se1g_date %>% 
  left_join(pn56e_se1g_date, by = "idbs") %>% 
  left_join(incl_se1g_date, by = "idbs") %>% 
  left_join(tri3_se1g_date, by = "idbs") %>% 
  left_join(pn12m_se1g_date, by = "idbs") %>% 
  left_join(pn56m_se1g_date, by = "idbs")  

metadataGut <- read.csv("../results/metadata.csv", row.names = 1)

metadataGut <- metadataGut %>%
  mutate(abo = ifelse(lbw == 1 | sga_new == 1 | preterm == 1 | 
         c_stunting0 == 1 | c_wasting0 == 1 | c_underweight0 == 1 | biospe_neonatal_mortality == 1, 1, 0)) %>%
#  filter(!is.na(abo)) %>%
  mutate(svn = ifelse(lbw == 1 | sga_new == 1 | preterm == 1, 1, 0))



taxonomy <- read.csv("../results/taxonomy_clean.csv", row.names = 1) %>%
  mutate(strain = gsub("_Bifidobacterium longum", "Bifidobacterium longum", strain)) %>%
  mutate(strain = gsub("_Bifidobacterium infantis", "Bifidobacterium infantis", strain)) %>%
  mutate(species = gsub("_Bifidobacterium longum", "Bifidobacterium longum", species)) %>%
  mutate(species = gsub("_Bifidobacterium infantis", "Bifidobacterium infantis", species)) %>%
  mutate(genus = gsub("_Bifidobacterium", "Bifidobacterium", genus)) %>%
  mutate(family = gsub("_Bifidobacteriaceae", "Bifidobacteriaceae", family)) %>%
  mutate(order = gsub("_Actinomycetales", "Actinomycetales", order)) %>%
  mutate(class = gsub("_Actinomycetia", "Actinomycetia", class)) %>%
  as.matrix()

absolute_counts <- read.csv("../results/absolute_counts_table.csv", row.names = 1)
relative_counts <- read.csv("../results/relative_counts_table.csv", row.names = 1)



# read gene tables
gene_counts <- read.csv("../results/gene_counts_clean.csv", row.names = 1)
gene_anno <- read.csv("../results/gene_annotations_clean.csv", row.names = 1)

gene_to_pathway <- read.csv("../../../data/stanford/k2pathway.txt", sep="\t", header=FALSE)
names(gene_to_pathway) <- c("gene", "pathway")
gene_to_pathway$gene <- gsub(pattern = "^ko:", "", gene_to_pathway$gene)
gene_to_pathway$pathway <- gsub(pattern = "^path:", "", gene_to_pathway$pathway)
pathway_to_gene <- gene_to_pathway[, c("pathway", "gene")]

pathway_to_description <- read.csv("../keggmaps_to_name.txt", sep="\t", header=FALSE, colClasses = c("character", "character"))
pathway_to_description$V1 <- gsub(pattern = "^", "map", pathway_to_description$V1)

tax_for_tree <- cbind(taxonomy[, 1:ncol(taxonomy)-1], row.names(taxonomy))
proxy_phylogenetic_tree <- TreeSummarizedExperiment::toTree(tax_for_tree)

ps <- phyloseq(
  otu_table=otu_table(absolute_counts, taxa_are_rows=TRUE), 
  tax_table=tax_table(taxonomy),
  sample_data=sample_data(metadataGut), 
  phy_tree=phy_tree(proxy_phylogenetic_tree)
  )
ps

```

## 16S ps

```{r message=FALSE}

rawMilkMicrobe <- read.csv("../../../data/Milk_Data/17Nov2023/Microbiome/Research_Data/Raw/Features_Counts_df_MISAME.csv")
rawMilkTaxonomy <- read.csv("../Taxonomy_Counts_df_MISAME.csv")

milkTaxonomy <- rawMilkTaxonomy %>%
  group_by(Genus) %>%
  dplyr::mutate(n = row_number(),
         Species = case_when(
           is.na(Species) ~ paste0(Genus, ".sp", n),
           TRUE ~ as.character(Species)
         )) %>%
  ungroup() %>%
  dplyr::select(-n) %>%
  column_to_rownames("X") %>%
  mutate(domain = Kingdom) %>%
  mutate(phylum = Phylum) %>%
  mutate(class = Class) %>%
  mutate(order = Order) %>%
  mutate(family = Family) %>%
  mutate(genus = Genus) %>%
  mutate(species = Species) %>%
  dplyr::select("domain", "phylum", "class", "order", "family", "genus", "species") 

milkTaxonomy <- as.matrix(
  TreeSummarizedExperiment::resolveLoop(as.data.frame(milkTaxonomy))
  )

rownames(milkTaxonomy) <- gsub(" ", ".", rownames(milkTaxonomy))

milkCounts <- rawMilkMicrobe %>%
  column_to_rownames("X") %>%
  t() %>%
  as.data.frame() %>%
  dplyr::select(-contains("pool"))  # Select columns not containing "pool"

milkMetadata <- rawMilkMicrobe %>%
  dplyr::select("X") %>%
  mutate(rownames = X) %>%
  separate(X, into = c("timepoint", "sample", "idbs"), sep = "_") %>%
  separate(idbs, into = c("idbs", "A"), sep = "(?<=[0-9])(?=[A-Za-z])") %>%
  filter(sample == "lama")

metadata$idbs <- as.character(metadata$idbs)  # Convert idbs column to character

milkMetadata <- milkMetadata %>%
  left_join(metadata, by = "idbs") %>%
  column_to_rownames("rownames") %>%
  mutate(abo = ifelse(lbw == 1 | sga_new == 1 | preterm == 1 | 
         c_stunting0 == 1 | c_wasting0 == 1 | c_underweight0 == 1 | biospe_neonatal_mortality == 1, 1, 0)) %>%
  mutate(abo_group = ifelse(timepoint=="1421" & abo==1, "1421_abo",
                     ifelse(timepoint=="1421" & abo==0, "1421_con",
                     ifelse(timepoint=="pn12" & abo==1, "pn12_abo",
                     ifelse(timepoint=="pn12" & abo==0, "pn12_con",
                     ifelse(timepoint=="pn34" & abo==1, "pn34_abo",
                     ifelse(timepoint=="pn34" & abo==0, "pn34_con","other"))))))) %>%
  filter(!is.na(abo_group))

milk_tax_for_tree <- cbind(milkTaxonomy[, 1:ncol(milkTaxonomy)-1], row.names(milkTaxonomy))

# Convert resolved tree to a format suitable for further analysis, if needed
milk_proxy_phylogenetic_tree <- toTree(milk_tax_for_tree)
#milk_proxy_phylogenetic_tree <- TreeSummarizedExperiment::toTree(milk_tax_for_tree)

milkps <- phyloseq(
  otu_table=otu_table(milkCounts, taxa_are_rows=TRUE), 
  tax_table=tax_table(milkTaxonomy),
  sample_data=sample_data(milkMetadata),
  phy_tree=phy_tree(milk_proxy_phylogenetic_tree)
)
milkps

```

## Subset

```{r message=FALSE}

milkps_meta <- subset_samples(milkps, code_bep_n == 1 | code_bep_n == 4)

ps@sam_data$idbs <- as.integer(ps@sam_data$idbs)
milkps_meta@sam_data$idbs <- as.integer(milkps_meta@sam_data$idbs)

ps_meta <- subset_samples(ps, ps@sam_data$idbs %in% milkps_meta@sam_data$idbs)

# normalize data
pslog_meta <- transform_sample_counts(ps_meta, function(x) log(1 + x))

# data supsets
infant_meta <- subset_samples(ps_meta, child=="yes")
mother_meta <- subset_samples(ps_meta, child=="no")

# use log for beta diversity
infantlog_meta <- subset_samples(pslog_meta, child=="yes")
motherlog_meta <- subset_samples(pslog_meta, child=="no")

mother_meta <- subset_samples(mother_meta, mother_meta@sam_data$idbs %in% infant_meta@sam_data$idbs)
milkps_meta <- subset_samples(milkps_meta, milkps_meta@sam_data$idbs %in% infant_meta@sam_data$idbs)

pn12e_meta <- subset_samples(infant_meta, timepoint=="pn12")
pn56e_meta <- subset_samples(infant_meta, timepoint=="pn56")
pn12m_meta <- subset_samples(mother_meta, timepoint=="pn12")
pn56m_meta <- subset_samples(mother_meta, timepoint=="pn56")
incl_meta <- subset_samples(mother_meta, timepoint=="incl")
tri3_meta <- subset_samples(mother_meta, timepoint=="tri3")
X1421h_meta <- subset_samples(milkps_meta, timepoint=="1421")
pn12h_meta <- subset_samples(milkps_meta, timepoint=="pn12")
pn34h_meta <- subset_samples(milkps_meta, timepoint=="pn34")

sort(unique(mother_meta@sam_data$idbs), decreasing = FALSE)
sort(unique(infant_meta@sam_data$idbs), decreasing = FALSE)
sort(unique(tri3_meta@sam_data$idbs), decreasing = FALSE)

sort(unique(milkps_meta@sam_data$idbs), decreasing = FALSE)

X1421h_hmo <- hmo %>%
  dplyr::filter(timepoint == "1421") %>% dplyr:: filter(idbs %in% infant_meta@sam_data$idbs)

pn12h_hmo <- hmo %>%
  dplyr::filter(timepoint == "pn12") %>% dplyr:: filter(idbs %in% infant_meta@sam_data$idbs)

pn34h_hmo <- hmo %>%
  dplyr::filter(timepoint == "pn34") %>% dplyr:: filter(idbs %in% infant_meta@sam_data$idbs)

X1421h_bio <- bio %>%
  dplyr::filter(timepoint == "1421") %>% dplyr:: filter(idbs %in% infant_meta@sam_data$idbs)

pn12h_bio <- bio %>%
  dplyr::filter(timepoint == "pn12") %>% dplyr:: filter(idbs %in% infant_meta@sam_data$idbs)

pn34h_bio <- bio %>%
  dplyr::filter(timepoint == "pn34") %>% dplyr:: filter(idbs %in% infant_meta@sam_data$idbs)

milkMeta <- vitbMeta %>%
  left_join(minMeta %>% dplyr::select(idbs, timepoint, Na, Mg, P., K., Ca, Cr, Fe, Cu, Zn, Mo, As, Mn, Se), by = c("idbs", "timepoint")) %>% 
  left_join(bioMeta %>% dplyr::select(idbs, timepoint, FGF.21, FSH, Insulin, LH, Leptin, Calprotectin, IgA), by = c("idbs", "timepoint")) %>%
  left_join(marMeta %>% dplyr::select(idbs, timepoint, FAT, PROTEIN, CARBOHYDRATE, Kcal.L), by = c("idbs", "timepoint")) %>%
  left_join(fvitMeta %>% dplyr::select(idbs, timepoint, "g.tocopherol", "a.tocopherol", "vitamin.A"), by = c("idbs", "timepoint"))

# One-liner style to create 10-column idbs presence/absence table
idbs_table <- {
  # Extract all ID sets and assign labels
  pn12e_ids    <- unique(as.character(pn12e_meta@sam_data$idbs))
  pn56e_ids    <- unique(as.character(pn56e_meta@sam_data$idbs))
  X1421h_ids   <- unique(as.character(X1421h_meta@sam_data$idbs))
  pn12h_ids    <- unique(as.character(pn12h_meta@sam_data$idbs))
  pn34h_ids    <- unique(as.character(pn34h_meta@sam_data$idbs))
  X1421milk_ids   <- unique(as.character(milkMeta$idbs[milkMeta$timepoint=="1421"]))
  pn12milk_ids    <- unique(as.character(milkMeta$idbs[milkMeta$timepoint=="pn12"]))
  pn34milk_ids    <- unique(as.character(milkMeta$idbs[milkMeta$timepoint=="pn34"]))
  incl_ids     <- unique(as.character(incl_meta@sam_data$idbs))
  tri3_ids     <- unique(as.character(tri3_meta@sam_data$idbs))
  pn12m_ids    <- unique(as.character(pn12m_meta@sam_data$idbs))
  pn56m_ids    <- unique(as.character(pn56m_meta@sam_data$idbs))
  
  # All unique idbs
  all_ids <- sort(unique(c(
    pn12e_ids, pn56e_ids, X1421h_ids, pn12h_ids, pn34h_ids,
    incl_ids, tri3_ids, pn12m_ids, pn56m_ids
  )))
  
  # Create table
  data.frame(
    idbs   = all_ids,
    pn12e  = as.integer(all_ids %in% pn12e_ids),
    pn56e  = as.integer(all_ids %in% pn56e_ids),
    X1421h = as.integer(all_ids %in% X1421h_ids),
    pn12h  = as.integer(all_ids %in% pn12h_ids),
    pn34h  = as.integer(all_ids %in% pn34h_ids),
    X1421milk = as.integer(all_ids %in% X1421milk_ids),
    pn12milk  = as.integer(all_ids %in% pn12milk_ids),
    pn34milk  = as.integer(all_ids %in% pn34milk_ids),
    incl   = as.integer(all_ids %in% incl_ids),
    tri3   = as.integer(all_ids %in% tri3_ids),
    pn12m  = as.integer(all_ids %in% pn12m_ids),
    pn56m  = as.integer(all_ids %in% pn56m_ids)
  )
}

sum(idbs_table$pn12e == 1 & idbs_table$pn12milk == 1 & idbs_table$pn12m == 1)
sum(idbs_table$pn56e == 1 & idbs_table$pn56m == 1)
sum(idbs_table$pn12e == 1 & idbs_table$pn12milk == 1 & idbs_table$pn12m == 1 & idbs_table$pn56e == 1 & idbs_table$pn56m == 1 & idbs_table$X1421milk == 1 & idbs_table$pn34milk == 1 & idbs_table$tri3 == 1)
sum(idbs_table$tri3 == 1 & idbs_table$pn56m == 1 & idbs_table$pn12m == 1)
sum(idbs_table$X1421milk == 1 & idbs_table$pn12milk == 1 & idbs_table$pn34milk == 1)
sum(idbs_table$pn56e == 1 & idbs_table$pn12e == 1)

absolute_counts_t <- absolute_counts%>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("X") %>%
  separate(X, into = c("timePoint","sample", "idbs", "dyads"), sep = "_")

table(absolute_counts_t$timePoint)
unique(absolute_counts_t$idbs)

milk_microbe <- rawMilkMicrobe %>%
  separate(X, into = c("timePoint", "sample", "idbs"), sep = "_") %>%
  filter(timePoint != "MISAME") %>%
  filter(timePoint != "NorthStar") %>%
  mutate(idbs = str_extract(idbs, "\\d{3}")) %>%
  left_join(metadata %>% select(idbs, code_bep_n)) %>%
  filter(code_bep_n == 1 | code_bep_n == 4)

table(milk_microbe$timePoint)
unique(milk_microbe$idbs)

table(milkMeta$timepoint)
unique(milkMeta$idbs)

```

# Hierarchical clustering

## Fig2A Infant gut pn12 genera

```{r message=FALSE}

milkps_meta <- subset_samples(milkps, code_bep_n == 1 | code_bep_n == 4)

ps@sam_data$idbs <- as.integer(ps@sam_data$idbs)
milkps_meta@sam_data$idbs <- as.integer(milkps_meta@sam_data$idbs)

ps_meta <- subset_samples(ps, ps@sam_data$idbs %in% milkps_meta@sam_data$idbs)

pn12e_meta <- subset_samples(ps_meta, child=="yes" & timepoint=="pn12")

# Step 1: Prepare relative abundance data at the genus level
otu_table_genus <- pn12e_meta %>%
  tax_glom(taxrank = "genus") %>%  # Aggregate by genus level
  transform_sample_counts(function(x) x / sum(x)) %>%  # Convert to relative abundance
  psmelt() %>%  # Convert to long format
  filter(Abundance > 0)  # Remove zeros

# Step 2: Identify top 15 genera and group others
genus_abundance <- otu_table_genus %>%
  group_by(genus) %>%
  dplyr::summarise(total_abundance = sum(Abundance, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(total_abundance))  # Summarize total abundance by genus

top_15_genera <- genus_abundance %>%
  slice_head(n = 15) %>%  # Select top 15 genera
  pull(genus)  # Extract genus names

otu_table_genus_grouped <- otu_table_genus %>%
  mutate(genus = if_else(genus %in% top_15_genera, genus, "Others")) %>%  # Group non-top genera as "Others"
  group_by(Sample, genus) %>%
  dplyr::summarise(Abundance = sum(Abundance, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = genus, values_from = Abundance, values_fill = 0)  # Convert to wide format

# Step 3: Convert to matrix
otu_table_genus_matrix <- otu_table_genus_grouped %>%
  column_to_rownames("Sample") %>%
  as.matrix()

# Step 4: Perform hierarchical clustering
hc <- hclust(vegdist(otu_table_genus_matrix, method = "bray"), method = "ward.D2")  # Bray-Curtis + Ward's method

# Step 5: Color the dendrogram
dend_colored <- as.dendrogram(hc) %>%
  color_branches(k = 3)  # Color branches into 4 clusters

# Step 6: Annotate row clusters
row_clusters <- cutree(hc, k = 3)  # Assign samples to 4 clusters
row_annotation <- data.frame(Cluster = factor(row_clusters))  # Create annotation data frame
rownames(row_annotation) <- rownames(otu_table_genus_matrix)  # Match row names

# Step 7: Define cluster colors
cluster_colors <- list(
  Cluster = c(
    "1" = "#00A98F",
    "2" = "#FFC000",
    "3" = "#1565A9"

  )
)

# Step 8: Calculate the mean relative abundance for each genus
mean_abundance <- colMeans(otu_table_genus_matrix, na.rm = TRUE)  # Calculate mean relative abundance per genus

# Step 9: Order the genera by their mean relative abundance
ordered_genera <- names(sort(mean_abundance, decreasing = TRUE))  # Sort genera in descending order

# Step 10: Reorder the columns of the OTU table based on relative abundance
otu_table_genus_matrix_ordered <- otu_table_genus_matrix[, ordered_genera]

# Step 11: Define a custom color palette without blue
library(RColorBrewer)
custom_colors <- colorRampPalette(c("lightyellow", "orange", "red"))(50)


#svglite::svglite(
#  filename="./forISRHML/heatmap_pn12e_genera.svg",
#  width=6, height=5
#  )

# Step 12: Plot the heatmap with the custom color palette
pheatmap(
  otu_table_genus_matrix_ordered,  # Use the reordered matrix
  cluster_rows = hc,  # Use hierarchical clustering for rows
  cluster_cols = FALSE,  # Do not cluster columns
  scale = "none",  # Keep original values (no scaling)
  main = "Infant PN12: Top 15 Genera ",
  show_rownames = FALSE,  # Hide sample names for clarity
  show_colnames = TRUE,   # Show genus names
  annotation_row = row_annotation,  # Add row cluster annotations
  annotation_colors = cluster_colors,  # Define cluster colors
  color = custom_colors  # Custom color palette
)

#dev.off()
```

## FigS4A&B Infant gut pn56 genera

This is just for visualize if the infants change clusters with time

```{r}

# Step 1: Prepare relative abundance data at the genus level
otu_table_genus2 <- pn56e_meta %>%
  tax_glom(taxrank = "genus") %>%  # Aggregate by genus level
  transform_sample_counts(function(x) x / sum(x)) %>%  # Convert to relative abundance
  psmelt() %>%  # Convert to long format
  filter(Abundance > 0)  # Remove zeros

# Step 2: Identify top 15 genera and group others
genus_abundance2 <- otu_table_genus2 %>%
  group_by(genus) %>%
  dplyr::summarise(total_abundance = sum(Abundance, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(total_abundance))  # Summarize total abundance by genus

top_15_genera2 <- genus_abundance2 %>%
  slice_head(n = 15) %>%  # Select top 15 genera
  pull(genus)  # Extract genus names

otu_table_genus_grouped2 <- otu_table_genus2 %>%
  mutate(genus = if_else(genus %in% top_15_genera2, genus, "Others")) %>%  # Group non-top genera as "Others"
  group_by(Sample, genus) %>%
  dplyr::summarise(Abundance = sum(Abundance, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = genus, values_from = Abundance, values_fill = 0)  # Convert to wide format

# Step 3: Convert to matrix
otu_table_genus_matrix2 <- otu_table_genus_grouped2 %>%
  column_to_rownames("Sample") %>%
  as.matrix()

# Step 4: Perform hierarchical clustering
hc2 <- hclust(vegdist(otu_table_genus_matrix2, method = "bray"), method = "ward.D2")  # Bray-Curtis + Ward's method

# Step 5: Color the dendrogram
dend_colored2 <- as.dendrogram(hc2) %>%
  color_branches(k = 3)  # Color branches into 3 clusters

# Step 6: Annotate row clusters
row_clusters2 <- cutree(hc2, k = 3)  # Assign samples to 3 clusters
row_annotation2 <- data.frame(Cluster = factor(row_clusters2))  # Create annotation data frame
rownames(row_annotation2) <- rownames(otu_table_genus_matrix2)  # Match row names

# Step 7: Define cluster colors
cluster_colors2 <- list(
  Cluster = c(
    "1" = "#00A98F",
    "2" = "#FFC000",
    "3" = "#1565A9"
  )
)

# Step 8: Calculate the mean relative abundance for each genus
mean_abundance2 <- colMeans(otu_table_genus_matrix2, na.rm = TRUE)  # Calculate mean relative abundance per genus

# Step 9: Order the genera by their mean relative abundance
ordered_genera2 <- names(sort(mean_abundance2, decreasing = TRUE))  # Sort genera in descending order

# Step 10: Reorder the columns of the OTU table based on relative abundance
otu_table_genus_matrix_ordered2 <- otu_table_genus_matrix2[, ordered_genera2]

# Step 11: Define a custom color palette without blue
library(RColorBrewer)
custom_colors2 <- colorRampPalette(c("lightyellow", "orange", "red"))(50)


# svglite::svglite(
#   filename="./forISRHML/heatmap_pn56e_genera_2cl.svg",
#   width=6, height=5
#   )

# Step 12: Plot the heatmap with the custom color palette
pheatmap(
  otu_table_genus_matrix_ordered2,  # Use the reordered matrix
  cluster_rows = hc2,  # Use hierarchical clustering for rows
  cluster_cols = FALSE,  # Do not cluster columns
  scale = "none",  # Keep original values (no scaling)
  main = "Infant PN56: Top 15 Genera ",
  show_rownames = FALSE,  # Hide sample names for clarity
  show_colnames = TRUE,   # Show genus names
  annotation_row = row_annotation2,  # Add row cluster annotations
  annotation_colors = cluster_colors2,  # Define cluster colors
  color = custom_colors2  # Custom color palette
)

# dev.off()

table(row_annotation2$Cluster)

row_annotation_idbs <- row_annotation %>%
  rownames_to_column(var = "rownames") %>%
  separate(rownames, into = c("timepoint", "sample", "idbs", "dyads"), sep = "_") %>%
  filter(timepoint == "pn12") %>%
  dplyr::select(idbs, Cluster) %>%
  dplyr::mutate(Cluster = case_when(
    Cluster == "1" ~ "C1",
    Cluster == "2" ~ "C2",
    Cluster == "3" ~ "C3",
    TRUE ~ Cluster  # Keep other values unchanged, if any
  ))%>%
  mutate(
    Cluster = factor(Cluster, levels = c("C1", "C2", "C3")))  # Set Cluster level order

row_annotationAll <- row_annotation2 %>%
  #mutate(Cluster = if_else(Cluster == "2", "4", if_else(Cluster=="3", "2", if_else(Cluster== "4", "5", Cluster)))) %>%
  rownames_to_column(var = "rownames") %>%
  separate(rownames, into = c("timepoint", "sample", "idbs", "dyads"), sep = "_") %>%
  dplyr::select(idbs, Cluster) %>%
  right_join(row_annotation_idbs, by = "idbs") %>%
  mutate(Cluster1 = if_else(Cluster.y == "C1", "1", if_else(Cluster.y == "C2", "2", "3"))) %>%
  mutate(Cluster2 = Cluster.x) %>%
  select(idbs, Cluster1, Cluster2) %>%
  pivot_longer(
    cols = c(Cluster1, Cluster2),
    names_to = "timepoint",
    names_pattern = "Cluster(\\d)",  # extract 1 or 2
    values_to = "cluster"
  ) %>%
    mutate(
    timepoint = as.integer(timepoint),
    cluster = as.integer(cluster)
  ) 

cluster_colors <- list(
  Cluster = c(
    "1" = "#00A98F",
    "2" = "#FFC000",
    "3" = "#1565A9"
  )
)

clusterChange <- ggplot(row_annotationAll, aes(x = timepoint, y = cluster, group = idbs)) +
  geom_line(aes(color = factor(cluster)), 
            position = position_jitter(width = 0, height = 0.1), 
            size = 0.7, alpha = 0.7) +
  geom_point(aes(color = factor(cluster)), 
             position = position_jitter(width = 0, height = 0.1),
             size = 2) +
  scale_color_manual(values = cluster_colors$Cluster) +
  scale_x_continuous(breaks = c(1, 2), labels = c("Timepoint 1", "Timepoint 2")) +
  scale_y_continuous(breaks = c(1, 2, 3), labels = c("Cluster 1", "Cluster 2", "Cluster 3")) +
  labs(x = "Timepoint", y = "Cluster", 
       title = "Cluster Transitions for Each Participant") +
  theme_minimal() +
  theme(legend.position = "bottom")

clusterChange

# svglite::svglite(
#   filename="./forISRHML/heatmap_Pn12epn56e_clusterChange.svg",
#   width=6, height=5
#   )
# clusterChange
# dev.off()
 
```

## ü§ç for reviewer - 6 clusters

```{r}

milkps_meta <- subset_samples(milkps, code_bep_n == 1 | code_bep_n == 4)

ps@sam_data$idbs <- as.integer(ps@sam_data$idbs)
milkps_meta@sam_data$idbs <- as.integer(milkps_meta@sam_data$idbs)

ps_meta <- subset_samples(ps, ps@sam_data$idbs %in% milkps_meta@sam_data$idbs)

pn12e_meta <- subset_samples(ps_meta, child=="yes" & timepoint=="pn12")

# Step 1: Prepare relative abundance data at the genus level
otu_table_genus <- pn12e_meta %>%
  tax_glom(taxrank = "genus") %>%  # Aggregate by genus level
  transform_sample_counts(function(x) x / sum(x)) %>%  # Convert to relative abundance
  psmelt() %>%  # Convert to long format
  filter(Abundance > 0)  # Remove zeros

# Step 2: Identify top 15 genera and group others
genus_abundance <- otu_table_genus %>%
  group_by(genus) %>%
  dplyr::summarise(total_abundance = sum(Abundance, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(total_abundance))  # Summarize total abundance by genus

top_15_genera <- genus_abundance %>%
  slice_head(n = 15) %>%  # Select top 15 genera
  pull(genus)  # Extract genus names

otu_table_genus_grouped <- otu_table_genus %>%
  mutate(genus = if_else(genus %in% top_15_genera, genus, "Others")) %>%  # Group non-top genera as "Others"
  group_by(Sample, genus) %>%
  dplyr::summarise(Abundance = sum(Abundance, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = genus, values_from = Abundance, values_fill = 0)  # Convert to wide format

# Step 3: Convert to matrix
otu_table_genus_matrix <- otu_table_genus_grouped %>%
  column_to_rownames("Sample") %>%
  as.matrix()

# Step 4: Perform hierarchical clustering
hc <- hclust(vegdist(otu_table_genus_matrix, method = "bray"), method = "ward.D2")  # Bray-Curtis + Ward's method

# Step 5: Color the dendrogram
dend_colored <- as.dendrogram(hc) %>%
  color_branches(k = 6)  # Color branches into 4 clusters

# Step 6: Annotate row clusters
row_clusters <- cutree(hc, k = 6)  # Assign samples to 4 clusters
row_annotation <- data.frame(Cluster = factor(row_clusters))  # Create annotation data frame
rownames(row_annotation) <- rownames(otu_table_genus_matrix)  # Match row names

# Step 7: Define cluster colors
cluster_colors <- list(
  Cluster = c(
    "1" = "#00A98F",
    "2" = "#FFC000",
    "3" = "#1565A9",
    "4" = "#C00000",
    "5" = "#0D0D0D",
    "6" = "#6aa84f"
  )
)

# Step 8: Calculate the mean relative abundance for each genus
mean_abundance <- colMeans(otu_table_genus_matrix, na.rm = TRUE)  # Calculate mean relative abundance per genus

# Step 9: Order the genera by their mean relative abundance
ordered_genera <- names(sort(mean_abundance, decreasing = TRUE))  # Sort genera in descending order

# Step 10: Reorder the columns of the OTU table based on relative abundance
otu_table_genus_matrix_ordered <- otu_table_genus_matrix[, ordered_genera]

# Step 11: Define a custom color palette without blue
library(RColorBrewer)
custom_colors <- colorRampPalette(c("lightyellow", "orange", "red"))(50)


#svglite::svglite(
#  filename="./forISRHML/Revision/heatmap_pn12e_genera_6cluster.svg",
#  width=6, height=5
#  )

# Step 12: Plot the heatmap with the custom color palette
pheatmap(
  otu_table_genus_matrix_ordered,  # Use the reordered matrix
  cluster_rows = hc,  # Use hierarchical clustering for rows
  cluster_cols = FALSE,  # Do not cluster columns
  scale = "none",  # Keep original values (no scaling)
  main = "Infant PN12: Top 15 Genera ",
  show_rownames = FALSE,  # Hide sample names for clarity
  show_colnames = TRUE,   # Show genus names
  annotation_row = row_annotation,  # Add row cluster annotations
  annotation_colors = cluster_colors,  # Define cluster colors
  color = custom_colors  # Custom color palette
)

#dev.off()

```

## ü§ç for reviewer - 6 clusters

```{r}

# Step 1: Prepare relative abundance data at the genus level
otu_table_genus2 <- pn56e_meta %>%
  tax_glom(taxrank = "genus") %>%  # Aggregate by genus level
  transform_sample_counts(function(x) x / sum(x)) %>%  # Convert to relative abundance
  psmelt() %>%  # Convert to long format
  filter(Abundance > 0)  # Remove zeros

# Step 2: Identify top 15 genera and group others
genus_abundance2 <- otu_table_genus2 %>%
  group_by(genus) %>%
  dplyr::summarise(total_abundance = sum(Abundance, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(total_abundance))  # Summarize total abundance by genus

top_15_genera2 <- genus_abundance2 %>%
  slice_head(n = 15) %>%  # Select top 15 genera
  pull(genus)  # Extract genus names

otu_table_genus_grouped2 <- otu_table_genus2 %>%
  mutate(genus = if_else(genus %in% top_15_genera2, genus, "Others")) %>%  # Group non-top genera as "Others"
  group_by(Sample, genus) %>%
  dplyr::summarise(Abundance = sum(Abundance, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = genus, values_from = Abundance, values_fill = 0)  # Convert to wide format

# Step 3: Convert to matrix
otu_table_genus_matrix2 <- otu_table_genus_grouped2 %>%
  column_to_rownames("Sample") %>%
  as.matrix()

# Step 4: Perform hierarchical clustering
hc2 <- hclust(vegdist(otu_table_genus_matrix2, method = "bray"), method = "ward.D2")  # Bray-Curtis + Ward's method

# Step 5: Color the dendrogram
dend_colored2 <- as.dendrogram(hc2) %>%
  color_branches(k = 6)  # Color branches into 3 clusters

# Step 6: Annotate row clusters
# Step 6: Annotate row clusters (ensure all 6 levels exist)
row_clusters2 <- cutree(hc2, k = 6)
row_annotation2 <- data.frame(
  Cluster = factor(row_clusters2, levels = as.character(1:6))
)
rownames(row_annotation2) <- rownames(otu_table_genus_matrix2)
row_annotation2 <- row_annotation2 %>%
  dplyr::mutate(
    Cluster = as.character(Cluster),
    Cluster = dplyr::case_when(
      Cluster == "2" ~ "5",
      Cluster == "3" ~ "2",
      Cluster == "5" ~ "3",
      TRUE ~ Cluster
    ),
    Cluster = factor(Cluster, levels = c("1","2","3","4","5","6"))
  )
# Step 7: Define cluster colors
cluster_colors <- list(
  Cluster = c(
    "1" = "#00A98F",
    "2" = "#FFC000",
    "3" = "#1565A9",
    "4" = "#C00000",
    "5" = "#0D0D0D",
    "6" = "#6aa84f"
  )
)

# Step 8: Calculate the mean relative abundance for each genus
mean_abundance2 <- colMeans(otu_table_genus_matrix2, na.rm = TRUE)  # Calculate mean relative abundance per genus

# Step 9: Order the genera by their mean relative abundance
ordered_genera2 <- names(sort(mean_abundance2, decreasing = TRUE))  # Sort genera in descending order

# Step 10: Reorder the columns of the OTU table based on relative abundance
otu_table_genus_matrix_ordered2 <- otu_table_genus_matrix2[, ordered_genera2]

# Step 11: Define a custom color palette without blue
library(RColorBrewer)
custom_colors2 <- colorRampPalette(c("lightyellow", "orange", "red"))(50)


# svglite::svglite(
#   filename="./forISRHML/Revision/heatmap_pn56e_genera_6cl.svg",
#   width=6, height=5
#   )

# Step 12: Plot the heatmap with the custom color palette
pheatmap(
  otu_table_genus_matrix_ordered2,  # Use the reordered matrix
  cluster_rows = hc2,  # Use hierarchical clustering for rows
  cluster_cols = FALSE,  # Do not cluster columns
  scale = "none",  # Keep original values (no scaling)
  main = "Infant PN56: Top 15 Genera ",
  show_rownames = FALSE,  # Hide sample names for clarity
  show_colnames = TRUE,   # Show genus names
  annotation_row = row_annotation2,  # Add row cluster annotations
  annotation_colors = cluster_colors,  # Define cluster colors
  color = custom_colors2  # Custom color palette
)

#dev.off()

table(row_annotation2$Cluster)

row_annotation_idbs <- row_annotation %>%
  rownames_to_column(var = "rownames") %>%
  separate(rownames, into = c("timepoint", "sample", "idbs", "dyads"), sep = "_") %>%
  filter(timepoint == "pn12") %>%
  dplyr::select(idbs, Cluster) %>%
  dplyr::mutate(Cluster = case_when(
    Cluster == "1" ~ "C1",
    Cluster == "2" ~ "C2",
    Cluster == "3" ~ "C3",
    Cluster == "4" ~ "C4",
    Cluster == "5" ~ "C5",
    Cluster == "6" ~ "C6",
    TRUE ~ Cluster  # Keep other values unchanged, if any
  ))%>%
  mutate(
    Cluster = factor(Cluster, levels = c("C1", "C2", "C3", "C4", "C5", "C6")))  # Set Cluster level order

row_annotationAll <- row_annotation2 %>%
  rownames_to_column(var = "rownames") %>%
  tidyr::separate(rownames, into = c("timepoint", "sample", "idbs", "dyads"),
                  sep = "_", fill = "right", remove = FALSE) %>%
  dplyr::select(idbs, Cluster.x = Cluster) %>%                # timepoint 2 clusters ("1".."6")
  dplyr::right_join(                                          # keep only ids present in tp1 map
    row_annotation_idbs %>% dplyr::transmute(idbs, Cluster.y = Cluster),  # "C1".."C6"
    by = "idbs"
  ) %>%
  dplyr::mutate(
    Cluster1 = sub("^C", "", as.character(Cluster.y)),  # "C1"->"1", ..., "C6"->"6"
    Cluster2 = as.character(Cluster.x)
  ) %>%
  dplyr::select(idbs, Cluster1, Cluster2) %>%
  tidyr::pivot_longer(
    cols = c(Cluster1, Cluster2),
    names_to = "timepoint",
    names_pattern = "Cluster(\\d)",                     # 1 = tp1, 2 = tp2
    values_to = "cluster"
  ) %>%
  dplyr::mutate(
    timepoint = as.integer(timepoint),
    cluster   = suppressWarnings(as.integer(cluster))
  ) %>%
  dplyr::filter(!is.na(cluster))                        # drop any rows with missing cluster

cluster_colors <- list(
  Cluster = c(
    "1" = "#00A98F",
    "2" = "#FFC000",
    "3" = "#1565A9",
    "4" = "#C00000",
    "5" = "#0D0D0D",
    "6" = "#6aa84f"
  )
)

clusterChange <- ggplot(row_annotationAll, aes(x = timepoint, y = cluster, group = idbs)) +
  geom_line(aes(color = factor(cluster)), 
            position = position_jitter(width = 0, height = 0.1), 
            size = 0.7, alpha = 0.7) +
  geom_point(aes(color = factor(cluster)), 
             position = position_jitter(width = 0, height = 0.1),
             size = 2) +
  scale_color_manual(values = cluster_colors$Cluster) +
  scale_x_continuous(breaks = c(1, 2), labels = c("Timepoint 1", "Timepoint 2")) +
  scale_y_continuous(breaks = c(1, 2, 3,4,5,6), labels = c("Cluster 1", "Cluster 2", "Cluster 3", "Cluster 4", "Cluster 5", "Cluster 6")) +
  labs(x = "Timepoint", y = "Cluster", 
       title = "Cluster Transitions for Each Participant") +
  theme_minimal() +
  theme(legend.position = "bottom")

clusterChange

table(row_annotation$Cluster)
table(row_annotation2$Cluster)

#svglite::svglite(
#  filename="./forISRHML/Revision/heatmap_Pn12epn56e_clusterChange_6cluster.svg",
#   width=6, height=5
#   )
# clusterChange
# dev.off()
 
```

## ü§ç for reviewer - relative abundance

```{r}

row_annotation_reviewer <- row_annotation %>%
  rownames_to_column(var = "rownames") %>%
  separate(rownames, into = c("timepoint", "sample", "idbs", "dyads"), sep = "_") %>%
  filter(timepoint == "pn12") %>%
  dplyr::select(idbs, Cluster) %>%
  dplyr::mutate(Cluster = case_when(
    Cluster == "1" ~ "C1",
    Cluster == "2" ~ "C2",
    Cluster == "3" ~ "C3",
    Cluster == "4" ~ "C4",
    Cluster == "5" ~ "C5",
    Cluster == "6" ~ "C6",
    TRUE ~ Cluster  # Keep other values unchanged, if any
  ))%>%
  mutate(
    Cluster = factor(Cluster, levels = c("C1", "C2", "C3", "C4", "C5", "C6")))  # Set Cluster level order

metadataGut2 <- metadataGut %>%
  rownames_to_column(var = "original_rownames") %>%  # Preserve original rownames
  dplyr::mutate(idbs = as.character(idbs)) %>%  # Convert `idbs` to character
  left_join(row_annotation_reviewer, by = "idbs") %>%  # Perform the join
  column_to_rownames(var = "original_rownames") 

milkMetadata2 <- milkMetadata %>%
  rownames_to_column(var = "original_rownames") %>%  # Preserve original rownames
  mutate(idbs = as.character(idbs)) %>%  # Convert `idbs` to character
  left_join(row_annotation_reviewer, by = "idbs") %>%  # Perform the join
  column_to_rownames(var = "original_rownames")  # Restore original rownames


ps_reviewer <- phyloseq(
  otu_table=otu_table(absolute_counts, taxa_are_rows=TRUE), 
  tax_table=tax_table(taxonomy),
  sample_data=sample_data(metadataGut2), 
  phy_tree=phy_tree(proxy_phylogenetic_tree)
  )

infant_reviewer <- subset_samples(ps_reviewer, child=="yes")  

genus_name <- c("Bifidobacterium", "Escherichia",  "Bacteroides", "Prevotella",  "Veillonella_A", "Klebsiella","Parolsenella", "Campylobacter_D", "Streptococcus", "Parabacteroides", "Phocaeicola",  "Veillonella", "Megasphaera", "Akkermansia", "Sutterella", "Other")
genus_color <- c( "coral1", "bisque3", "#28E2E5", "#2986cc", "brown", "gold4", "palegreen", "thistle", "slateblue2", "yellow2", "azure4", "forestgreen", "lightblue", "skyblue", "tan2", "gray")

infant_genus <- infant_reviewer %>%
  tax_glom(taxrank = "genus") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  #filter(Abundance > 0) %>%
  mutate(timepoint = factor(timepoint, 
                       levels = c("pn12", "pn56"),  
                       labels = c("Pn12", "Pn56"))) 
infant_genus <- infant_genus %>% filter(!is.na(Cluster))
sort_infant_genus <- infant_genus %>%
  dplyr::count(genus, wt = Abundance) %>%
  arrange(desc(n)) %>%
  slice_head(n = 15) %>%
  pull(genus)

infant_genus$genus_grouped <- ifelse(infant_genus$genus %in% sort_infant_genus, as.character(infant_genus$genus), "Other")

sample_order_genus <- infant_genus %>%
  group_by(Cluster) %>%
  dplyr::summarize(Abundance = mean(Abundance)) %>%
  arrange(desc(Abundance)) %>%
  pull(Cluster)

genus_order <- infant_genus %>%
  group_by(genus_grouped) %>%
  dplyr::summarize(Abundance = mean(Abundance)) %>%
  arrange(desc(Abundance)) %>%
  pull(genus_grouped)

# Generate the plot with ordered x-axis
infant_genus_plot <- infant_genus %>%
  mutate(genus_grouped = factor(genus_grouped, levels = genus_order)) %>%
  ggplot(aes(x = Cluster, y = Abundance, fill = genus_grouped)) +
  geom_bar(stat = 'identity', position = 'fill', color = NA, size = 0) +
  scale_fill_manual(breaks = genus_name, values = genus_color) + 
  facet_wrap(~timepoint) +
  theme(
    axis.text.x = element_text(size = 8),
    legend.title = element_text(size = 8),
    legend.key.size = unit(0.3, 'cm'),
    legend.text = element_text(size = 8),
    panel.grid = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  labs(x = "", y = "Relative Abundance (%)", fill = "Genus") +
  guides(fill = guide_legend(ncol = 1))
infant_genus_plot

# Save the plot as an SVG file
#svglite::svglite(
#  filename = "./forISRHML/Revision/cluster_gut_infant_genus_6cluster.svg",
#  width = 6, height = 4.5
#)
#print(infant_genus_plot)
#dev.off()

```

## ü§ç for reviewer - secretors

```{r}

metadataGut_reviewer <- metadataGut %>%
  rownames_to_column(var = "original") %>%
  mutate(idbs = as.character(idbs)) %>%
  left_join(
    hmoMeta %>%
      mutate(idbs = as.character(idbs)) %>%
      select(idbs, Secretor) %>%
      distinct(idbs, .keep_all = TRUE),   # <-- keep only one row per idbs
    by = "idbs"
  ) %>%
  mutate(Secretor = as.factor(Secretor)) %>%
  column_to_rownames(var = "original") 

ps_secretor <- phyloseq(
  otu_table=otu_table(absolute_counts, taxa_are_rows=TRUE), 
  tax_table=tax_table(taxonomy),
  sample_data=sample_data(metadataGut_reviewer), 
  phy_tree=phy_tree(proxy_phylogenetic_tree)
  )

infant_secretor <- subset_samples(ps_secretor, child=="yes")  

genus_name <- c("Bifidobacterium", "Escherichia",  "Bacteroides", "Prevotella",  "Veillonella_A", "Klebsiella","Parolsenella", "Campylobacter_D", "Streptococcus", "Parabacteroides", "Phocaeicola",  "Veillonella", "Megasphaera", "Akkermansia", "Sutterella", "Other")
genus_color <- c( "coral1", "bisque3", "#28E2E5", "#2986cc", "brown", "gold4", "palegreen", "thistle", "slateblue2", "yellow2", "azure4", "forestgreen", "lightblue", "skyblue", "tan2", "gray")

infant_genus <- infant_secretor %>%
  tax_glom(taxrank = "genus") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  #filter(Abundance > 0) %>%
  mutate(timepoint = factor(timepoint, 
                       levels = c("pn12", "pn56"),  
                       labels = c("Pn12", "Pn56"))) 
infant_genus <- infant_genus %>% filter(!is.na(Secretor))
sort_infant_genus <- infant_genus %>%
  dplyr::count(genus, wt = Abundance) %>%
  arrange(desc(n)) %>%
  slice_head(n = 15) %>%
  pull(genus)

infant_genus$genus_grouped <- ifelse(infant_genus$genus %in% sort_infant_genus, as.character(infant_genus$genus), "Other")

sample_order_genus <- infant_genus %>%
  group_by(Secretor) %>%
  dplyr::summarize(Abundance = mean(Abundance)) %>%
  arrange(desc(Abundance)) %>%
  pull(Secretor)

genus_order <- infant_genus %>%
  group_by(genus_grouped) %>%
  dplyr::summarize(Abundance = mean(Abundance)) %>%
  arrange(desc(Abundance)) %>%
  pull(genus_grouped)

# Generate the plot with ordered x-axis
infant_genus_plot <- infant_genus %>%
  mutate(genus_grouped = factor(genus_grouped, levels = genus_order)) %>%
  ggplot(aes(x = Secretor, y = Abundance, fill = genus_grouped)) +
  geom_bar(stat = 'identity', position = 'fill', color = NA, size = 0) +
  scale_fill_manual(breaks = genus_name, values = genus_color) + 
  facet_wrap(~timepoint) +
  theme(
    axis.text.x = element_text(size = 8),
    legend.title = element_text(size = 8),
    legend.key.size = unit(0.3, 'cm'),
    legend.text = element_text(size = 8),
    panel.grid = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  labs(x = "", y = "Relative Abundance (%)", fill = "Genus") +
  guides(fill = guide_legend(ncol = 1))
infant_genus_plot

# Save the plot as an SVG file
#svglite::svglite(
#  filename = "./forISRHML/Revision/infant_relativeAbundance_secretor.svg",
#  width = 4, height = 4.5
#)
#print(infant_genus_plot)
#dev.off()

```

# New metagenomic ps - cluster added

```{r}

# Convert `pn12e_date` to Date class
ps_date$pn12e_date <- as.Date(ps_date$pn12e_date, format = "%y-%m-%d")
ps_date$pn56e_date <- as.Date(ps_date$pn56e_date, format = "%y-%m-%d")
ps_date$pn12m_date <- as.Date(ps_date$pn12m_date, format = "%y-%m-%d")
ps_date$pn56m_date <- as.Date(ps_date$pn56m_date, format = "%y-%m-%d")
ps_date$incl_date <- as.Date(ps_date$incl_date, format = "%y-%m-%d")
ps_date$tri3_date <- as.Date(ps_date$tri3_date, format = "%y-%m-%d")

row_annotation_idbs <- row_annotation %>%
  rownames_to_column(var = "rownames") %>%
  separate(rownames, into = c("timepoint", "sample", "idbs", "dyads"), sep = "_") %>%
  filter(timepoint == "pn12") %>%
  dplyr::select(idbs, Cluster) %>%
  dplyr::mutate(Cluster = case_when(
    Cluster == "1" ~ "C1",
    Cluster == "2" ~ "C2",
    Cluster == "3" ~ "C3",
    TRUE ~ Cluster  # Keep other values unchanged, if any
  ))%>%
  mutate(
    Cluster = factor(Cluster, levels = c("C1", "C2", "C3")))  # Set Cluster level order

metadataGut2 <- metadataGut %>%
  rownames_to_column(var = "original_rownames") %>%  # Preserve original rownames
  dplyr::mutate(idbs = as.character(idbs)) %>%  # Convert `idbs` to character
  left_join(row_annotation_idbs, by = "idbs") %>%  # Perform the join
  left_join(purge_pn12 %>%
            dplyr::select(pn12e_idbs, pn12e_evpu, pn12e_pufr, pn12e_lapu, pn12e_puty, pn12e_pure, pn12e_mpre),
            by = c("idbs" = "pn12e_idbs")) %>%
  left_join(ps_date, by = "idbs") %>%
  column_to_rownames(var = "original_rownames") %>% # Restore original rownames
  mutate(
    pn12e_age = as.numeric(difftime(pn12e_date, dob, units = "weeks")),  # Calculate age in weeks
    pn56e_age = as.numeric(difftime(pn56e_date, dob, units = "weeks"))  # Calculate age in weeks for pn56
  )


milkMetadata2 <- milkMetadata %>%
  rownames_to_column(var = "original_rownames") %>%  # Preserve original rownames
  mutate(idbs = as.character(idbs)) %>%  # Convert `idbs` to character
  left_join(row_annotation_idbs, by = "idbs") %>%  # Perform the join
  column_to_rownames(var = "original_rownames")  # Restore original rownames


ps <- phyloseq(
  otu_table=otu_table(absolute_counts, taxa_are_rows=TRUE), 
  tax_table=tax_table(taxonomy),
  sample_data=sample_data(metadataGut2), 
  phy_tree=phy_tree(proxy_phylogenetic_tree)
  )

milkps <- phyloseq(
  otu_table=otu_table(milkCounts, taxa_are_rows=TRUE), 
  tax_table=tax_table(milkTaxonomy),
  sample_data=sample_data(milkMetadata2),
  phy_tree=phy_tree(milk_proxy_phylogenetic_tree)
)
milkps

milkps_meta <- subset_samples(milkps, code_bep_n == 1 | code_bep_n == 4)
ps_meta <- subset_samples(ps, ps@sam_data$idbs %in% milkps_meta@sam_data$idbs)
milkps_meta@sam_data$idbs <- as.integer(milkps_meta@sam_data$idbs)
ps@sam_data$idbs <- as.integer(ps@sam_data$idbs)

# data supsets
infant_meta <- subset_samples(ps_meta, child=="yes")
infant_meta <- subset_samples(infant_meta, !(idbs %in% c(532, 559, 563, 203)))

mother_meta <- subset_samples(ps_meta, child=="no")

mother_meta <- subset_samples(mother_meta, mother_meta@sam_data$idbs %in% infant_meta@sam_data$idbs)
milkps_meta <- subset_samples(milkps_meta, milkps_meta@sam_data$idbs %in% infant_meta@sam_data$idbs)

pn12e_meta <- subset_samples(infant_meta, timepoint=="pn12")
pn56e_meta <- subset_samples(infant_meta, timepoint=="pn56")
pn12m_meta <- subset_samples(mother_meta, timepoint=="pn12")
pn56m_meta <- subset_samples(mother_meta, timepoint=="pn56")
incl_meta <- subset_samples(mother_meta, timepoint=="incl")
tri3_meta <- subset_samples(mother_meta, timepoint=="tri3")
X1421h_meta <- subset_samples(milkps_meta, timepoint=="1421")
pn12h_meta <- subset_samples(milkps_meta, timepoint=="pn12")
pn34h_meta <- subset_samples(milkps_meta, timepoint=="pn34")

sort(unique(pn12e_meta@sam_data$idbs), decreasing = FALSE)
sort(unique(pn56e_meta@sam_data$idbs), decreasing = FALSE)
setdiff(pn56e_meta@sam_data$idbs, pn12e_meta@sam_data$idbs)

```

# baseline

## FigS3A Baseline for 3 clusters

```{r}
metadata_cluster <- metadataGut2 %>%
  dplyr::select(idbs, Cluster, ch_sex,c_hemoglobin6, morb_observation_tot, hh_size, hh_child5, impr_water, impr_sanitation, svn, lbw, sga_new, preterm, code, gravidity, HH_food_insecurity, w_age, iycf_ebf_age, m_weightincl, m_heightincl, m_bmiincl, m_hbincl, mddw_10_ave, asset1comp_10, season_lean, m_muacincl, GWG, GAbirthweeks, c_weight0, c_weight1, c_weight2, c_weight3, c_weight4, c_weight5, c_weight6, c_height0, c_height1, c_height2, c_height3, c_height4, c_height5, c_height6, c_headc0, c_headc1, c_headc2, c_headc3, c_headc4, c_headc5, c_headc6, c_muac0, c_muac1, c_muac2, c_muac3, c_muac4, c_muac5, c_muac6, c_whz0, c_whz1, c_whz2, c_whz3, c_whz4, c_whz5, c_whz6, c_waz0, c_waz1, c_waz2, c_waz3, c_waz4, c_waz5, c_waz6, c_haz0, c_haz1, c_haz2, c_haz3, c_haz4, c_haz5, c_haz6,  pn12e_evpu, pn12e_pufr, pn12e_lapu, pn12e_puty, pn12e_pure, pn12e_mpre)

metadata_distinct <- metadata_cluster %>%
  distinct(idbs, .keep_all = TRUE) %>%
  mutate(lbw = replace_na(lbw, 0),
         sga_new = replace_na(sga_new, 0),
         preterm = replace_na(preterm, 0)) %>%
   mutate(
    code = dplyr::recode(code, `A Y` = "IFA-IFA", `A Z` = "IFA-BEP", `B Y` = "BEP-IFA", `B Z` = "BEP-BEP")  )


metadata_baseline <- metadata_distinct %>%
  dplyr::select(idbs, Cluster, w_age, m_weightincl, m_heightincl, m_bmiincl, m_hbincl, mddw_10_ave, asset1comp_10, m_muacincl, GWG,iycf_ebf_age, GAbirthweeks,c_weight0,c_height0,c_headc0,c_muac0, c_hemoglobin6, morb_observation_tot, hh_size, hh_child5) %>%
  mutate(
         C_Weight=c_weight0,
         C_Height=c_height0,
         C_HeadCircumference=c_headc0,
         C_MUAC=c_muac0,
         C_Hemoglobin=c_hemoglobin6,
         C_Morbidity=morb_observation_tot,
         C_GestationalAge=GAbirthweeks,
         M_BMI=m_bmiincl,
         M_Weight=m_weightincl,
         M_Height=m_heightincl,
         M_MUAC=m_muacincl,
         M_Age=w_age,
         M_Hemoglobin=m_hbincl,
         M_DietaryDiversity=mddw_10_ave,
         M_WealthIndex=asset1comp_10,
         M_GestationalWeightGain=GWG,
         HH_Size=hh_size,
         HH_Child5=hh_child5,
         ExclusivelyBFmonths=iycf_ebf_age
         ) %>%
  dplyr::select(idbs, Cluster, C_Weight, C_Height, C_HeadCircumference, C_MUAC,  C_GestationalAge, C_Hemoglobin, C_Morbidity, M_BMI, M_Weight, M_Height, M_MUAC, M_Age, M_Hemoglobin, M_DietaryDiversity, M_WealthIndex, M_GestationalWeightGain,HH_Size, HH_Child5, ExclusivelyBFmonths)

# Transform the data from wide to long format
metadata_long <- metadata_baseline %>%
  pivot_longer(
    cols = c(C_Weight, C_Height, C_HeadCircumference, C_MUAC,  C_GestationalAge, C_Hemoglobin, C_Morbidity, M_BMI, M_Weight, M_Height, M_MUAC, M_Age, M_Hemoglobin, M_DietaryDiversity, M_WealthIndex, M_GestationalWeightGain,HH_Size, HH_Child5, ExclusivelyBFmonths),
    names_to = "variable",
    values_to = "value"
  ) %>%
  filter(!is.na(Cluster)) %>%
  mutate(
    variable = factor(
      variable,
      levels = c("C_Weight", "C_Height", "C_HeadCircumference", "C_MUAC",  "C_GestationalAge", "C_Hemoglobin", "C_Morbidity", "M_BMI", "M_Weight", "M_Height", "M_MUAC", "M_Age", "M_Hemoglobin", "M_DietaryDiversity", "M_WealthIndex", "M_GestationalWeightGain","HH_Size", "HH_Child5", "ExclusivelyBFmonths")
    )
  )


# Step 1: Compute pairwise comparisons for each facet using linear regression
pairwise_results <- metadata_long %>%
  filter(!is.na(value)) %>%  # Remove rows with NA values in `value`
  group_by(variable) %>%
  dplyr::summarise(
    comparisons = list(
      emmeans::emmeans(
        lm(
          value ~ Cluster,  # Simple linear regression model
          data = cur_data()  # Use current data subset for each `variable`
        ),
        pairwise ~ Cluster
      )$contrasts %>%
        as.data.frame()
    ),
    .groups = "drop"
  )


# Step 2: Extract pairwise comparisons and prepare for annotation
significance_annotations <- pairwise_results %>%
  tidyr::unnest(comparisons) %>%
  dplyr::mutate(
    # FDR correction of p-values using BH method
    adj_p_value = p.adjust(p.value, method = "BH"),
    
    # Define significance based on adjusted p-values
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      p.value <= 0.05 & adj_p_value > 0.1 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    ),
    group1 = str_extract(contrast, "^C\\d"),  # Extract first cluster (e.g., "C1")
    group2 = str_extract(contrast, "C\\d$"),  # Extract second cluster (e.g., "C2"),
    y_position = ave(rep(1, n()), variable, FUN = seq_along) * 0.1 +
      sapply(variable, function(v) max(metadata_long$value[metadata_long$variable == v], na.rm = TRUE))
  )  %>%
  filter(significance != "")  # Keep only significant comparisons



# Step 3: Create the plot with independent y-axis scales for each facet
baseline <- ggplot(metadata_long, aes(x = Cluster, y = value, color = Cluster)) +
  geom_boxplot() +  # Add boxplot
  geom_jitter(width = 0.2, alpha = 0.5) +  # Add jittered points
  facet_wrap(~ variable, scales = "free_y", ncol = 5) +  # Facet by variable with free y-scales
  scale_color_manual(values = COLOR_SCHEME) +  # Use the provided color scheme
  labs(x = "", y = "") +  # Label axes
  theme(
    axis.text = element_text(size = 6),  # Set axis text font size
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA)
  ) +
  theme_bw() +
  # Add significance annotations
  geom_segment(
    data = significance_annotations,
    aes(
      x = as.numeric(factor(group1, levels = unique(metadata_long$Cluster))),
      xend = as.numeric(factor(group2, levels = unique(metadata_long$Cluster))),
      y = y_position,
      yend = y_position
    ),
    inherit.aes = FALSE,
    color = "darkred",
    size = 0.5
  ) +
  geom_text(
    data = significance_annotations,
    aes(
      x = (as.numeric(factor(group1, levels = unique(metadata_long$Cluster))) +
           as.numeric(factor(group2, levels = unique(metadata_long$Cluster)))) / 2,
      y = y_position + 0.1,
      label = significance
    ),
    inherit.aes = FALSE,
    size = 5,
    color = "darkred"
  )

# Step 4: Display the plot
baseline

# svglite::svglite(
#   filename="./forISRHML/baseline_Jan22.svg",
#   width=10, height=7
#   )
# baseline
# dev.off()

```

## TableS1 cluster part for CellHostMicrobe -

```{r}

metadataCluster2 <- metadataGut2 %>%
  dplyr::select(idbs, csps, w_religion, w_etnicity, w_school_level, w_nr_jobs, anemia_anc3, Cluster, ch_sex,c_hemoglobin6, morb_observation_tot, hh_size, hh_child5, impr_water, impr_sanitation, svn, lbw, sga_new, preterm, code, gravidity, HH_food_insecurity, w_age, iycf_ebf_age, m_weightincl, m_heightincl, m_bmiincl, m_hbincl, mddw_10_ave, asset1comp_10, season_lean, m_muacincl, GWG, GAbirthweeks, c_weight0, c_weight1, c_weight2, c_weight3, c_weight4, c_weight5, c_weight6, c_height0, c_height1, c_height2, c_height3, c_height4, c_height5, c_height6, c_headc0, c_headc1, c_headc2, c_headc3, c_headc4, c_headc5, c_headc6, c_muac0, c_muac1, c_muac2, c_muac3, c_muac4, c_muac5, c_muac6, c_whz0, c_whz1, c_whz2, c_whz3, c_whz4, c_whz5, c_whz6, c_waz0, c_waz1, c_waz2, c_waz3, c_waz4, c_waz5, c_waz6, c_haz0, c_haz1, c_haz2, c_haz3, c_haz4, c_haz5, c_haz6,  pn12e_evpu, pn12e_pufr, pn12e_lapu, pn12e_puty, pn12e_pure, pn12e_mpre) %>%
  distinct(idbs, .keep_all = TRUE) %>%
  mutate(lbw = replace_na(lbw, 0),
         sga_new = replace_na(sga_new, 0),
         preterm = replace_na(preterm, 0)) %>%
   mutate(
    code = dplyr::recode(code, `A Y` = "IFA-IFA", `A Z` = "IFA-BEP", `B Y` = "BEP-IFA", `B Z` = "BEP-BEP")  )

table(metadataCluster2$csps[metadataCluster2$Cluster=="C1"])
table(metadataCluster2$csps[metadataCluster2$Cluster=="C2"])
table(metadataCluster2$csps[metadataCluster2$Cluster=="C3"])

chisq.test(table(metadataCluster2$csps, metadataCluster2$Cluster))$p.value
fisher.test(
  table(metadataCluster2$csps, metadataCluster2$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

table(metadataCluster2$HH_food_insecurity[metadataCluster2$Cluster=="C1"])
table(metadataCluster2$HH_food_insecurity[metadataCluster2$Cluster=="C2"])
table(metadataCluster2$HH_food_insecurity[metadataCluster2$Cluster=="C3"])

fisher.test(
  table(metadataCluster2$HH_food_insecurity, metadataCluster2$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

mean(metadataCluster2$asset1comp_10[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$asset1comp_10[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$asset1comp_10[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$asset1comp_10[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$asset1comp_10[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$asset1comp_10[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(asset1comp_10 ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$hh_size[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$hh_size[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$hh_size[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$hh_size[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$hh_size[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$hh_size[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(hh_size ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$hh_child5[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$hh_child5[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$hh_child5[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$hh_child5[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$hh_child5[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$hh_child5[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(hh_child5 ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

table(metadataCluster2$impr_water[metadataCluster2$Cluster=="C1"])
table(metadataCluster2$impr_water[metadataCluster2$Cluster=="C2"])
table(metadataCluster2$impr_water[metadataCluster2$Cluster=="C3"])

fisher.test(
  table(metadataCluster2$impr_water, metadataCluster2$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

table(metadataCluster2$impr_sanitation[metadataCluster2$Cluster=="C1"])
table(metadataCluster2$impr_sanitation[metadataCluster2$Cluster=="C2"])
table(metadataCluster2$impr_sanitation[metadataCluster2$Cluster=="C3"])

fisher.test(
  table(metadataCluster2$impr_sanitation, metadataCluster2$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

table(metadataCluster2$w_etnicity[metadataCluster2$Cluster=="C1"])
table(metadataCluster2$w_etnicity[metadataCluster2$Cluster=="C2"])
table(metadataCluster2$w_etnicity[metadataCluster2$Cluster=="C3"])

fisher.test(
  table(metadataCluster2$w_etnicity, metadataCluster2$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

table(metadataCluster2$w_religion[metadataCluster2$Cluster=="C1"])
table(metadataCluster2$w_religion[metadataCluster2$Cluster=="C2"])
table(metadataCluster2$w_religion[metadataCluster2$Cluster=="C3"])

fisher.test(
  table(metadataCluster2$w_religion, metadataCluster2$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

table(metadataCluster2$w_school_level[metadataCluster2$Cluster=="C1"])
table(metadataCluster2$w_school_level[metadataCluster2$Cluster=="C2"])
table(metadataCluster2$w_school_level[metadataCluster2$Cluster=="C3"])

fisher.test(
  table(metadataCluster2$w_school_level, metadataCluster2$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

table(metadataCluster2$w_nr_jobs[metadataCluster2$Cluster=="C1"])
table(metadataCluster2$w_nr_jobs[metadataCluster2$Cluster=="C2"])
table(metadataCluster2$w_nr_jobs[metadataCluster2$Cluster=="C3"])

fisher.test(
  table(metadataCluster2$w_nr_jobs, metadataCluster2$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

table(metadataCluster2$gravidity[metadataCluster2$Cluster=="C1"])
table(metadataCluster2$gravidity[metadataCluster2$Cluster=="C2"])
table(metadataCluster2$gravidity[metadataCluster2$Cluster=="C3"])

fisher.test(
  table(metadataCluster2$gravidity, metadataCluster2$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

table(metadataCluster2$code[metadataCluster2$Cluster=="C1"])
table(metadataCluster2$code[metadataCluster2$Cluster=="C2"])
table(metadataCluster2$code[metadataCluster2$Cluster=="C3"])

fisher.test(
  table(metadataCluster2$code, metadataCluster2$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

mean(metadataCluster2$w_age[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$w_age[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$w_age[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$w_age[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$w_age[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$w_age[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(w_age ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$m_weightincl[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$m_weightincl[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$m_weightincl[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$m_weightincl[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$m_weightincl[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$m_weightincl[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(m_weightincl ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$m_heightincl[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$m_heightincl[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$m_heightincl[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$m_heightincl[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$m_heightincl[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$m_heightincl[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(m_heightincl ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$m_bmiincl[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$m_bmiincl[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$m_bmiincl[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$m_bmiincl[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$m_bmiincl[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$m_bmiincl[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(m_bmiincl ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$m_muacincl[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$m_muacincl[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$m_muacincl[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$m_muacincl[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$m_muacincl[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$m_muacincl[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(m_muacincl ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$m_hbincl[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$m_hbincl[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$m_hbincl[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$m_hbincl[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$m_hbincl[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$m_hbincl[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(m_hbincl ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

table(metadataCluster2$anemia_anc3[metadataCluster2$Cluster=="C1"])
table(metadataCluster2$anemia_anc3[metadataCluster2$Cluster=="C2"])
table(metadataCluster2$anemia_anc3[metadataCluster2$Cluster=="C3"])

fisher.test(
  table(metadataCluster2$anemia_anc3, metadataCluster2$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

mean(metadataCluster2$GWG[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$GWG[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$GWG[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$GWG[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$GWG[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$GWG[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(GWG ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$mddw_10_ave[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$mddw_10_ave[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$mddw_10_ave[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$mddw_10_ave[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$mddw_10_ave[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$mddw_10_ave[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(mddw_10_ave ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

table(metadataCluster2$ch_sex[metadataCluster2$Cluster=="C1"])
table(metadataCluster2$ch_sex[metadataCluster2$Cluster=="C2"])
table(metadataCluster2$ch_sex[metadataCluster2$Cluster=="C3"])

fisher.test(
  table(metadataCluster2$ch_sex, metadataCluster2$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

table(metadataCluster2$season_lean[metadataCluster2$Cluster=="C1"])
table(metadataCluster2$season_lean[metadataCluster2$Cluster=="C2"])
table(metadataCluster2$season_lean[metadataCluster2$Cluster=="C3"])

fisher.test(
  table(metadataCluster2$season_lean, metadataCluster2$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

mean(metadataCluster2$c_weight0[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$c_weight0[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$c_weight0[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$c_weight0[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$c_weight0[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$c_weight0[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(c_weight0 ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$c_height0[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$c_height0[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$c_height0[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$c_height0[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$c_height0[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$c_height0[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(c_height0 ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$c_headc0[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$c_headc0[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$c_headc0[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$c_headc0[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$c_headc0[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$c_headc0[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(c_headc0 ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$c_muac0[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$c_muac0[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$c_muac0[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$c_muac0[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$c_muac0[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$c_muac0[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(c_muac0 ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$GAbirthweeks[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$GAbirthweeks[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$GAbirthweeks[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$GAbirthweeks[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$GAbirthweeks[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$GAbirthweeks[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(GAbirthweeks ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$c_hemoglobin6[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$c_hemoglobin6[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$c_hemoglobin6[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$c_hemoglobin6[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$c_hemoglobin6[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$c_hemoglobin6[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(c_hemoglobin6 ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$morb_observation_tot[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$morb_observation_tot[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$morb_observation_tot[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$morb_observation_tot[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$morb_observation_tot[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$morb_observation_tot[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(morb_observation_tot ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

mean(metadataCluster2$iycf_ebf_age, na.rm=T)
sd(metadataCluster2$iycf_ebf_age, na.rm=T)

mean(metadataCluster2$iycf_ebf_age[metadataCluster2$Cluster=="C1"], na.rm=T)
sd(metadataCluster2$iycf_ebf_age[metadataCluster2$Cluster=="C1"], na.rm=T)
mean(metadataCluster2$iycf_ebf_age[metadataCluster2$Cluster=="C2"], na.rm=T)
sd(metadataCluster2$iycf_ebf_age[metadataCluster2$Cluster=="C2"], na.rm=T)
mean(metadataCluster2$iycf_ebf_age[metadataCluster2$Cluster=="C3"], na.rm=T)
sd(metadataCluster2$iycf_ebf_age[metadataCluster2$Cluster=="C3"], na.rm=T)

summary(aov(iycf_ebf_age ~ Cluster, data = metadataCluster2))[[1]][["Pr(>F)"]][1]

```

## ü§ç for reviewer

```{r}

ebf <- metadata %>%
  select("idwoman", "idbs", "code_bep_n") %>%
  filter(code_bep_n == 1 | code_bep_n == 4) %>%
  left_join(row_annotation_idbs, by = "idbs") %>%  # Perform the join
  left_join(merge_wide %>%
  select("idwoman", "d_cdob", "pn_ebf_age_", "lama_date_sample_pn1421", "lama_date_sample_pn12", "lama_date_sample_pn34")) %>%
  left_join(pn12e_se1g_date) %>%
  left_join(pn56e_se1g_date) %>%
mutate(
    # make sure d_cdob is Date
    d_cdob = as.Date(d_cdob),
    
    # parse sample dates (character -> POSIX -> Date)
    date_pn1421 = as.Date(parse_date_time(lama_date_sample_pn1421, orders = c("y-m-d H:M", "dmy HM", "y-m-d"))),
    date_pn12   = as.Date(parse_date_time(lama_date_sample_pn12,   orders = c("y-m-d H:M", "dmy HM", "y-m-d"))),
    date_pn34   = as.Date(parse_date_time(lama_date_sample_pn34,   orders = c("y-m-d H:M", "dmy HM", "y-m-d"))),
    date_pn56   = as.Date(parse_date_time(pn56e_date,              orders = c("y-m-d H:M", "dmy HM", "y-m-d"))),
    
    # compute age in months (difference in days / 30.44)
    lama_1421_mo = as.numeric(difftime(date_pn1421, d_cdob, units = "days")) / 30.44,
    lama_pn12_mo = as.numeric(difftime(date_pn12,   d_cdob, units = "days")) / 30.44,
    lama_pn34_mo = as.numeric(difftime(date_pn34,   d_cdob, units = "days")) / 30.44,
    se1g_pn56_mo = as.numeric(difftime(date_pn56,   d_cdob, units = "days")) / 30.44
  ) %>%
  mutate(
    ebf_1421 = case_when(
      !is.na(lama_1421_mo) & !is.na(pn_ebf_age_) & lama_1421_mo <= pn_ebf_age_ ~ 1,
      !is.na(lama_1421_mo) & !is.na(pn_ebf_age_) & lama_1421_mo >  pn_ebf_age_ ~ 0,
      TRUE ~ NA_real_
    )
  ) %>%
  mutate(
    ebf_pn12 = case_when(
      !is.na(lama_pn12_mo) & !is.na(pn_ebf_age_) & lama_pn12_mo <= pn_ebf_age_ ~ 1,
      !is.na(lama_pn12_mo) & !is.na(pn_ebf_age_) & lama_pn12_mo >  pn_ebf_age_ ~ 0,
      TRUE ~ NA_real_
    )
  ) %>%
  mutate(
    ebf_pn34 = case_when(
      !is.na(lama_pn34_mo) & !is.na(pn_ebf_age_) & lama_pn34_mo <= pn_ebf_age_ ~ 1,
      !is.na(lama_pn34_mo) & !is.na(pn_ebf_age_) & lama_pn34_mo >  pn_ebf_age_ ~ 0,
      TRUE ~ NA_real_
    )
  ) %>%
  mutate(
    ebf_pn56 = case_when(
      !is.na(se1g_pn56_mo) & !is.na(pn_ebf_age_) & se1g_pn56_mo <= pn_ebf_age_ ~ 1,
      !is.na(se1g_pn56_mo) & !is.na(pn_ebf_age_) & se1g_pn56_mo >  pn_ebf_age_ ~ 0,
      TRUE ~ NA_real_
    )
  )

table(ebf$ebf_1421)
table(ebf$ebf_1421[ebf$Cluster=="C1"])
table(ebf$ebf_1421[ebf$Cluster=="C2"])
table(ebf$ebf_1421[ebf$Cluster=="C3"])
fisher.test(
  table(ebf$ebf_1421, ebf$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value


table(ebf$ebf_pn12)
table(ebf$ebf_pn12[ebf$Cluster=="C1"])
table(ebf$ebf_pn12[ebf$Cluster=="C2"])
table(ebf$ebf_pn12[ebf$Cluster=="C3"])
fisher.test(
  table(ebf$ebf_pn12, ebf$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value


table(ebf$ebf_pn34)
table(ebf$ebf_pn34[ebf$Cluster=="C1"])
table(ebf$ebf_pn34[ebf$Cluster=="C2"])
table(ebf$ebf_pn34[ebf$Cluster=="C3"])
fisher.test(
  table(ebf$ebf_pn34, ebf$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

table(ebf$ebf_pn56)
table(ebf$ebf_pn56[ebf$Cluster=="C1"])
table(ebf$ebf_pn56[ebf$Cluster=="C2"])
table(ebf$ebf_pn56[ebf$Cluster=="C3"])
fisher.test(
  table(ebf$ebf_pn56, ebf$Cluster),
  workspace = 2e8  # Increase workspace size (e.g., 200 MB)
)$p.value

# Example: list of EBF variables at different timepoints
ebf_vars <- c("ebf_1421", "ebf_pn12", "ebf_pn34", "ebf_pn56")

# Run Fisher‚Äôs exact test for each timepoint
pvals <- sapply(ebf_vars, function(v) {
  fisher.test(table(ebf[[v]], ebf$Cluster), workspace = 2e8)$p.value
})

# Adjust p-values (FDR)
pvals_adj <- p.adjust(pvals, method = "fdr")

# Combine results
results <- data.frame(
  timepoint = ebf_vars,
  pval_raw = pvals,
  pval_fdr = pvals_adj
)

print(results)

median(ebf$pn_ebf_age_, na.rm = T)
min(ebf$pn_ebf_age_, na.rm = T)
max(ebf$pn_ebf_age_, na.rm = T)

median(metadataCluster2$iycf_ebf_age, na.rm = T)
min(metadataCluster2$iycf_ebf_age, na.rm = T)
max(metadataCluster2$iycf_ebf_age, na.rm = T)

table(
  case_when(
    hour(suppressWarnings(dmy_hm(ebf$lama_date_sample_pn1421))) < 12 ~ "Before noon",
    hour(suppressWarnings(dmy_hm(ebf$lama_date_sample_pn1421))) >= 12 ~ "After noon",
    TRUE ~ NA_character_
  )
)

table(
  case_when(
    hour(suppressWarnings(dmy_hm(ebf$lama_date_sample_pn12))) < 12 ~ "Before noon",
    hour(suppressWarnings(dmy_hm(ebf$lama_date_sample_pn12))) >= 12 ~ "After noon",
    TRUE ~ NA_character_
  )
)

table(
  case_when(
    hour(suppressWarnings(dmy_hm(ebf$lama_date_sample_pn34))) < 12 ~ "Before noon",
    hour(suppressWarnings(dmy_hm(ebf$lama_date_sample_pn34))) >= 12 ~ "After noon",
    TRUE ~ NA_character_
  )
)


```

## FigS3B binary baseline

```{r}

# Convert all variables to character before pivoting
metadata_long_binary <- metadata_distinct %>%
  dplyr::select(Cluster, code, ch_sex, gravidity, HH_food_insecurity, season_lean, impr_water, impr_sanitation, pn12e_evpu, lbw, sga_new, preterm) %>%
  dplyr::mutate(ch_sex = if_else(ch_sex == 1, 1, 0)) %>%
  dplyr::mutate(parity = if_else(gravidity == 1, 1, 0)) %>%
  dplyr::mutate(code = if_else(code == "BEP-BEP", 1, 0)) %>%
  dplyr::mutate(
    M_BEP=code,
    FirstPregnancy=parity,
    FoodInsecurity=HH_food_insecurity,
    LeanSeason=season_lean,
    Purge=pn12e_evpu,
    LBW=lbw,
    SGA=sga_new,
    Preterm=preterm
  ) %>%
  dplyr::select(Cluster, ch_sex, M_BEP, FirstPregnancy, FoodInsecurity, LeanSeason, impr_water, impr_sanitation, Purge, LBW, SGA, Preterm) %>%
  dplyr::mutate(across(everything(), as.character)) %>%
  pivot_longer(cols = c(ch_sex, M_BEP, FirstPregnancy, FoodInsecurity, LeanSeason,impr_water, impr_sanitation, Purge, LBW, SGA, Preterm),  names_to = "variable", values_to = "value")  %>%
  filter(!is.na(Cluster)) %>%
  dplyr::mutate(
    variable = factor(
      variable,
      levels = c("M_BEP", "FirstPregnancy", "FoodInsecurity", "LeanSeason", "impr_water", "impr_sanitation", "Purge", "ch_sex", "LBW", "SGA", "Preterm")
    )
  )

metadata_long_binary <- metadata_long_binary %>%
  group_by(Cluster, variable, value) %>%
  dplyr::summarise(count = n(), .groups = "drop") %>%  # Count occurrences
  dplyr::mutate(total_count = if_else(Cluster=="C1", 44,
                               if_else(Cluster == "C2", 65, 30))) %>%  # Sum counts within each Cluster & Variable
  dplyr::mutate(percentage = (count / total_count) * 100)  # Calculate percentage

# Step 3: Perform pairwise comparisons for each variable
pairwise_p_values <- metadata_long_binary %>%
  group_by(variable) %>%
  dplyr::summarise(
    comparisons = list({
      pairwise_results <- combn(unique(Cluster), 2, function(pair) {
        # Subset data for the pair of clusters
        data_subset <- filter(metadata_long_binary, Cluster %in% pair & variable == unique(variable))
        contingency_table <- table(data_subset$value, data_subset$Cluster)
        # Perform Fisher's exact test
        test <- fisher.test(contingency_table)
        data.frame(
          group1 = pair[1],
          group2 = pair[2],
          p_value = test$p.value
        )
      }, simplify = FALSE)
      do.call(rbind, pairwise_results)
    }),
    .groups = "drop"
  ) %>%
  tidyr::unnest(comparisons) %>%
  dplyr::mutate(
    significance = case_when(
      p_value <= 0.001 ~ "***",
      p_value <= 0.01 ~ "**",
      p_value <= 0.05 ~ "*",
      TRUE ~ ""
    )
  )

# Step 4: Create the plot
baseline2 <- ggplot(metadata_long_binary, aes(x = Cluster, y = percentage, fill = factor(value))) +
  geom_bar(stat = "identity") +  # Use stat = "identity" for calculated percentages
  facet_wrap(~ variable, scales = "free_y", ncol = 6) +
  labs(x = "", y = "Percentage", fill = "Value") +
  theme_bw() +
  
  # Change color scheme: "1" = darkred, "0" = grey
  scale_fill_manual(values = c("1" = "darkred", "0" = "grey")) +

  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA),
    legend.position = "right"
  ) +
  
  # Add significance annotations above bars
  geom_text(
    data = pairwise_p_values,
    aes(
      x = as.numeric(factor(group1)) + (as.numeric(factor(group2)) - as.numeric(factor(group1))) / 2,
      y = max(metadata_long_binary$percentage, na.rm = TRUE) + 5,  # Position above bars
      label = significance
    ),
    inherit.aes = FALSE,
    size = 3,
    color = "black"
  )

baseline2

#svglite::svglite(
#  filename="./forISRHML/baseline2.svg",
#  width=10, height=4
#  )
#baseline2
#dev.off()

```

## FigS3C infant anthropometry

```{r}

metadata_weight <- metadata_cluster %>%
  dplyr::select(idbs, Cluster, c_weight0, c_weight1, c_weight2, c_weight3, c_weight4, c_weight5, c_weight6) %>%
  filter(!is.na(Cluster))

# Transform the data from wide to long format
metadata_long <- metadata_weight %>%
  pivot_longer(
    cols = starts_with("c_weight"),
    names_to = "time",
    values_to = "weight"
  ) 

# Fit the mixed-effects linear regression model
library(lmerTest)
model <- lmer(weight ~ time * Cluster + (1 | idbs), data = metadata_long)
summary(model)

# Convert 'time' to a numeric variable for plotting
metadata_long <- metadata_long %>%
  mutate(time = as.numeric(gsub("c_weight", "", time)))

# Summarize the data
metadata_summary <- metadata_long %>%
  group_by(Cluster, time) %>%
  dplyr::summarize(
    mean_weight = mean(weight, na.rm = TRUE),
    sd_weight = sd(weight, na.rm = TRUE),
    .groups = 'drop'
  )

# Create the line plot
infant_weight <- ggplot(metadata_summary, aes(x = time, y = mean_weight, color = Cluster, group = Cluster)) +
  geom_line(size = 0.5) +
  geom_point(size = 1) +
  geom_errorbar(aes(ymin = mean_weight - sd_weight, ymax = mean_weight + sd_weight), width = 0.2, alpha = 0.7) +
  labs(x = "Months", y = "Weight, kg", color = "Group") +
  scale_color_manual(values = COLOR_SCHEME) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA)
  )

infant_weight

#svglite::svglite(
#  filename="./forISRHML/infant_weight.svg",
#  width=6, height=2.5
#  )
#infant_weight
#dev.off()


## infant height

metadata_height <- metadata_cluster %>%
  dplyr::select(idbs, Cluster, c_height0, c_height1, c_height2, c_height3, c_height4, c_height5, c_height6) %>%
  filter(!is.na(Cluster))

# Transform the data from wide to long format
metadata_long <- metadata_height %>%
  pivot_longer(
    cols = starts_with("c_height"),
    names_to = "time",
    values_to = "height"
  ) 

# Fit the mixed-effects linear regression model
library(lmerTest)
model <- lmer(height ~ time * Cluster + (1 | idbs), data = metadata_long)
summary(model)

# Convert 'time' to a numeric variable for plotting
metadata_long <- metadata_long %>%
  mutate(time = as.numeric(gsub("c_height", "", time)))

# Summarize the data
metadata_summary <- metadata_long %>%
  group_by(Cluster, time) %>%
  dplyr::summarize(
    mean_height = mean(height, na.rm = TRUE),
    sd_height = sd(height, na.rm = TRUE),
    .groups = 'drop'
  )

# Create the line plot
infant_height <- ggplot(metadata_summary, aes(x = time, y = mean_height, color = Cluster, group = Cluster)) +
  geom_line(size = 0.5) +
  geom_point(size = 1) +
  geom_errorbar(aes(ymin = mean_height - sd_height, ymax = mean_height + sd_height), width = 0.2, alpha = 0.7) +
  labs(x = "Months", y = "Length, cm", color = "Group") +
  scale_color_manual(values = COLOR_SCHEME) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA)
  )

infant_height


## infant headc

metadata_headc <- metadata_cluster %>%
  dplyr::select(idbs, Cluster, c_headc0, c_headc1, c_headc2, c_headc3, c_headc4, c_headc5, c_headc6) %>%
  filter(!is.na(Cluster))

# Transform the data from wide to long format
metadata_long <- metadata_headc %>%
  pivot_longer(
    cols = starts_with("c_headc"),
    names_to = "time",
    values_to = "headc"
  ) 

# Fit the mixed-effects linear regression model
library(lmerTest)
model <- lmer(headc ~ time * Cluster + (1 | idbs), data = metadata_long)
summary(model)

# Convert 'time' to a numeric variable for plotting
metadata_long <- metadata_long %>%
  mutate(time = as.numeric(gsub("c_headc", "", time)))

# Summarize the data
metadata_summary <- metadata_long %>%
  group_by(Cluster, time) %>%
  dplyr::summarize(
    mean_headc = mean(headc, na.rm = TRUE),
    sd_headc = sd(headc, na.rm = TRUE),
    .groups = 'drop'
  )

# Create the line plot
infant_headc <- ggplot(metadata_summary, aes(x = time, y = mean_headc, color = Cluster, group = Cluster)) +
  geom_line(size = 0.5) +
  geom_point(size = 1) +
  geom_errorbar(aes(ymin = mean_headc - sd_headc, ymax = mean_headc + sd_headc), width = 0.2, alpha = 0.7) +
  labs(x = "Months", y = "Head Circumference, cm", color = "Group") +
  scale_color_manual(values = COLOR_SCHEME) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA)
  )

infant_headc


## infant muac


metadata_muac <- metadata_cluster %>%
  dplyr::select(idbs, Cluster, c_muac0, c_muac1, c_muac2, c_muac3, c_muac4, c_muac5, c_muac6) %>%
  filter(!is.na(Cluster))

# Transform the data from wide to long format
metadata_long <- metadata_muac %>%
  pivot_longer(
    cols = starts_with("c_muac"),
    names_to = "time",
    values_to = "muac"
  ) 

# Fit the mixed-effects linear regression model
library(lmerTest)
model <- lmer(muac ~ time * Cluster + (1 | idbs), data = metadata_long)
summary(model)

# Convert 'time' to a numeric variable for plotting
metadata_long <- metadata_long %>%
  mutate(time = as.numeric(gsub("c_muac", "", time)))

# Summarize the data
metadata_summary <- metadata_long %>%
  group_by(Cluster, time) %>%
  dplyr::summarize(
    mean_muac = mean(muac, na.rm = TRUE),
    sd_muac = sd(muac, na.rm = TRUE),
    .groups = 'drop'
  )

# Create the line plot
infant_muac <- ggplot(metadata_summary, aes(x = time, y = mean_muac, color = Cluster, group = Cluster)) +
  geom_line(size = 0.5) +
  geom_point(size = 1) +
  geom_errorbar(aes(ymin = mean_muac - sd_muac, ymax = mean_muac + sd_muac), width = 0.2, alpha = 0.7) +
  labs(x = "Months", y = "Mid-upper Arm Circumference, cm", color = "Group") +
  scale_color_manual(values = COLOR_SCHEME) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA)
  )

infant_muac


## infant whz


metadata_whz <- metadata_cluster %>%
  dplyr::select(idbs, Cluster, c_whz0, c_whz1, c_whz2, c_whz3, c_whz4, c_whz5, c_whz6) %>%
  filter(!is.na(Cluster))

# Transform the data from wide to long format
metadata_long <- metadata_whz %>%
  pivot_longer(
    cols = starts_with("c_whz"),
    names_to = "time",
    values_to = "whz"
  ) 

# Fit the mixed-effects linear regression model
library(lmerTest)
model <- lmer(whz ~ time * Cluster + (1 | idbs), data = metadata_long)
summary(model)

# Convert 'time' to a numeric variable for plotting
metadata_long <- metadata_long %>%
  mutate(time = as.numeric(gsub("c_whz", "", time)))

# Summarize the data
metadata_summary <- metadata_long %>%
  group_by(Cluster, time) %>%
  dplyr::summarize(
    mean_whz = mean(whz, na.rm = TRUE),
    sd_whz = sd(whz, na.rm = TRUE),
    .groups = 'drop'
  )

# Create the line plot
infant_whz <- ggplot(metadata_summary, aes(x = time, y = mean_whz, color = Cluster, group = Cluster)) +
  geom_line(size = 0.5) +
  geom_point(size = 1) +
  geom_errorbar(aes(ymin = mean_whz - sd_whz, ymax = mean_whz + sd_whz), width = 0.2, alpha = 0.7) +
  labs(x = "Months", y = "WHZ", color = "Group") +
  scale_color_manual(values = COLOR_SCHEME) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA)
  )

infant_whz


## infant waz

metadata_waz <- metadata_cluster %>%
  dplyr::select(idbs, Cluster, c_waz0, c_waz1, c_waz2, c_waz3, c_waz4, c_waz5, c_waz6) %>%
  filter(!is.na(Cluster))

# Transform the data from wide to long format
metadata_long <- metadata_waz %>%
  pivot_longer(
    cols = starts_with("c_waz"),
    names_to = "time",
    values_to = "waz"
  ) 

# Fit the mixed-effects linear regression model
library(lmerTest)
model <- lmer(waz ~ time * Cluster + (1 | idbs), data = metadata_long)
summary(model)

# Convert 'time' to a numeric variable for plotting
metadata_long <- metadata_long %>%
  mutate(time = as.numeric(gsub("c_waz", "", time)))

# Summarize the data
metadata_summary <- metadata_long %>%
  group_by(Cluster, time) %>%
  dplyr::summarize(
    mean_waz = mean(waz, na.rm = TRUE),
    sd_waz = sd(waz, na.rm = TRUE),
    .groups = 'drop'
  )

# Create the line plot
infant_waz <- ggplot(metadata_summary, aes(x = time, y = mean_waz, color = Cluster, group = Cluster)) +
  geom_line(size = 0.5) +
  geom_point(size = 1) +
  geom_errorbar(aes(ymin = mean_waz - sd_waz, ymax = mean_waz + sd_waz), width = 0.2, alpha = 0.7) +
  labs(x = "Months", y = "WAZ", color = "Group") +
  scale_color_manual(values = COLOR_SCHEME) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA)
  )

infant_waz


## infant haz

metadata_haz <- metadata_cluster %>%
  dplyr::select(idbs, Cluster, c_haz0, c_haz1, c_haz2, c_haz3, c_haz4, c_haz5, c_haz6) %>%
  filter(!is.na(Cluster))

# Transform the data from wide to long format
metadata_long <- metadata_haz %>%
  pivot_longer(
    cols = starts_with("c_haz"),
    names_to = "time",
    values_to = "haz"
  ) 

# Fit the mixed-effects linear regression model
library(lmerTest)
model <- lmer(haz ~ time * Cluster + (1 | idbs), data = metadata_long)
summary(model)

# Convert 'time' to a numeric variable for plotting
metadata_long <- metadata_long %>%
  mutate(time = as.numeric(gsub("c_haz", "", time)))

# Summarize the data
metadata_summary <- metadata_long %>%
  group_by(Cluster, time) %>%
  dplyr::summarize(
    mean_haz = mean(haz, na.rm = TRUE),
    sd_haz = sd(haz, na.rm = TRUE),
    .groups = 'drop'
  )

# Create the line plot
infant_haz <- ggplot(metadata_summary, aes(x = time, y = mean_haz, color = Cluster, group = Cluster)) +
  geom_line(size = 0.5) +
  geom_point(size = 1) +
  geom_errorbar(aes(ymin = mean_haz - sd_haz, ymax = mean_haz + sd_haz), width = 0.2, alpha = 0.7) +
  labs(x = "Months", y = "LAZ", color = "Group") +
  scale_color_manual(values = COLOR_SCHEME) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA)
  )

infant_haz

```

# Relative abundance

## Fig2C gut infant rb

```{r message=FALSE}

genus_name <- c("Bifidobacterium", "Escherichia",  "Bacteroides", "Prevotella",  "Veillonella_A", "Klebsiella","Parolsenella", "Campylobacter_D", "Streptococcus", "Parabacteroides", "Phocaeicola",  "Veillonella", "Megasphaera", "Akkermansia", "Sutterella", "Other")
genus_color <- c( "coral1", "bisque3", "#28E2E5", "#2986cc", "brown", "gold4", "palegreen", "thistle", "slateblue2", "yellow2", "azure4", "forestgreen", "lightblue", "skyblue", "tan2", "gray")

infant_genus <- infant_meta %>%
  tax_glom(taxrank = "genus") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  #filter(Abundance > 0) %>%
  mutate(timepoint = factor(timepoint, 
                       levels = c("pn12", "pn56"),  
                       labels = c("Pn12", "Pn56")))

sort_infant_genus <- infant_genus %>%
  dplyr::count(genus, wt = Abundance) %>%
  arrange(desc(n)) %>%
  slice_head(n = 15) %>%
  pull(genus)

infant_genus$genus_grouped <- ifelse(infant_genus$genus %in% sort_infant_genus, as.character(infant_genus$genus), "Other")

sample_order_genus <- infant_genus %>%
  group_by(Cluster) %>%
  dplyr::summarize(Abundance = mean(Abundance)) %>%
  arrange(desc(Abundance)) %>%
  pull(Cluster)

genus_order <- infant_genus %>%
  group_by(genus_grouped) %>%
  dplyr::summarize(Abundance = mean(Abundance)) %>%
  arrange(desc(Abundance)) %>%
  pull(genus_grouped)

# Generate the plot with ordered x-axis
infant_genus_plot <- infant_genus %>%
  mutate(genus_grouped = factor(genus_grouped, levels = genus_order)) %>%
  ggplot(aes(x = Cluster, y = Abundance, fill = genus_grouped)) +
  geom_bar(stat = 'identity', position = 'fill', color = NA, size = 0) +
  scale_fill_manual(breaks = genus_name, values = genus_color) + 
  facet_wrap(~timepoint) +
  theme(
    axis.text.x = element_text(size = 8),
    legend.title = element_text(size = 8),
    legend.key.size = unit(0.3, 'cm'),
    legend.text = element_text(size = 8),
    panel.grid = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  labs(x = "", y = "Relative Abundance (%)", fill = "Genus") +
  guides(fill = guide_legend(ncol = 1))
infant_genus_plot

# Save the plot as an SVG file
#svglite::svglite(
#  filename = "./forISRHML/cluster_gut_infant_genus_mar04.svg",
#  width = 4.5, height = 4.5
#)
#print(infant_genus_plot)
#dev.off()
```

## Fig3A gut mother rb

```{r message=FALSE}

genus_name <- c("Prevotella",  "RC9", "Faecalibacterium", "CAG-83", "Prevotellamassilia", "ER4", "Bacteroides", "C941", "CAG-170", "Succinivibrio", "Dialister", "Agathobacter", "Acetatifactor", "CAG-110", "CAG-279", "Other")
genus_color <- c("#2986cc", "#cd0000", "#6aa84f",  "#f1c232", "#228585","#f4cccc", "#28E2E5","#e69138", "#cfe2f3", "#d0f679", "#483D8B", "#2F4F4F", "#8B0A50", "#104E8E", "#A6611A",  "gray")

mother_genus <- mother_meta %>%
  tax_glom(taxrank = "genus") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  filter(Abundance > 0) %>%
  mutate(timepoint = factor(timepoint, 
                       levels = c("incl", "tri3", "pn12", "pn56"),  
                       labels = c("Incl", "Tri3", "Pn12", "Pn56")))

sort_mother_genus <- mother_genus %>%
  dplyr::count(genus, wt = Abundance) %>%
  arrange(desc(n)) %>%
  slice_head(n = 15) %>%
  pull(genus)

mother_genus$genus_grouped <- ifelse(mother_genus$genus %in% sort_mother_genus, as.character(mother_genus$genus), "Other")

sample_order_genus <- mother_genus %>%
  group_by(Cluster) %>%
  dplyr::summarize(Abundance = mean(Abundance)) %>%
  arrange(desc(Abundance)) %>%
  pull(Cluster)

genus_order <- mother_genus %>%
  group_by(genus_grouped) %>%
  dplyr::summarize(Abundance = mean(Abundance)) %>%
  arrange(desc(Abundance)) %>%
  pull(genus_grouped)

# Generate the plot with ordered x-axis
mother_genus_plot <- mother_genus %>%
  mutate(genus_grouped = factor(genus_grouped, levels = genus_order)) %>%
  ggplot(aes(x = Cluster, y = Abundance, fill = genus_grouped)) +
  geom_bar(stat = 'identity', position = 'fill') +
  scale_fill_manual(breaks = genus_name, values = genus_color) + 
  facet_wrap(~timepoint, ncol = 4) +
  theme(
    axis.text.x = element_text(size = 8),
    legend.title = element_text(size = 8),
    legend.key.size = unit(0.3, 'cm'),
    legend.text = element_text(size = 8),
    panel.grid = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  labs(x = "", y = "Relative Abundance (%)", fill = "Genus") +
  guides(fill = guide_legend(ncol = 1))
mother_genus_plot

#svglite::svglite(
#  filename="./forISRHML/cluster_gut_mother_genus_mar04.svg",
#  width=7, height=4.5
#  )
#mother_genus_plot
#dev.off()

```

## Fig4A milk rb

```{r message=FALSE}

genus_name <- c("Streptococcus", "Staphylococcus", "Corynebacterium",  "Bacillus_A",  "Acinetobacter", "Bifidobacterium_388775", "Veillonella_A", "Rothia", "Priestia", "Unclassified Enterobacteriaceae_A", "Kocuria", "Unclassified Pseudomonadaceae", "Stenotrophomonas_A_615274", "Brevibacillus_D",  "Gemella", "Other")
genus_color <- c("slateblue2", "orange2", "lavender", "palegreen4", "yellowgreen", "coral1", "brown", "gold4",  "khaki2", "dodgerblue", "hotpink2", "cyan3", "skyblue4", "lemonchiffon3", "plum3", "gray")


milk_genus <- milkps_meta %>%
  tax_glom(taxrank = "genus") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  filter(Abundance > 0) %>%
  mutate(timepoint = factor(timepoint, 
                       levels = c("1421", "pn12", "pn34"), 
                       labels = c("1421", "Pn12", "Pn34")))

sort_milk_genus <- milk_genus %>%
  dplyr::count(genus, wt = Abundance) %>%
  arrange(desc(n)) %>%
  slice_head(n = 15) %>%
  pull(genus)

milk_genus$genus_grouped <- ifelse(milk_genus$genus %in% sort_milk_genus, as.character(milk_genus$genus), "Other")

sample_order_genus <- milk_genus %>%
  group_by(timepoint) %>%
  dplyr::summarize(Abundance = mean(Abundance)) %>%
  arrange(desc(Abundance)) %>%
  pull(timepoint)

genus_order <- milk_genus %>%
  group_by(genus_grouped) %>%
  dplyr::summarize(Abundance = mean(Abundance)) %>%
  arrange(desc(Abundance)) %>%
  pull(genus_grouped)

timepoint_order <- c("1421", "pn12", "pn34")

milk_genus_plot <- milk_genus %>%
  mutate(genus_grouped = factor(genus_grouped, levels = genus_order)) %>%
  ggplot(aes(x = Cluster, y = Abundance, fill = genus_grouped)) +
  geom_bar(stat = 'identity', position = 'fill') +
  scale_fill_manual(breaks = genus_name, values = genus_color) + 
  facet_wrap(~timepoint, ncol = 4) +
  theme(
    axis.text.x = element_text(size = 8),
    legend.title = element_text(size = 8),
    legend.key.size = unit(0.3, 'cm'),
    legend.text = element_text(size = 8),
    panel.grid = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  labs(x = "", y = "Relative Abundance (%)", fill = "Genus") +
  guides(fill = guide_legend(ncol = 1))
milk_genus_plot

#svglite::svglite(
#  filename="./forISRHML/cluster_milk_genus.svg",
#  width=6.5, height=5
#  )
#milk_genus_plot
#dev.off()


```

# Shannon diversity

```{r message=FALSE}

# Load the necessary libraries
library(phyloseq)
library(ggplot2)
library(reshape2)

# Assuming you have loaded your phyloseq objects named phyloseq_16S and phyloseq_metagenomics
# Rarefy both datasets to the same sequencing depth
rarefaction_depth <- min(sample_sums(milkps_meta), sample_sums(mother_meta), sample_sums(infant_meta))
rarefied_milk <- rarefy_even_depth(milkps_meta, sample.size = rarefaction_depth, rngseed = 42, verbose = FALSE)
rarefied_mother <- rarefy_even_depth(mother_meta, sample.size = rarefaction_depth, rngseed = 42, verbose = FALSE)
rarefied_infant <- rarefy_even_depth(infant_meta, sample.size = rarefaction_depth, rngseed = 42, verbose = FALSE)

# Calculate Shannon diversity index for both datasets
diversity_milk <- estimate_richness(rarefied_milk, measures = c("Shannon", "Observed", "Simpson") )
diversity_mother <- estimate_richness(rarefied_mother, measures = c("Shannon", "Observed", "Simpson"))
diversity_infant <- estimate_richness(rarefied_infant, measures = c("Shannon", "Observed", "Simpson"))

rownames(diversity_milk) <- gsub("^X", "", rownames(diversity_milk))

diversity_milk <- merge(
  x=diversity_milk, 
  y=milkMetadata2[, c("idbs", "timepoint", "abo", "code", "Cluster")],
  by = 0) %>%
  mutate(
    timepoint = factor(timepoint, 
                       levels = c("1421", "pn12", "pn34"), 
                       labels = c("1421", "Pn12", "Pn34")))
diversity_mother <- merge(
  x=diversity_mother, 
  y=metadataGut2[, c("idbs", "timepoint", "abo", "code", "Cluster")],
  by = 0) %>%
  mutate(
    timepoint = factor(timepoint, 
                       levels = c("incl", "tri3", "pn12", "pn56"),  
                       labels = c("Incl", "Tri3", "Pn12", "Pn56")))
diversity_infant <- merge(
  x=diversity_infant, 
  y=metadataGut2[, c("idbs", "timepoint", "abo", "code", "Cluster")],
  by = 0) %>%
  mutate(
    timepoint = factor(timepoint, 
                       levels = c("pn12", "pn56"),  
                       labels = c("Pn12", "Pn56")))


```

## Fig2D topLeft vis shannon infant

```{r}
color_values <- c("#00A98F", "#f1c232", "#1565A9")
color_labels <- c("C1", "C2", "C3")

# Step 1: Perform pairwise comparisons for each timepoint
pairwise_results <- diversity_infant %>%
  group_by(timepoint) %>%
  dplyr::summarise(
    comparisons = list(
      emmeans::emmeans(
        lme(fixed = Shannon ~ Cluster, random = ~1 | idbs, data = cur_data(), method = "REML"),
        pairwise ~ Cluster
      )$contrasts %>% 
        as.data.frame()
    ),
    .groups = "drop"
  )

# Step 2: Filter for significant comparisons and prepare data for segments
significance_annotations <- pairwise_results %>%
  tidyr::unnest(comparisons) %>%
  dplyr::mutate(
    group1 = as.numeric(factor(str_extract(contrast, "^C\\d"), levels = c("C1", "C2", "C3"))),  # Convert groups to numeric for plotting
    group2 = as.numeric(factor(str_extract(contrast, "C\\d$"), levels = c("C1", "C2", "C3")))
  ) %>%
  group_by(timepoint) %>%
  dplyr::mutate(
    y_position = max(diversity_infant$Shannon[diversity_infant$timepoint == unique(timepoint)], na.rm = TRUE) +
      0.2 * row_number()  # Incremental spacing for multiple comparisons
  ) %>%
  ungroup()

# Step 3: Apply BH FDR correction to the p-values for each comparison
significance_annotations <- significance_annotations %>%
  mutate(
    adj_p_value = p.adjust(p.value, method = "BH")  # Apply BH FDR correction to p-values
  )

# Step 4: Define significance based on adjusted p-values
significance_annotations <- significance_annotations %>%
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      adj_p_value > 0.1 & p.value <= 0.05 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )

# Step 5: Plot the data with dynamically set y_position
shannon_infant_gut <- ggplot(diversity_infant, aes(x = Cluster, y = Shannon, color = Cluster)) +
  geom_jitter(position = position_jitter(width = 0.2), alpha = 0.7) +  # Scatter plot for points
  geom_boxplot(fill = NA, alpha = 0.9, color = "grey20") +  # Boxplot without fill
  scale_color_manual(values = color_values, labels = color_labels) +  # Custom color scheme
  labs(x = "", y = "Shannon Diversity Index") +  # Labels for axes
  facet_grid(. ~ timepoint, scales = "free_x", space = "free") +  # Facets for each timepoint
  theme_bw() +  # Clean theme
  theme(
    legend.position = "right",  # Position legend
    panel.grid.major = element_blank(),  # Remove grid
    panel.grid.minor = element_blank()
  ) +
  # Add significance lines in dark red
  geom_segment(
    data = significance_annotations,
    aes(
      x = group1,
      xend = group2,
      y = y_position,
      yend = y_position
    ),
    inherit.aes = FALSE,
    color = "darkred",  # Line color
    size = 0.5
  ) +
  # Add significance labels in dark red
  geom_text(
    data = significance_annotations,
    aes(
      x = (group1 + group2) / 2,  # Midpoint between groups
      y = y_position + 0.05 ,  # Slightly above the line
      label = significance  # Use the significance labels here
    ),
    inherit.aes = FALSE,
    size = 4,
    color = "darkred"  # Text color
  )

# Display the plot
shannon_infant_gut

# Step 4: Save the plot
#svglite::svglite(
#  filename = "./forISRHML/shannon_infant_gut.svg",
#  width = 4, height = 2.3
#)
#shannon_infant_gut
#dev.off()

```

## Fig2D topRight change

```{r}
# 1. Compute per-cluster p-values
p_values_cluster <- diversity_infant %>%
  group_by(Cluster) %>%
  dplyr::summarise(
    p_value = {
      model <- lme(
        fixed = Shannon ~ timepoint,
        random = ~ 1 | idbs,
        data = cur_data(),
        method = "REML"
      )
      anova(model)["timepoint", "p-value"]
    },
    # Adjust p-values using BH FDR correction
    adj_p_value = p.adjust(p_value, method = "BH"),
    
    # Define significance levels based on adjusted p-values
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      adj_p_value > 0.1 & p_value <= 0.05 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    ),
    .groups = "drop"
  )

# 2. Merge significance levels back into the main data for annotation
diversity_infant <- diversity_infant %>%
  left_join(p_values_cluster, by = "Cluster")

# 3. Plot Shannon diversity with per-cluster significance levels
shannon_infant_change_plot <- ggplot(diversity_infant, aes(x = timepoint, y = Shannon, group = idbs)) +
  geom_line(aes(color = Cluster), alpha = 0.7) +  # Lines for each sample (idbs)
  geom_point(aes(color = Cluster), size = 2, alpha = 0.7) +  # Points for each timepoint
  stat_summary(fun = mean, geom = "line", aes(group = 1), color = "darkred", linetype = "dashed", size = 0.5) +  # Mean line
  stat_summary(fun = mean, geom = "point", aes(color = Cluster), alpha = 0, size = 0.5) +  # Mean points
  scale_color_manual(values = color_values, labels = color_labels) +  # Custom colors
  facet_wrap(~ Cluster) +  # Facet by Cluster
  labs(
    x = "",
    y = "Shannon Diversity Index",
    color = "Cluster"
  ) +
  theme_bw() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  geom_text(
    data = p_values_cluster,  # Use the significance data
    aes(x = 1.5, y = max(diversity_infant$Shannon, na.rm = TRUE), label = significance),
    inherit.aes = FALSE,
    size = 4,
    color = "darkred"
  )

# 4. Display the plot
shannon_infant_change_plot

# 5. Save as SVG
#svglite::svglite(
#  filename = "./forISRHML/shannon_infant_change_plot.svg",
#  width = 4.5, height = 2.3
#)
#shannon_infant_change_plot
#dev.off()

```

## Fig2D bottomLeft vis observed infant

```{r}
color_values <- c("#00A98F", "#f1c232", "#1565A9")
color_labels <- c("C1", "C2", "C3")

# Step 1: Perform pairwise comparisons for each timepoint
pairwise_results <- diversity_infant %>%
  group_by(timepoint) %>%
  dplyr::summarise(
    comparisons = list(
      emmeans::emmeans(
        lme(fixed = Observed ~ Cluster, random = ~1 | idbs, data = cur_data(), method = "REML"),
        pairwise ~ Cluster
      )$contrasts %>%
        as.data.frame()
    ),
    .groups = "drop"
  )

# Step 2: Extract pairwise comparisons and prepare data for significance lines
significance_annotations <- pairwise_results %>%
  tidyr::unnest(comparisons) %>%
  dplyr::mutate(
    significance = case_when(
      p.value <= 0.001 ~ "***",
      p.value <= 0.01 ~ "**",
      p.value <= 0.05 ~ "*",
      TRUE ~ ""
    ),
    group1 = str_extract(contrast, "^C\\d"),  # Extract first cluster (e.g., "C1")
    group2 = str_extract(contrast, "C\\d$"),  # Extract second cluster (e.g., "C2")
    y_position = sapply(
      timepoint,
      function(tp) max(diversity_infant$Observed[diversity_infant$timepoint == tp], na.rm = TRUE)
    ) + (row_number() - 1) * 2  # Dynamically set y_position
  ) %>%
  filter(significance != "")  # Remove non-significant comparisons

# Step 3: Plot the data
observed_infant_gut <- ggplot(diversity_infant, aes(x = Cluster, y = Observed, color = Cluster)) +
  geom_jitter(position = position_jitter(width = 0.2), alpha = 0.7) +
  geom_boxplot(fill = NA, alpha = 0.9, color = "grey20") +
  scale_color_manual(values = color_values, labels = color_labels) +
  labs(x = "", y = "Observed Richness Index") +
  facet_grid(. ~ timepoint, scales = "free_x", space = "free") +
  theme_bw() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  geom_segment(
    data = significance_annotations,
    aes(
      x = as.numeric(factor(group1, levels = unique(diversity_infant$Cluster))),
      xend = as.numeric(factor(group2, levels = unique(diversity_infant$Cluster))),
      y = y_position,
      yend = y_position
    ),
    inherit.aes = FALSE,
    color = "darkred",
    size = 0.5
  ) +
  geom_text(
    data = significance_annotations,
    aes(
      x = (as.numeric(factor(group1, levels = unique(diversity_infant$Cluster))) +
             as.numeric(factor(group2, levels = unique(diversity_infant$Cluster)))) / 2,
      y = y_position + 1,  # Slightly above the line
      label = significance
    ),
    inherit.aes = FALSE,
    size = 4,
    color = "darkred"
  )

# Step 4: Display the plot
observed_infant_gut


# Step 4: Save the plot
#svglite::svglite(
#  filename = "./forISRHML/observed_infant_gut.svg",
#  width = 4, height = 2.3
#)
#observed_infant_gut
#dev.off()

```

## Fig2D bottomRIght change

```{r}
# 1. Compute per-cluster p-values
p_values_cluster <- diversity_infant %>%
  group_by(Cluster) %>%
  dplyr::summarise(
    p_value = {
      model <- lme(
        fixed = Observed ~ timepoint,
        random = ~ 1 | idbs,
        data = cur_data(),
        method = "REML"
      )
      anova(model)["timepoint", "p-value"]
    },
    significance = case_when(  # Add significance levels
      p_value <= 0.001 ~ "***",
      p_value <= 0.01 ~ "**",
      p_value <= 0.05 ~ "*",
      TRUE ~ ""
    ),
    .groups = "drop"
  )

# 2. Merge significance levels back into the main data for annotation
diversity_infant <- diversity_infant %>%
  left_join(p_values_cluster, by = "Cluster")

# 3. Plot Observed diversity with per-cluster significance levels
observed_infant_change_plot <- ggplot(diversity_infant, aes(x = timepoint, y = Observed, group = idbs)) +
  geom_line(aes(color = Cluster), alpha = 0.7) +  # Lines for each sample (idbs)
  geom_point(aes(color = Cluster), size = 2, alpha = 0.7) +  # Points for each timepoint
  stat_summary(fun = mean, geom = "line", aes(group = 1), color = "darkred", linetype = "dashed", size = 0.5) +  # Mean line
  stat_summary(fun = mean, geom = "point", aes(color = Cluster), alpha = 0, size = 0.5) +  # Mean points
  scale_color_manual(values = color_values, labels = color_labels) +  # Custom colors
  facet_wrap(~ Cluster) +  # Facet by Cluster
  labs(
    x = "",
    y = "Observed Richness Index",
    color = "Cluster"
  ) +
  theme_bw() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  geom_text(
    data = p_values_cluster,  # Use the significance data
    aes(x = 1.5, y = max(diversity_infant$Observed, na.rm = TRUE), label = significance),
    inherit.aes = FALSE,
    size = 4,
    color = "darkred"
  )

# 4. Display the plot
observed_infant_change_plot

# 5. Save as SVG
#svglite::svglite(
#  filename = "./forISRHML/observed_infant_change_plot.svg",
#  width = 4.5, height = 2.3
#)
#observed_infant_change_plot
#dev.off()

```

## Fig3B vis shannon mother

```{r}
color_values <- c("#00A98F", "#f1c232", "#1565A9")
color_labels <- c("C1", "C2", "C3")

# Step 1: Perform pairwise comparisons for each timepoint
# Step 1: Fit the model and get pairwise comparisons using emmeans
pairwise_results <- diversity_mother %>%
  group_by(timepoint) %>%
  dplyr::summarise(
    comparisons = list(
      emmeans::emmeans(
        lme(fixed = Shannon ~ Cluster, random = ~1 | idbs, data = cur_data(), method = "REML"),
        pairwise ~ Cluster
      )$contrasts %>%
        as.data.frame()
    ),
    .groups = "drop"
  )

# Step 2: Extract pairwise comparisons and prepare data for significance lines
significance_annotations <- pairwise_results %>%
  tidyr::unnest(comparisons) %>%
  dplyr::mutate(
    # Extract groups for plotting
    group1 = str_extract(contrast, "^C\\d"),  # First cluster (e.g., "C1")
    group2 = str_extract(contrast, "C\\d$"),  # Second cluster (e.g., "C2"),
    
    # Adjust p-values using BH FDR correction
    adj_p_value = p.adjust(p.value, method = "BH"),
    
    # Significance based on adjusted p-value
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      adj_p_value > 0.1 & p.value <= 0.05 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    ),
    
    # Dynamically set y_position for the significance lines
    y_position = sapply(
      timepoint,
      function(tp) max(diversity_mother$Shannon[diversity_mother$timepoint == tp], na.rm = TRUE)
    ) + (row_number() - 1) * 0.03  # Incremental spacing for multiple comparisons
  ) %>%
  filter(significance != "")  # Remove non-significant comparisons

# Step 3: Plot the data
shannon_mother_gut <- ggplot(diversity_mother, aes(x = Cluster, y = Shannon, color = Cluster)) +
  geom_jitter(position = position_jitter(width = 0.2), alpha = 0.7) +  # Scatter plot for points
  geom_boxplot(fill = NA, alpha = 0.9, color = "grey20") +  # Boxplot without fill
  scale_color_manual(values = color_values, labels = color_labels) +  # Custom color scheme
  labs(x = "", y = "Shannon Diversity Index") +  # Labels for axes
  facet_grid(. ~ timepoint, scales = "free_x", space = "free") +  # Facets for each timepoint
  theme_bw() +  # Clean theme
  theme(
    legend.position = "right",  # Position legend
    panel.grid.major = element_blank(),  # Remove grid
    panel.grid.minor = element_blank()
  ) +
  # Add significance lines in dark red
  geom_segment(
    data = significance_annotations,
    aes(
      x = as.numeric(factor(group1, levels = unique(diversity_mother$Cluster))),
      xend = as.numeric(factor(group2, levels = unique(diversity_mother$Cluster))),
      y = y_position,
      yend = y_position
    ),
    inherit.aes = FALSE,
    color = "darkred",  # Line color
    size = 0.5
  ) +
  # Add significance labels in dark red
  geom_text(
    data = significance_annotations,
    aes(
      x = (as.numeric(factor(group1, levels = unique(diversity_mother$Cluster))) +
             as.numeric(factor(group2, levels = unique(diversity_mother$Cluster)))) / 2,  # Midpoint between groups
      y = y_position + 0.01,  # Slightly above the line
      label = significance  # Use the significance labels here
    ),
    inherit.aes = FALSE,
    size = 4,
    color = "darkred"  # Text color
  )

# Step 4: Display the plot
shannon_mother_gut


# Step 4: Save the plot
# svglite::svglite(
#   filename = "./forISRHML/shannon_mother_gut.svg",
#   width = 6, height = 2.3
# )
# shannon_mother_gut
#dev.off()

```

## Fig4B vis shannon milk

```{r}
color_values <- c("#00A98F", "#f1c232", "#1565A9")
color_labels <- c("C1", "C2", "C3")

# Step 1: Perform pairwise comparisons for each timepoint
pairwise_results <- diversity_milk %>%
  group_by(timepoint) %>%
  dplyr::summarise(
    comparisons = list(
      emmeans::emmeans(
        lme(fixed = Shannon ~ Cluster, random = ~1 | idbs, data = cur_data(), method = "REML"),
        pairwise ~ Cluster
      )$contrasts %>%
        as.data.frame()
    ),
    .groups = "drop"
  )

# Step 2: Extract pairwise comparisons and prepare data for significance lines
significance_annotations <- pairwise_results %>%
  tidyr::unnest(comparisons) %>%
  dplyr::mutate(
    # Adjust p-values using BH FDR correction
    adj_p_value = p.adjust(p.value, method = "BH"),
    
    # Define significance based on adjusted p-values
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      adj_p_value > 0.1 & p.value <= 0.05 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    ),
    
    # Extract groups for plotting
    group1 = str_extract(contrast, "^C\\d"),  # First cluster (e.g., "C1")
    group2 = str_extract(contrast, "C\\d$"),  # Second cluster (e.g., "C2"),
    
    # Dynamically set y_position for the significance lines
    y_position = ave(rep(1, n()), timepoint, FUN = seq_along) * 0.1 + 
      max(diversity_milk$Shannon, na.rm = TRUE)
  ) %>%
  filter(significance != "")  # Remove non-significant comparisons

# Step 3: Plot the data
shannon_milk <- ggplot(diversity_milk, aes(x = Cluster, y = Shannon, color = Cluster)) +
  geom_jitter(position = position_jitter(width = 0.2), alpha = 0.7) +  # Scatter plot for points
  geom_boxplot(fill = NA, alpha = 0.9, color = "grey20") +  # Boxplot without fill
  scale_color_manual(values = color_values, labels = color_labels) +  # Custom color scheme
  labs(x = "", y = "Shannon Diversity Index") +  # Labels for axes
  facet_grid(. ~ timepoint, scales = "free_x", space = "free") +  # Facets for each timepoint
  theme_bw() +  # Clean theme
  theme(
    legend.position = "right",  # Position legend
    panel.grid.major = element_blank(),  # Remove grid
    panel.grid.minor = element_blank()
  ) +
  # Add significance lines in dark red
  geom_segment(
    data = significance_annotations,
    aes(
      x = as.numeric(factor(group1, levels = unique(diversity_milk$Cluster))),
      xend = as.numeric(factor(group2, levels = unique(diversity_milk$Cluster))),
      y = y_position,
      yend = y_position
    ),
    inherit.aes = FALSE,
    color = "darkred",  # Line color
    size = 0.5
  ) +
  # Add significance labels in dark red
  geom_text(
    data = significance_annotations,
    aes(
      x = (as.numeric(factor(group1, levels = unique(diversity_milk$Cluster))) +
           as.numeric(factor(group2, levels = unique(diversity_milk$Cluster)))) / 2,  # Midpoint between groups
      y = y_position + 0.2,  # Slightly above the line
      label = significance  # Use the significance labels here
    ),
    inherit.aes = FALSE,
    size = 4,
    color = "darkred"  # Text color
  )

# Step 4: Display the plot
shannon_milk

# Step 4: Save the plot
#svglite::svglite(
#  filename = "./forISRHML/shannon_milk.svg",
#  width = 5, height = 2.5
#)
#shannon_milk
#dev.off()

```

# Beta diversity

### Fig2E infant

```{r message=FALSE}
# Calculate the UniFrac distance matrix
unifrac_dist <- phyloseq::distance(infant_meta, method="unifrac", weighted=TRUE)

# Perform PCoA ordination using the calculated distance matrix
infant_ord <- ordinate(infant_meta, method="PCoA", distance=unifrac_dist)
phyloseq::plot_scree(infant_ord) + geom_bar(stat = "identity", fill="blue") + labs(x="\nAxis", y="Proportion of Variance\n")
head(infant_ord$values$Eigenvalues)

infant_eig1 <- infant_ord$values$Eigenvalues[1]/sum(infant_ord$values$Eigenvalues)
infant_eig2 <- infant_ord$values$Eigenvalues[2]/sum(infant_ord$values$Eigenvalues)

beta_infant <- phyloseq::plot_ordination(infant_meta, infant_ord, color = "Cluster") + 
  scale_color_manual(
    name="Cluster", 
    values = COLOR_SCHEME[1:3]
    ) +
  geom_point(size=1) +
  #coord_fixed(infant_eig1/infant_eig2) +
  stat_ellipse(aes(group=Cluster), linetype=2) +
  theme_bw() +
  theme(legend.position = "right") +
  facet_wrap(~ timepoint, scales = "fixed")

  beta_infant

#svglite::svglite(
#  filename="./forISRHML/beta_infant.svg",
#  width=5, height=3.5
#  )
#beta_infant
#dev.off()

# Perform UniFrac distance calculation and Adonis test for infant
infant_dist <- UniFrac(infant_meta, weighted = TRUE, normalized = TRUE, parallel = FALSE, fast = TRUE)
infant_adonis <- vegan::adonis2(infant_dist ~ phyloseq::sample_data(infant_meta)$Cluster * phyloseq::sample_data(infant_meta)$timepoint)

# test for homogeneity of dispersions
group_time <- phyloseq::sample_data(infant_meta)$timepoint
dispersion_time <- betadisper(infant_dist, group_time)
permutest_time <- permutest(dispersion_time)
permutest_time

# Perform UniFrac distance calculation and Adonis test for pn12e
pn12e_dist <- UniFrac(pn12e_meta, weighted = TRUE, normalized = TRUE, parallel = FALSE, fast = TRUE)
pn12e_adonis <- vegan::adonis2(pn12e_dist ~ phyloseq::sample_data(pn12e_meta)$Cluster)

# Perform UniFrac distance calculation and Adonis test for pn56e
pn56e_dist <- UniFrac(pn56e_meta, weighted = TRUE, normalized = TRUE, parallel = FALSE, fast = TRUE)
pn56e_adonis <- vegan::adonis2(pn56e_dist ~ phyloseq::sample_data(pn56e_meta)$Cluster)


# Extract p-values from the adonis results
infant_pvalues <- infant_adonis[2,5]  # p-values from infant dataset
pn12e_pvalues <- pn12e_adonis[1,5]  # p-values from pn12e dataset
pn56e_pvalues <- pn56e_adonis[1,5] # p-values from pn56e dataset

# Adjust p-values for FDR using Benjamini-Hochberg method
p.adjust(infant_pvalues, method = "BH")
p.adjust(pn12e_pvalues, method = "BH")
p.adjust(pn56e_pvalues, method = "BH")

```

### Fig3C mother

```{r message=FALSE}
# Calculate the UniFrac distance matrix
mother_dist <- phyloseq::distance(mother_meta, method="unifrac", weighted=TRUE)

# Perform PCoA ordination using the calculated distance matrix
mother_ord <- ordinate(mother_meta, method="PCoA", distance=mother_dist)
phyloseq::plot_scree(mother_ord) + geom_bar(stat = "identity", fill="blue") + labs(x="\nAxis", y="Proportion of Variance\n")
head(mother_ord$values$Eigenvalues)

mother_eig1 <- mother_ord$values$Eigenvalues[1]/sum(mother_ord$values$Eigenvalues)
mother_eig2 <- mother_ord$values$Eigenvalues[2]/sum(mother_ord$values$Eigenvalues)

# Ensure timepoint is a factor with the correct order
mother_meta@sam_data$timepoint <- factor(
  mother_meta@sam_data$timepoint, 
  levels = c("incl", "tri3", "pn12", "pn56")  # Define the desired order
)

# Plot beta diversity with ordered facets
beta_mother <- phyloseq::plot_ordination(mother_meta, mother_ord, color = "Cluster") +  
  scale_color_manual(name="Cluster", values = COLOR_SCHEME[1:3]) +
  geom_point(size=1.5, alpha=0.8) +  # Increase point size & opacity
  stat_ellipse(aes(group=Cluster), linetype=2) +  # Add ellipses
  theme_bw() +  
  theme(legend.position = "bottom") +  
  facet_wrap(~ timepoint, scales = "fixed", ncol = 4)  # Set order & columns

beta_mother

#svglite::svglite(
#  filename="./forISRHML/beta_mother.svg",
#  width=5.5, height=2.7
#  )
#beta_mother
#dev.off()

mother_dist <-UniFrac(mother_meta, weighted = TRUE, normalized = TRUE, parallel = FALSE, fast=TRUE)
vegan::adonis2(mother_dist ~ phyloseq::sample_data(mother_meta)$Cluster + phyloseq::sample_data(mother_meta)$timepoint )

incl_dist <-UniFrac(incl_meta, weighted = TRUE, normalized = TRUE, parallel = FALSE, fast=TRUE)
incl_adonis <- vegan::adonis2(incl_dist ~ phyloseq::sample_data(incl_meta)$Cluster)

tri3_dist <-UniFrac(tri3_meta, weighted = TRUE, normalized = TRUE, parallel = FALSE, fast=TRUE)
tri3_adonis <- vegan::adonis2(tri3_dist ~ phyloseq::sample_data(tri3_meta)$Cluster)

pn12m_dist <-UniFrac(pn12m_meta, weighted = TRUE, normalized = TRUE, parallel = FALSE, fast=TRUE)
pn12m_adonis <- vegan::adonis2(pn12m_dist ~ phyloseq::sample_data(pn12m_meta)$Cluster)

pn56m_dist <-UniFrac(pn56m_meta, weighted = TRUE, normalized = TRUE, parallel = FALSE, fast=TRUE)
pn56m_adonis <- vegan::adonis2(pn56m_dist ~ phyloseq::sample_data(pn56m_meta)$Cluster)

# Extract p-values from the adonis results
incl_pvalues <- incl_adonis[1,5]  # p-values from infant dataset
p.adjust(incl_pvalues, method = "BH")

tri3_pvalues <- tri3_adonis[1,5]  # p-values from infant dataset
p.adjust(tri3_pvalues, method = "BH")

pn12m_pvalues <- pn12m_adonis[1,5]  # p-values from infant dataset
p.adjust(pn12m_pvalues, method = "BH")

pn56m_pvalues <- pn56m_adonis[1,5]  # p-values from infant dataset
p.adjust(pn56m_pvalues, method = "BH")

```

### FIg4C milk

```{r message=FALSE}
# Calculate the UniFrac distance matrix
milkps_dist <- phyloseq::distance(milkps_meta, method="unifrac", weighted=TRUE)

# Perform PCoA ordination using the calculated distance matrix
milkps_ord <- ordinate(milkps_meta, method="PCoA", distance=milkps_dist)
phyloseq::plot_scree(milkps_ord) + geom_bar(stat = "identity", fill="blue") + labs(x="\nAxis", y="Proportion of Variance\n")
head(milkps_ord$values$Eigenvalues)

milkps_eig1 <- milkps_ord$values$Eigenvalues[1]/sum(milkps_ord$values$Eigenvalues)
milkps_eig2 <- milkps_ord$values$Eigenvalues[2]/sum(milkps_ord$values$Eigenvalues)

# Ensure timepoint is a factor with the correct order
milkps_meta@sam_data$timepoint <- factor(
  milkps_meta@sam_data$timepoint, 
  levels = c("1421", "pn12", "pn34")  # Define the desired order
)

# Plot beta diversity with ordered facets
beta_milkps <- phyloseq::plot_ordination(milkps_meta, milkps_ord, color = "Cluster") +  
  scale_color_manual(name="Cluster", values = COLOR_SCHEME[1:3]) +
  geom_point(size=1.5, alpha=0.8) +  # Increase point size & opacity
  stat_ellipse(aes(group=Cluster), linetype=2) +  # Add ellipses
  theme_bw() +  
  theme(legend.position = "right") +  
  facet_wrap(~ timepoint, scales = "fixed", ncol = 3)  # Set order & columns

beta_milkps

#svglite::svglite(
#  filename="./forISRHML/beta_milkps.svg",
#  width=5, height=2.5
#  )
#beta_milkps
#dev.off()

milkps_dist <-UniFrac(milkps_meta, weighted = TRUE, normalized = TRUE, parallel = FALSE, fast=TRUE)
vegan::adonis2(milkps_dist ~ phyloseq::sample_data(milkps_meta)$Cluster + phyloseq::sample_data(milkps_meta)$timepoint )



```

# DAA

## FigS5A top infant pn12e

```{r message=FALSE}
pn12e_daa <- ancombc2(data=pn12e_meta, 
                        assay_name = "counts", tax_level = "species",
                        fix_formula = "Cluster", rand_formula = NULL,
                        p_adj_method = "BH", 
                        prv_cut = 0.1,
                        lib_cut = 1000, s0_perc = 0.05,
                        group = "Cluster", struc_zero = TRUE, neg_lb = TRUE,
                        alpha = 0.05, n_cl = 2, verbose = TRUE,
                        global = F, pairwise = F, dunnet = F, trend = F,
                        iter_control = list(tol=1e-2, max_iter=1, verbose=TRUE),
                        em_control = list(tol=1e-5, max_iter=100),
                        lme_control = lme4::lmerControl(),
                        mdfdr_control = list(fwer_ctrl_method = "BH", B=1000),
                        trend_control = list(contrast=list(matrix(c(1,0,-1,1),
                                                                  nrow = 2,
                                                                  byrow = TRUE)),
                                             node=list(2),
                                             solver="ECOS",
                                             B=10))

result_pn12e_daa = pn12e_daa$res

#write.xlsx(result_pn12e_daa, "./forISRHML/result_pn12e_daa.xlsx")

##### C2 vs C1
daa_pn12e_C2vC1 <- result_pn12e_daa |>
  mutate(`q_ClusterC2`=-log10(`q_ClusterC2`)) |>
  mutate(color=if_else(`lfc_ClusterC2`>0, "steelblue", "darkred")) |>
  mutate(label=if_else(abs(`lfc_ClusterC2`)>2 & `q_ClusterC2` >1.3 & `passed_ss_ClusterC2` == TRUE, taxon, NA_character_)) |>
  mutate(color=if_else(abs(`lfc_ClusterC2`)<2 & `q_ClusterC2` <1.3, "#000000", color)) |>
  mutate(color=if_else(`passed_ss_ClusterC2` == FALSE, "grey55", color)) |>
  ggplot(mapping = aes(`lfc_ClusterC2`, `q_ClusterC2`, color=I(color), label=label, shape=I(1))) +
  geom_point() +
  geom_hline(linetype = "dotted", yintercept = 1.3) +
  geom_vline(linetype = "dotted", xintercept = 2) +
  geom_vline(linetype = "dotted", xintercept = -2) +
  geom_label_repel(min.segment.length = 0, force = 10, max.overlaps = 20, na.rm = TRUE) +
  labs(title = "Infant gut Pn12: C2 vs. C1",
       x = expression(~Log[2]~FoldChange),
       y = expression(-~Log[10]~P)) +
  theme_bw()  + xlim(-3.5, 3.5) 
daa_pn12e_C2vC1

#ggsave("./forISRHML/daa_pn12e_C2vC1.svg", daa_pn12e_C2vC1, width = 3, height = 3.5, dpi = 300)



sample_data(pn12e_meta)$Cluster <- relevel(factor(sample_data(pn12e_meta)$Cluster), ref = "C3")

pn12e_daa2 <- ancombc2(data=pn12e_meta, 
                        assay_name = "counts", tax_level = "species",
                        fix_formula = "Cluster", rand_formula = NULL,
                        p_adj_method = "BH", 
                        prv_cut = 0.1,
                        lib_cut = 1000, s0_perc = 0.05,
                        group = "Cluster", struc_zero = TRUE, neg_lb = TRUE,
                        alpha = 0.05, n_cl = 2, verbose = TRUE,
                        global = F, pairwise = F, dunnet = F, trend = F,
                        iter_control = list(tol=1e-2, max_iter=1, verbose=TRUE),
                        em_control = list(tol=1e-5, max_iter=100),
                        lme_control = lme4::lmerControl(),
                        mdfdr_control = list(fwer_ctrl_method = "BH", B=1000),
                        trend_control = list(contrast=list(matrix(c(1,0,-1,1),
                                                                  nrow = 2,
                                                                  byrow = TRUE)),
                                             node=list(2),
                                             solver="ECOS",
                                             B=10))

result_pn12e_daa2 = pn12e_daa2$res
#write.xlsx(result_pn12e_daa2, "./forISRHML/result_pn12e_daa2.xlsx")

##### C2 vs C3
daa_pn12e_C2vC3 <- result_pn12e_daa2 |>
  mutate(`q_ClusterC2`=-log10(`q_ClusterC2`)) |>
  mutate(color=if_else(`lfc_ClusterC2`>0, "steelblue", "darkred")) |>
  mutate(label=if_else(abs(`lfc_ClusterC2`)>0.5 & `q_ClusterC2` >1.3 & `passed_ss_ClusterC2` == TRUE, taxon, NA_character_)) |>
  mutate(color=if_else(abs(`lfc_ClusterC2`)<0.5 & `q_ClusterC2` <1.3, "#000000", color)) |>
  mutate(color=if_else(`passed_ss_ClusterC2` == FALSE, "grey55", color)) |>
  ggplot(mapping = aes(`lfc_ClusterC2`, `q_ClusterC2`, color=I(color), label=label, shape=I(1))) +
  geom_point() +
  geom_hline(linetype = "dotted", yintercept = 1.3) +
  geom_vline(linetype = "dotted", xintercept = 0.5) +
  geom_vline(linetype = "dotted", xintercept = -0.5) +
  geom_label_repel(min.segment.length = 0, force = 10, max.overlaps = 20, na.rm = TRUE) +
  labs(title = "Infant gut Pn12: C2 vs. C3",
       x = expression(~Log[2]~FoldChange),
       y = expression(-~Log[10]~P)) +
  theme_bw()  + xlim(-3.5, 3.5) 
daa_pn12e_C2vC3

#ggsave("./forISRHML/daa_pn12e_C2vC3.svg", daa_pn12e_C2vC3, width = 3, height = 3.5, dpi = 300)

##### C1 vs C3
daa_pn12e_C1vC3 <- result_pn12e_daa2 |>
  mutate(`q_ClusterC1`=-log10(`q_ClusterC1`)) |>
  mutate(color=if_else(`lfc_ClusterC1`>0, "steelblue", "darkred")) |>
  mutate(label=if_else(abs(`lfc_ClusterC1`)>2 & `q_ClusterC1` >2 & `passed_ss_ClusterC1` == TRUE, taxon, NA_character_)) |>
  mutate(color=if_else(abs(`lfc_ClusterC1`)<2 & `q_ClusterC1` <1.3, "#000000", color)) |>
  mutate(color=if_else(`passed_ss_ClusterC1` == FALSE, "grey55", color)) |>
  ggplot(mapping = aes(`lfc_ClusterC1`, `q_ClusterC1`, color=I(color), label=label, shape=I(1))) +
  geom_point() +
  geom_hline(linetype = "dotted", yintercept = 1.3) +
  geom_vline(linetype = "dotted", xintercept = 2) +
  geom_vline(linetype = "dotted", xintercept = -2) +
  geom_label_repel(min.segment.length = 0, force = 10, max.overlaps = 20, na.rm = TRUE) +
  labs(title = "Infant gut Pn12: C1 vs. C3",
       x = expression(~Log[2]~FoldChange),
       y = expression(-~Log[10]~P)) +
  theme_bw()  + xlim(-3.5, 3.5) 
daa_pn12e_C1vC3

#ggsave("./forISRHML/daa_pn12e_C1vC3.svg", daa_pn12e_C1vC3, width = 3, height = 3.5, dpi = 300)

sample_data(pn12e_meta)$Cluster <- relevel(factor(sample_data(pn12e_meta)$Cluster), ref = "C2")

sample_data(pn12e_meta)$Cluster <- relevel(factor(sample_data(pn12e_meta)$Cluster), ref = "C1")

```

## FigS5A bottom infant pn56e

```{r message=FALSE}
pn56e_daa <- ancombc2(data=pn56e_meta, 
                        assay_name = "counts", tax_level = "species",
                        fix_formula = "Cluster", rand_formula = NULL,
                        p_adj_method = "BH", 
                        prv_cut = 0.1,
                        lib_cut = 1000, s0_perc = 0.05,
                        group = "Cluster", struc_zero = TRUE, neg_lb = TRUE,
                        alpha = 0.05, n_cl = 2, verbose = TRUE,
                        global = F, pairwise = F, dunnet = F, trend = F,
                        iter_control = list(tol=1e-2, max_iter=1, verbose=TRUE),
                        em_control = list(tol=1e-5, max_iter=100),
                        lme_control = lme4::lmerControl(),
                        mdfdr_control = list(fwer_ctrl_method = "BH", B=1000),
                        trend_control = list(contrast=list(matrix(c(1,0,-1,1),
                                                                  nrow = 2,
                                                                  byrow = TRUE)),
                                             node=list(2),
                                             solver="ECOS",
                                             B=10))

result_pn56e_daa = pn56e_daa$res
#write.xlsx(result_pn56e_daa, "./forISRHML/result_pn56e_daa.xlsx")

##### C2 vs C1
daa_pn56e_C2vC1 <- result_pn56e_daa |>
  mutate(`q_ClusterC2`=-log10(`q_ClusterC2`)) |>
  mutate(color=if_else(`lfc_ClusterC2`>0, "steelblue", "darkred")) |>
  mutate(label=if_else(abs(`lfc_ClusterC2`)>2 & `q_ClusterC2` >1.3 & `passed_ss_ClusterC2` == TRUE, taxon, NA_character_)) |>
  mutate(color=if_else(abs(`lfc_ClusterC2`)<2 & `q_ClusterC2` <1.3, "#000000", color)) |>
  mutate(color=if_else(`passed_ss_ClusterC2` == FALSE, "grey55", color)) |>
  ggplot(mapping = aes(`lfc_ClusterC2`, `q_ClusterC2`, color=I(color), label=label, shape=I(1))) +
  geom_point() +
  geom_hline(linetype = "dotted", yintercept = 1.3) +
  geom_vline(linetype = "dotted", xintercept = 2) +
  geom_vline(linetype = "dotted", xintercept = -2) +
  geom_label_repel(min.segment.length = 0, force = 10, max.overlaps = 20, na.rm = TRUE) +
  labs(title = "Infant gut pn56: C2 vs. C1",
       x = expression(~Log[2]~FoldChange),
       y = expression(-~Log[10]~P)) +
  theme_bw()  + xlim(-3.5, 3.5) 
daa_pn56e_C2vC1

#ggsave("./forISRHML/daa_pn56e_C2vC1.svg", daa_pn56e_C2vC1, width = 3, height = 3.5, dpi = 300)

##### C3 vs C1
daa_pn56e_C3vC1 <- result_pn56e_daa |>
  mutate(`q_ClusterC3`=-log10(`q_ClusterC3`)) |>
  mutate(color=if_else(`lfc_ClusterC3`>0, "steelblue", "darkred")) |>
  mutate(label=if_else(abs(`lfc_ClusterC3`)>2 & `q_ClusterC3` >2 & `passed_ss_ClusterC3` == TRUE, taxon, NA_character_)) |>
  mutate(color=if_else(abs(`lfc_ClusterC3`)<2 & `q_ClusterC3` <1.3, "#000000", color)) |>
  mutate(color=if_else(`passed_ss_ClusterC3` == FALSE, "grey55", color)) |>
  ggplot(mapping = aes(`lfc_ClusterC3`, `q_ClusterC3`, color=I(color), label=label, shape=I(1))) +
  geom_point() +
  geom_hline(linetype = "dotted", yintercept = 1.3) +
  geom_vline(linetype = "dotted", xintercept = 2) +
  geom_vline(linetype = "dotted", xintercept = -2) +
  geom_label_repel(min.segment.length = 0, force = 10, max.overlaps = 20, na.rm = TRUE) +
  labs(title = "Infant gut pn56: C3 vs. C1",
       x = expression(~Log[2]~FoldChange),
       y = expression(-~Log[10]~P)) +
  theme_bw()  + xlim(-3.5, 3.5) 
daa_pn56e_C3vC1

#ggsave("./forISRHML/daa_pn56e_C3vC1.svg", daa_pn56e_C3vC1, width = 3, height = 3.5, dpi = 300)


sample_data(pn56e_meta)$Cluster <- relevel(factor(sample_data(pn56e_meta)$Cluster), ref = "C3")

pn56e_daa2 <- ancombc2(data=pn56e_meta, 
                        assay_name = "counts", tax_level = "species",
                        fix_formula = "Cluster", rand_formula = NULL,
                        p_adj_method = "BH", 
                        prv_cut = 0.1,
                        lib_cut = 1000, s0_perc = 0.05,
                        group = "Cluster", struc_zero = TRUE, neg_lb = TRUE,
                        alpha = 0.05, n_cl = 2, verbose = TRUE,
                        global = F, pairwise = F, dunnet = F, trend = F,
                        iter_control = list(tol=1e-2, max_iter=1, verbose=TRUE),
                        em_control = list(tol=1e-5, max_iter=100),
                        lme_control = lme4::lmerControl(),
                        mdfdr_control = list(fwer_ctrl_method = "BH", B=1000),
                        trend_control = list(contrast=list(matrix(c(1,0,-1,1),
                                                                  nrow = 2,
                                                                  byrow = TRUE)),
                                             node=list(2),
                                             solver="ECOS",
                                             B=10))

result_pn56e_daa2 = pn56e_daa2$res
#write.xlsx(result_pn56e_daa2, "./forISRHML/result_pn56e_daa2.xlsx")

##### C1 vs C3
daa_pn56e_C2vC3 <- result_pn56e_daa2 |>
  mutate(`q_ClusterC2`=-log10(`q_ClusterC2`)) |>
  mutate(color=if_else(`lfc_ClusterC2`>0, "steelblue", "darkred")) |>
  mutate(label=if_else(abs(`lfc_ClusterC2`)>2 & `q_ClusterC2` >2 & `passed_ss_ClusterC2` == TRUE, taxon, NA_character_)) |>
  mutate(color=if_else(abs(`lfc_ClusterC2`)<2 & `q_ClusterC2` <1.3, "#000000", color)) |>
  mutate(color=if_else(`passed_ss_ClusterC2` == FALSE, "grey55", color)) |>
  ggplot(mapping = aes(`lfc_ClusterC2`, `q_ClusterC2`, color=I(color), label=label, shape=I(1))) +
  geom_point() +
  geom_hline(linetype = "dotted", yintercept = 1.3) +
  geom_vline(linetype = "dotted", xintercept = 2) +
  geom_vline(linetype = "dotted", xintercept = -2) +
  geom_label_repel(min.segment.length = 0, force = 10, max.overlaps = 20, na.rm = TRUE) +
  labs(title = "Infant gut Pn56: C2 vs. C3",
       x = expression(~Log[2]~FoldChange),
       y = expression(-~Log[10]~P)) +
  theme_bw()  + xlim(-3.5, 3.5) 
daa_pn56e_C2vC3

#ggsave("./forISRHML/daa_pn56e_C2vC3.svg", daa_pn56e_C2vC3, width = 3, height = 3.5, dpi = 300)


sample_data(pn56e_meta)$Cluster <- relevel(factor(sample_data(pn56e_meta)$Cluster), ref = "C1")

```

# Longitudinal

## Fig2F infant

```{r message=FALSE}
infant_species <- infant_meta %>%
  tax_glom(taxrank = "species") %>%
  transform_sample_counts(function(x){x/sum(x)}) %>%
  psmelt() %>%
  filter(Abundance > 0)

summary_relAbuSpeInf <- summarySE(infant_species, measurevar = "Abundance", groupvars = c("species", "timepoint", "Cluster"), na.rm = TRUE)%>%
  group_by(species) %>%
  filter(all(N>5)) %>%
  ungroup()

avg_abundance <- infant_species %>%
  group_by(species) %>%
  dplyr::summarise(avg_abundance = mean(Abundance, na.rm = TRUE)) %>%
  arrange(desc(avg_abundance))

# Select the top 15 species
top_fifteen_species <- avg_abundance %>%
  filter(species %in% summary_relAbuSpeInf$species) %>%
  slice_max(order_by = avg_abundance, n=12) %>%
  pull(species)

# Filter the dataset to include only the top 15 species
filtered_data <- summary_relAbuSpeInf %>%
  filter(species %in% top_fifteen_species) %>%
  dplyr::mutate(Abundance = Abundance *100) %>%
  dplyr::mutate(se = se*100) %>%
  dplyr::mutate(sd=sd*100) %>%
  dplyr::mutate(ci = ci*100) %>%
  dplyr::mutate(species = factor(species, levels = top_fifteen_species)) %>%
  arrange(factor(species, levels = rev(top_fifteen_species)))

plotInfClustter <- ggplot(filtered_data, aes(x = timepoint, y = Abundance, color = Cluster)) +
  geom_errorbar(aes(ymin = Abundance - se, ymax = Abundance + se), linetype = "solid", width = 0.05, position = position_dodge(0.05), alpha = 0.5) +
  geom_line(aes(group = interaction(species, Cluster)), linetype = "solid", position = position_dodge(0.05)) +
  geom_point(position = position_dodge(0.05)) +
  facet_wrap(~ species, scales = "free_y", ncol = 4) +  # Facet by species
  theme_bw() +
  labs(color = "Cluster", y = "Relative Abundance, %", x = "Timepoint") +
  scale_color_manual(values = c("C1" = "#00A98F", "C2" = "#FFC000", "C3" = "#1565A9")) +
  expand_limits(y = 0.0) +  # Ensure y-axis starts at 0
  theme(
    panel.spacing = unit(0.5, "lines"),
    strip.text = element_text(size = 8)
  )
  
plotInfClustter

#svglite::svglite(
#  filename = "./forISRHML/plotInfClustter.svg",
#  width = 8, height = 4
#)
#plotInfClustter
#dev.off()

library(dplyr)
library(ggplot2)
library(forcats)

# Use the long-format data with individual-level values
raw_filtered_data <- infant_species %>%
  filter(species %in% top_fifteen_species) %>%
  mutate(
    Abundance = Abundance * 100,
    species = factor(species, levels = top_fifteen_species)
  )

# Compute p-values using ANOVA per species per timepoint
p_values_data <- raw_filtered_data %>%
  group_by(species, timepoint) %>%
  dplyr::summarise(
    p_value = tryCatch(
      anova(lm(Abundance ~ Cluster, data = cur_data()))$`Pr(>F)`[1],
      error = function(e) NA_real_
    ),
    max_y = max(Abundance, na.rm = TRUE),
    min_y = min(Abundance, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    adj_p_value = p.adjust(p_value, method = "BH"),
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",
      adj_p_value <= 0.01 ~ "**",
      adj_p_value <= 0.05 ~ "*",
      adj_p_value <= 0.1 ~ ".",
      adj_p_value > 0.1 & p_value <= 0.05 ~ "~",
      TRUE ~ ""
    ),
    species = factor(species, levels = top_fifteen_species)
  )

# Base plot with means and SE
plotInfCluster <- ggplot(filtered_data, aes(x = timepoint, y = Abundance, color = Cluster)) +
  geom_errorbar(
    aes(ymin = Abundance - se, ymax = Abundance + se),
    linetype = "solid", width = 0.05, position = position_dodge(0.05), alpha = 0.5
  ) +
  geom_line(aes(group = interaction(species, Cluster)), linetype = "solid", position = position_dodge(0.05)) +
  geom_point(position = position_dodge(0.05)) +
  facet_wrap(~ species, scales = "free_y", ncol = 4) +
  theme_bw() +
  labs(color = "Cluster", y = "Relative Abundance (%)", x = "Timepoint") +
  scale_color_manual(values = c("C1" = "#00A98F", "C2" = "#FFC000", "C3" = "#1565A9")) +
  expand_limits(y = 0.0) +
  theme(
    panel.spacing = unit(0.5, "lines"),
    strip.text = element_text(size = 8)
  )

# Add significance labels
plotInfCluster + 
  geom_text(
    data = p_values_data,
    aes(
      x = as.numeric(as.factor(timepoint)),
      y = max_y + 0.1 * (max_y - min_y),
      label = significance
    ),
    inherit.aes = FALSE,
    size = 4,
    color = "black"
  )

## mixed effect

library(lmerTest)

relAbuSpeInf <- infant_species %>%
  mutate(Timepoint = if_else(timepoint == "pn12", "1", "2")) %>%
  #ungroup() %>%
  select(species, Sample, Cluster, idbs, Timepoint, Abundance)

Inf_infantis <- relAbuSpeInf %>% filter(species == "Bifidobacterium infantis")
Inf_infantis_model <- lmer(Abundance ~ Timepoint * Cluster + (1 | idbs), data = Inf_infantis)
summary(Inf_infantis_model)
Anova(Inf_infantis_model, type = "III")
data.frame(
  Term = rownames(Anova(Inf_infantis_model, type = "III")),
  Raw_P = Anova(Inf_infantis_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(Inf_infantis_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

Inf2 <- relAbuSpeInf %>% filter(species == "Escherichia coli")
Inf2_model <- lmer(Abundance ~ Timepoint * Cluster + (1 | idbs), data = Inf2)
summary(Inf2_model)
Anova(Inf2_model, type = "III")
data.frame(
  Term = rownames(Anova(Inf2_model, type = "III")),
  Raw_P = Anova(Inf2_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(Inf2_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

Inf3 <- relAbuSpeInf %>% filter(species == "Veillonella_A sp000431435")
Inf3_model <- lmer(Abundance ~ Timepoint * Cluster + (1 | idbs), data = Inf3)
summary(Inf3_model)
Anova(Inf3_model, type = "III")
data.frame(
  Term = rownames(Anova(Inf3_model, type = "III")),
  Raw_P = Anova(Inf3_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(Inf3_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

Inf4 <- relAbuSpeInf %>% filter(species == "Parolsenella uli_B")
Inf4_model <- lmer(Abundance ~ Timepoint * Cluster + (1 | idbs), data = Inf4)
summary(Inf4_model)
Anova(Inf4_model, type = "III")
data.frame(
  Term = rownames(Anova(Inf4_model, type = "III")),
  Raw_P = Anova(Inf4_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(Inf4_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

Inf5 <- relAbuSpeInf %>% filter(species == "Bifidobacterium longum")
Inf5_model <- lmer(Abundance ~ Timepoint * Cluster + (1 | idbs), data = Inf5)
summary(Inf5_model)
Anova(Inf5_model, type = "III")
data.frame(
  Term = rownames(Anova(Inf5_model, type = "III")),
  Raw_P = Anova(Inf5_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(Inf5_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

Inf6 <- relAbuSpeInf %>% filter(species == "Klebsiella pneumoniae")
Inf6_model <- lmer(Abundance ~ Timepoint * Cluster + (1 | idbs), data = Inf6)
summary(Inf6_model)
Anova(Inf6_model, type = "III")
data.frame(
  Term = rownames(Anova(Inf6_model, type = "III")),
  Raw_P = Anova(Inf6_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(Inf6_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

Inf7 <- relAbuSpeInf %>% filter(species == "Bifidobacterium bifidum")
Inf7_model <- lmer(Abundance ~ Timepoint * Cluster + (1 | idbs), data = Inf7)
summary(Inf7_model)
Anova(Inf7_model, type = "III")
data.frame(
  Term = rownames(Anova(Inf7_model, type = "III")),
  Raw_P = Anova(Inf7_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(Inf7_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

Inf8 <- relAbuSpeInf %>% filter(species == "Bifidobacterium breve")
Inf8_model <- lmer(Abundance ~ Timepoint * Cluster + (1 | idbs), data = Inf8)
summary(Inf8_model)
Anova(Inf8_model, type = "III")
data.frame(
  Term = rownames(Anova(Inf8_model, type = "III")),
  Raw_P = Anova(Inf8_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(Inf8_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

Inf9 <- relAbuSpeInf %>% filter(species == "Unknown_Veillonella")
Inf9_model <- lmer(Abundance ~ Timepoint * Cluster + (1 | idbs), data = Inf9)
summary(Inf9_model)
Anova(Inf9_model, type = "III")
data.frame(
  Term = rownames(Anova(Inf9_model, type = "III")),
  Raw_P = Anova(Inf9_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(Inf9_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

Inf10 <- relAbuSpeInf %>% filter(species == "Streptococcus sp000187445")
Inf10_model <- lmer(Abundance ~ Timepoint * Cluster + (1 | idbs), data = Inf10)
summary(Inf10_model)
Anova(Inf10_model, type = "III")
data.frame(
  Term = rownames(Anova(Inf10_model, type = "III")),
  Raw_P = Anova(Inf10_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(Inf10_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

Inf11 <- relAbuSpeInf %>% filter(species == "Unknown_Rothia")
Inf11_model <- lmer(Abundance ~ Timepoint * Cluster + (1 | idbs), data = Inf11)
summary(Inf11_model)
Anova(Inf11_model, type = "III")
data.frame(
  Term = rownames(Anova(Inf11_model, type = "III")),
  Raw_P = Anova(Inf11_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(Inf11_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

Inf12 <- relAbuSpeInf %>% filter(species == "Streptococcus sp900543065")
Inf12_model <- lmer(Abundance ~ Timepoint * Cluster + (1 | idbs), data = Inf12)
summary(Inf12_model)
Anova(Inf12_model, type = "III")
data.frame(
  Term = rownames(Anova(Inf12_model, type = "III")),
  Raw_P = Anova(Inf12_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(Inf12_model, type = "III")$`Pr(>Chisq)`, method = "BH"))


```

# TAC

```{r}
library(officer)
# Step 1: Read the .doc file
doc <- read_docx("../Liste des cibles dans l'analyse TAC.docx")  # Replace with your file path
doc_text <- docx_summary(doc)$text  # Extract text content

# Step 2: Split the text into lines
doc_lines <- doc_text %>% str_split("\n") %>% unlist()

# Step 3: Convert to a data frame by splitting at `:`
doc_table <- doc_lines %>%
  as_tibble() %>%  # Convert to tibble
  filter(str_detect(value, ":")) %>%  # Keep only lines containing ':'
  separate(value, into = c("Target.Name", "FullName"), sep = ":", fill = "right", extra = "merge") %>%
  dplyr::mutate(across(everything(), str_trim))  %>%
  dplyr::mutate(
    FullName = str_replace_all(
      FullName,
      c(
        "Ent√©roagr√©gatif" = "Enteroaggregative",
        "Ent√©rotoxinog√®ne" = "Enterotoxigenic",
        "Escherichia coli" = "E.coli"
      )
    )
  )%>%
  dplyr::mutate(Target.Name = str_replace_all(Target.Name, " +", "_"),   # Replace spaces with underscores
                Target.Name = str_replace(Target.Name, "Adenovirus_40-41", "Adenovirus_40_41"))# Fix specific name
  

tac_raw <- read_excel("../TAC_Results_DenBalo/All_TAC_BioSpe_Results.xlsx")

tac <- tac_raw %>%
  filter(!Target.Name %in% c("16S", "CTX-M_1", "CTX-M_2", "ctx-M-1-2-9", "ctx-M-8-25", "ermB", "Hs99999901_s1", "KPC", "MCR1", "mphA", "MS2", "NDM", "OVA", "PhHV", "QnrA", "QnrB1", "QnrB4", "QnrS", "SHV", "TEM")) %>%
  filter(!is.na(idbs)) %>%
  dplyr::select(idbs, timepoint, dyads, Target.Name, Ct) %>%
  filter(Ct < 35) %>%
  left_join(metadata %>% dplyr::select(idbs, code), by = "idbs") %>%
  filter(code == "B Z" | code == "A Y") %>%
  left_join(row_annotation_idbs, by = "idbs") %>%
  left_join(doc_table, by = "Target.Name") %>%
  dplyr::mutate(FullName = ifelse(is.na(FullName), Target.Name, FullName)) %>%  # Replace NA in FullName with Target.Name
  dplyr::select(-Target.Name)  # Remove Target.Name if not needed


```

## Fig2B infant gut pn12

```{r}

tac_infant_wide <- tac %>%
  filter(dyads == "infant") %>%
  dplyr::select(-dyads, -code) %>%
  pivot_wider(
  names_from = FullName,   # Use Target.Name as the new column names
  values_from = Ct,           # Use Ct as the values for the new columns
  values_fill = "0"             # Fill missing values with 0
  ) %>%
  dplyr::mutate(across(
    -c(idbs, timepoint, Cluster),  # Exclude idbs and timepoint columns
    ~ ifelse(. != 0, 1, 0)  # Convert values: 1 if not 0, otherwise 0
  )) %>%
  filter(!is.na(Cluster)) 

tac_infant_wide_pn12 <- tac_infant_wide %>%
  filter(timepoint == "pn12") %>%
  dplyr::select(-timepoint)

# Step 1: Prepare the data for prevalence calculation
tac_infant_pn12_prevalence <- tac_infant_wide_pn12 %>%
  pivot_longer(
    cols = -c(idbs, Cluster),  # Columns to pivot into long format
    names_to = "Pathogen",               # New column for pathogen names
    values_to = "Presence"               # New column for presence/absence values
  ) %>%
  group_by(Cluster, Pathogen) %>%
  dplyr::summarise(
    Prevalence = mean(Presence, na.rm = TRUE) * 100,  # Calculate prevalence as %
    .groups = "drop"
  ) %>%
  group_by(Pathogen) %>%
  filter(any(Prevalence > 0))  # Keep rows where at least one cluster has non-zero prevalence

# Step 2: Calculate overall prevalence for ordering
pathogen_order <- tac_infant_pn12_prevalence %>%
  group_by(Pathogen) %>%
  dplyr::summarise(TotalPrevalence = sum(Prevalence, na.rm = TRUE)) %>%  # Sum prevalence across clusters
  arrange(desc(TotalPrevalence)) %>%  # Order by total prevalence descending
  pull(Pathogen)

# Step 5: Perform Chi-square test for each pathogen
p_values_data <- tac_infant_wide_pn12 %>%
  pivot_longer(
    cols = -c(idbs, Cluster),  # Columns to pivot into long format
    names_to = "Pathogen",     # New column for pathogen names
    values_to = "Presence"     # New column for presence/absence values
  ) %>%
  group_by(Pathogen) %>%
  dplyr::summarise(
    p_value = ifelse(
      any(table(Cluster, Presence) < 5),  # Check if any expected frequency < 5
      fisher.test(table(Cluster, Presence))$p.value,  # Use Fisher's exact test
      chisq.test(table(Cluster, Presence))$p.value    # Use Chi-square test
    ),
    .groups = "drop"
  ) %>%
  # Apply BH FDR correction to p-values
  mutate(adj_p_value = p.adjust(p_value, method = "BH")) %>%
  # Define significance based on adjusted p-values
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      adj_p_value > 0.1 & p_value <= 0.05 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )


# Merge p-values with prevalence data
tac_infant_pn12_prevalence <- tac_infant_pn12_prevalence %>%
  left_join(p_values_data, by = "Pathogen") %>%
  dplyr::mutate(Pathogen = factor(Pathogen, levels = pathogen_order))  %>%
  group_by(Pathogen) %>%
  dplyr::mutate(MaxPrevalence = max(Prevalence, na.rm = TRUE)) %>%
  ungroup()

# Step 6: Create the prevalence plot with significance annotations
tac_infant_pn12_prevalence_plot <- ggplot(tac_infant_pn12_prevalence, aes(x = Pathogen, y = Prevalence, fill = Cluster)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +  # Ensure dodge matches text placement
  scale_fill_manual(values = COLOR_SCHEME) +
  labs(
    x = "Pathogen: Pn12",
    y = "Prevalence (%)",
    fill = "Cluster"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, size = 8),
    legend.position = "right",
    panel.grid = element_blank()
  ) +
  geom_text(
    data = tac_infant_pn12_prevalence %>% 
      group_by(Pathogen) %>% 
      filter(row_number() == 1),  # Ensure only one label per pathogen
    aes(
      x = Pathogen,
      y = MaxPrevalence + 5,  # Place the label 5 units above the maximum bar
      label = significance
    ),
    inherit.aes = FALSE,
    color = "darkred",
    size = 4
  )

# Step 7: Display the plot
tac_infant_pn12_prevalence_plot


# svglite::svglite(
#   filename = "./forISRHML/tac_infant_pn12_prevalence_plot_Jan31.svg",
#   width = 6, height = 5
# )
# tac_infant_pn12_prevalence_plot
# dev.off()

```

## Fig3E mother gut tri3

```{r}

tac_mother_wide_tri3 <- tac %>%
  filter(dyads == "mom") %>%
  as.data.frame() %>%
  dplyr::select(-dyads, -code, -timepoint) %>%
  pivot_wider(
    names_from = FullName,   # Use FullName as the new column names
    values_from = Ct,        # Use Ct as the values for the new columns
    values_fn = list(Ct = ~ max(.x, na.rm = TRUE)),  # Resolve duplicates by taking the maximum
    values_fill = "0" 
  ) %>%
  dplyr::mutate(across(
    -c(idbs, Cluster),  # Exclude idbs, timepoint, and Cluster columns
    ~ ifelse(. != 0, 1, 0)         # Convert values: 1 if not 0, otherwise 0
  )) %>%
  filter(!is.na(Cluster))

# Step 1: Prepare the data for prevalence calculation
tac_mother_tri3_prevalence <- tac_mother_wide_tri3 %>%
  pivot_longer(
    cols = -c(idbs, Cluster),  # Columns to pivot into long format
    names_to = "Pathogen",               # New column for pathogen names
    values_to = "Presence"               # New column for presence/absence values
  ) %>%
  group_by(Cluster, Pathogen) %>%
  dplyr::summarise(
    Prevalence = mean(Presence, na.rm = TRUE) * 100,  # Calculate prevalence as %
    .groups = "drop"
  ) %>%
  group_by(Pathogen) %>%
  filter(any(Prevalence > 0))  # Keep rows where at least one cluster has non-zero prevalence


# Step 2: Calculate overall prevalence for ordering
pathogen_order <- tac_mother_tri3_prevalence %>%
  group_by(Pathogen) %>%
  dplyr::summarise(TotalPrevalence = sum(Prevalence, na.rm = TRUE)) %>%  # Sum prevalence across clusters
  arrange(desc(TotalPrevalence)) %>%  # Order by total prevalence descending
  pull(Pathogen)

# Step 5: Perform Chi-square test for each pathogen
p_values_data <- tac_mother_wide_tri3 %>%
  pivot_longer(
    cols = -c(idbs, Cluster),  # Columns to pivot into long format
    names_to = "Pathogen",     # New column for pathogen names
    values_to = "Presence"     # New column for presence/absence values
  ) %>%
  group_by(Pathogen) %>%
  dplyr::summarise(
    p_value = ifelse(
      any(table(Cluster, Presence) < 5),  # Check if any expected frequency < 5
      fisher.test(table(Cluster, Presence))$p.value,  # Use Fisher's exact test
      chisq.test(table(Cluster, Presence))$p.value    # Use Chi-square test
    ),
    .groups = "drop"
  ) %>%
  # Apply BH FDR correction to p-values
  mutate(adj_p_value = p.adjust(p_value, method = "BH")) %>%
  # Define significance based on adjusted p-values
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      adj_p_value > 0.1 & p_value <= 0.05 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )

# Merge p-values with prevalence data
tac_mother_tri3_prevalence <- tac_mother_tri3_prevalence %>%
  left_join(p_values_data, by = "Pathogen") %>%
  dplyr::mutate(Pathogen = factor(Pathogen, levels = pathogen_order))  %>%
  group_by(Pathogen) %>%
  dplyr::mutate(MaxPrevalence = max(Prevalence, na.rm = TRUE)) %>%
  ungroup()

# Step 6: Create the prevalence plot with significance annotations
tac_mother_tri3_prevalence_plot <- ggplot(tac_mother_tri3_prevalence, aes(x = Pathogen, y = Prevalence, fill = Cluster)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +  # Ensure dodge matches text placement
  scale_fill_manual(values = COLOR_SCHEME) +
  labs(
    x = "Pathogen: Mother - Tri3",
    y = "Prevalence (%)",
    fill = "Cluster"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, size = 8),
    legend.position = "right",
    panel.grid = element_blank()
  ) +
  geom_text(
    data = tac_mother_tri3_prevalence %>% 
      group_by(Pathogen) %>% 
      filter(row_number() == 1),  # Ensure only one label per pathogen
    aes(
      x = Pathogen,
      y = MaxPrevalence + 5,  # Place the label 5 units above the maximum bar
      label = significance
    ),
    inherit.aes = FALSE,
    color = "darkred",
    size = 4
  )

# Step 7: Display the plot
tac_mother_tri3_prevalence_plot

# svglite::svglite(
#   filename = "./forISRHML/tac_mother_tri3_prevalence_plot_feb03.svg",
#   width = 8, height = 5
# )
# tac_mother_tri3_prevalence_plot
# dev.off()

```

# SCFAs

```{r}

scfa_raw <- read_excel("../Copy of P1754_A_ResultsForClient.xlsx", skip = 1) %>%
  filter(!row_number() %in% c(241, 242, 243))

head(scfa_raw)

# Define LOQ value (example: 0.5 for demonstration)
LOQ_value <- 4
library(stringr)

# Ensure all relevant columns are processed
scfa_cleaned <- scfa_raw %>%
  dplyr::mutate(across(
    -c(`PD ID`, `Client ID`), # Apply across all columns
    ~ if (is.character(.x)) {
        .x %>%
          str_replace_all("<LOQ", as.character(LOQ_value / 2)) %>% # Replace <LOQ
          str_replace_all("ND", "0") %>% # Replace ND
          as.numeric() # Convert to numeric
      } else if (is.numeric(.x)) {
        .x # Leave numeric columns unchanged
      } else {
        as.numeric(.x) # Try converting other types to numeric
      }
  )) %>%
  separate(`Client ID`, into = c("timepoint", "sample", "idbs", "child"), sep = "_") %>%
  dplyr::mutate(child=if_else(is.na(child), "no", "yes")) %>%
  dplyr::mutate(timepoint = if_else(timepoint == "incl", "tri3", timepoint)) %>%
  dplyr::select(-`Sample n¬∞`, -`PD ID`, -sample) %>%
  left_join(row_annotation_idbs, by = "idbs")  # Perform the join


head(scfa_cleaned)

```

## Fig2G infant SCFAs line plot

```{r}

# Filter out 'tri3' and compute total SCFA
scfa_filtered <- scfa_cleaned %>%
  filter(timepoint != "tri3") %>%
  dplyr::mutate(Total_SCFA = rowSums(pick(
    Acetate, Propionate, Isobutyrate, Butyrate,
    Isovalerate, Valerate, Isocaproate, Caproate
  ), na.rm = TRUE))

# Reshape the data to long format for all SCFAs including Total_SCFA
scfa_long <- scfa_filtered %>%
  pivot_longer(
    cols = c(Acetate, Propionate, Isobutyrate, Butyrate,
             Isovalerate, Valerate, Isocaproate, Caproate, Total_SCFA),
    names_to = "SCFA",
    values_to = "Value"
  ) %>%
  filter(!is.na(Cluster))

# Summarize the SCFA data
scfa_summary <- scfa_long %>%
  group_by(timepoint, Cluster, SCFA) %>%
  dplyr::summarise(
    mean_value = mean(Value, na.rm = TRUE),
    se_value = sd(Value, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  group_by(SCFA) %>%
  mutate(max_value = max(mean_value, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(SCFA = fct_reorder(SCFA, max_value, .desc = TRUE))

# Compute p-values for each SCFA and timepoint
p_values_data <- scfa_long %>%
  group_by(SCFA, timepoint) %>%
  dplyr::summarise(
    p_value = anova(lm(Value ~ Cluster, data = cur_data()))$`Pr(>F)`[1],
    max_y = max(scfa_summary$mean_value[scfa_summary$SCFA == unique(SCFA) &
                                        scfa_summary$timepoint == unique(timepoint)], na.rm = TRUE),
    min_y = min(scfa_summary$mean_value[scfa_summary$SCFA == SCFA], na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(adj_p_value = p.adjust(p_value, method = "BH")) %>%
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",
      adj_p_value <= 0.01 ~ "**",
      adj_p_value <= 0.05 ~ "*",
      adj_p_value <= 0.1 ~ ".",
      adj_p_value > 0.1 & p_value <= 0.05 ~ "~",
      TRUE ~ ""
    )
  )

# Plot with all SCFAs including total
scfa_plot <- ggplot(scfa_summary, aes(x = timepoint, y = mean_value, color = Cluster, group = Cluster)) +
  geom_line() +
  geom_point() +
  geom_errorbar(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), width = 0.2) +
  facet_wrap(~ SCFA, scales = "free_y", ncol = 9) +
  scale_color_manual(values = COLOR_SCHEME) +
  labs(
    x = "Timepoint",
    y = "SCFA Levels (¬µmol/L)",
    color = "Cluster"
  ) +
  theme_bw() +
  theme(
    legend.position = "right",
    strip.text = element_text(size = 10)
  ) +
  geom_text(
    data = p_values_data %>%
      mutate(SCFA = factor(SCFA, levels = levels(scfa_summary$SCFA))),
    aes(
      x = as.numeric(as.factor(timepoint)),
      y = max_y + 0.4 * (max_y - min_y),
      label = significance
    ),
    inherit.aes = FALSE,
    size = 5,
    color = "black"
  )

# Show plot
scfa_plot

# svglite::svglite(
#   filename = "./forISRHML/scfa_infant_plot_jul17.svg",
#   width = 15, height = 2
# )
# scfa_plot
# dev.off()

### linear mixed effect
scfaLongChild <- scfa_long %>%
  mutate(Timepoint = if_else(timepoint == "pn12", "1", "2")) %>%
  select(-child)

scfaAcetate <- scfaLongChild %>% filter(SCFA == "Acetate")
scfaAcetate_model <- lmer(Value ~ timepoint * Cluster + (1 | idbs), data = scfaAcetate)
Anova(scfaAcetate_model, type = "III")
data.frame(
  Term = rownames(Anova(scfaAcetate_model, type = "III")),
  Raw_P = Anova(scfaAcetate_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(scfaAcetate_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

scfaPropionate <- scfaLongChild %>% filter(SCFA == "Propionate")
scfaPropionate_model <- lmer(Value ~ timepoint * Cluster + (1 | idbs), data = scfaPropionate)
Anova(scfaPropionate_model, type = "III")
data.frame(
  Term = rownames(Anova(scfaPropionate_model, type = "III")),
  Raw_P = Anova(scfaPropionate_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(scfaPropionate_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

scfaButyrate <- scfaLongChild %>% filter(SCFA == "Butyrate")
scfaButyrate_model <- lmer(Value ~ timepoint * Cluster + (1 | idbs), data = scfaButyrate)
Anova(scfaButyrate_model, type = "III")
data.frame(
  Term = rownames(Anova(scfaButyrate_model, type = "III")),
  Raw_P = Anova(scfaButyrate_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(scfaButyrate_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

scfaIsobutyrate <- scfaLongChild %>% filter(SCFA == "Isobutyrate")
scfaIsobutyrate_model <- lmer(Value ~ timepoint * Cluster + (1 | idbs), data = scfaIsobutyrate)
Anova(scfaIsobutyrate_model, type = "III")
data.frame(
  Term = rownames(Anova(scfaIsobutyrate_model, type = "III")),
  Raw_P = Anova(scfaIsobutyrate_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(scfaIsobutyrate_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

scfaCaproate <- scfaLongChild %>% filter(SCFA == "Caproate")
scfaCaproate_model <- lmer(Value ~ timepoint * Cluster + (1 | idbs), data = scfaCaproate)
Anova(scfaCaproate_model, type = "III")
data.frame(
  Term = rownames(Anova(scfaCaproate_model, type = "III")),
  Raw_P = Anova(scfaCaproate_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(scfaCaproate_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

scfaIsocaproate <- scfaLongChild %>% filter(SCFA == "Isocaproate")
scfaIsocaproate_model <- lmer(Value ~ timepoint * Cluster + (1 | idbs), data = scfaIsocaproate)
Anova(scfaIsocaproate_model, type = "III")
data.frame(
  Term = rownames(Anova(scfaIsocaproate_model, type = "III")),
  Raw_P = Anova(scfaIsocaproate_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(scfaIsocaproate_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

scfaValerate <- scfaLongChild %>% filter(SCFA == "Valerate")
scfaValerate_model <- lmer(Value ~ timepoint * Cluster + (1 | idbs), data = scfaValerate)
Anova(scfaValerate_model, type = "III")
data.frame(
  Term = rownames(Anova(scfaValerate_model, type = "III")),
  Raw_P = Anova(scfaValerate_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(scfaValerate_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

scfaIsovalerate <- scfaLongChild %>% filter(SCFA == "Isovalerate")
scfaIsovalerate_model <- lmer(Value ~ timepoint * Cluster + (1 | idbs), data = scfaIsovalerate)
Anova(scfaIsovalerate_model, type = "III")
data.frame(
  Term = rownames(Anova(scfaIsovalerate_model, type = "III")),
  Raw_P = Anova(scfaIsovalerate_model, type = "III")$`Pr(>Chisq)`,
  FDR_P = p.adjust(Anova(scfaIsovalerate_model, type = "III")$`Pr(>Chisq)`, method = "BH"))

```

## Fig3F mother SCFAs tri3 box plot

```{r}

scfa_filtered <- scfa_cleaned %>%
  filter(timepoint == "tri3")

# Reshape the filtered data to long format for plotting
scfa_long <- scfa_filtered %>%
  pivot_longer(
    cols = c(Acetate, Propionate, Isobutyrate, Butyrate, Isovalerate, Valerate, Isocaproate, Caproate),
    names_to = "SCFA",
    values_to = "Value"
  ) %>%
  filter(!is.na(Cluster))


# Step 1: Perform pairwise comparisons for each SCFA
pairwise_results <- scfa_long %>%
  group_by(SCFA) %>%
  dplyr::summarise(
    comparisons = list(
      emmeans::emmeans(
        lme(fixed = Value ~ Cluster, random = ~1 | idbs, data = cur_data(), method = "REML"),
        pairwise ~ Cluster
      )$contrasts %>%
        as.data.frame()
    ),
    .groups = "drop"
  )

# Step 2: Extract pairwise comparisons and prepare data for significance lines
significance_annotations <- pairwise_results %>%
  tidyr::unnest(comparisons) %>%
  dplyr::mutate(
    # Adjust p-values using BH FDR correction
    adj_p_value = p.adjust(p.value, method = "BH"),
    
    # Define significance based on adjusted p-values
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      adj_p_value > 0.1 & p.value <= 0.05 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    ),
    
    # Extract groups for plotting
    group1 = str_extract(contrast, "^C\\d"),  # First cluster (e.g., "C1")
    group2 = str_extract(contrast, "C\\d$"),  # Second cluster (e.g., "C2"),
    
    # Dynamically set y_position for the significance lines
    y_position = ave(rep(1, n()), SCFA, FUN = seq_along) * 0.05 + 
      max(scfa_long$Value[scfa_long$SCFA == unique(SCFA)], na.rm = TRUE)
  ) %>%
  filter(significance != "")  # Remove non-significant comparisons

# Step 3: Plot the SCFA data with significance annotations
scfa_plot <- ggplot(scfa_long, aes(x = Cluster, y = Value, fill = Cluster)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  geom_jitter(aes(color = Cluster), size = 1, width = 0.2, alpha = 0.7) +
  facet_wrap(~ SCFA, scales = "free_y", ncol = 8) +
  scale_fill_manual(values = color_values) +
  scale_color_manual(values = color_values) +
  labs(
    title = "SCFA Levels by Cluster (Timepoint: Tri3)",
    x = "Cluster",
    y = "Value (¬µmol/L)"
  ) +
  theme_bw() +
  theme(
    legend.position = "none",
    strip.text = element_text(size = 10, face = "bold"),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    panel.grid = element_blank()
  ) +
  geom_segment(
    data = significance_annotations,
    aes(
      x = as.numeric(factor(group1, levels = unique(scfa_long$Cluster))),
      xend = as.numeric(factor(group2, levels = unique(scfa_long$Cluster))),
      y = y_position,
      yend = y_position
    ),
    inherit.aes = FALSE,
    color = "darkred",
    size = 0.5
  ) +
  geom_text(
    data = significance_annotations,
    aes(
      x = (as.numeric(factor(group1, levels = unique(scfa_long$Cluster))) +
           as.numeric(factor(group2, levels = unique(scfa_long$Cluster)))) / 2,
      y = y_position + 0.01,  # Slightly above the line
      label = significance
    ),
    inherit.aes = FALSE,
    size = 4,
    color = "darkred"
  )

# Step 4: Display the plot
print(scfa_plot)


# svglite::svglite(
#   filename = "./forISRHML/scfa_plot_feb03.svg",
#   width = 12, height = 2.5
# )
# scfa_plot
# dev.off()

```

# Heatmaps

## Fig3G infant gut & mother gut

```{r message=FALSE}

dyads_species <- ps_meta %>%
  tax_glom(taxrank = "species") %>%
  transform_sample_counts(function(x){x/sum(x)}) %>%
  psmelt() %>%
  filter(Abundance > 0)

# Filter shared species present at both time points
shared_species <- dyads_species %>%
  filter(timepoint == "tri3" | (timepoint == "pn12" & child == "no")) %>%
  group_by(species, timepoint) %>%
  filter(n() >= 20) %>%  # Ensure at least 20 IDs at each timepoint
  ungroup() %>%
  group_by(species) %>%
  filter(n_distinct(timepoint) == 2) %>%  # Ensure species are present at both timepoints
  ungroup()

# Calculate average abundance for shared species
top_shared_species <- shared_species %>%
  group_by(species) %>%
  dplyr::summarise(avg_abundance = mean(Abundance, na.rm = TRUE)) %>%
  arrange(desc(avg_abundance)) %>%  # Sort by descending average abundance
  slice_head(n = 10) %>%  # Select the top 10 species
  pull(species)  # Extract species names

# Filter the dataset for the top 10 shared species
filtered_shared_species <- shared_species %>%
  filter(species %in% top_shared_species)

# Construct the wide-format data
genera_infantgut_mothergut_wide <- filtered_shared_species %>%
  mutate(timepoint_species = paste(timepoint, species, sep = "_")) %>%  # Combine timepoint and species
  select(idbs, timepoint_species, Abundance) %>%                       # Select relevant columns
  pivot_wider(names_from = timepoint_species, values_from = Abundance) # Pivot to wider format

# Replace NA values with 0
genera_infantgut_mothergut_wide[is.na(genera_infantgut_mothergut_wide)] <- 0

# Filter relevant columns for correlation
corr_data <- genera_infantgut_mothergut_wide %>%
  dplyr::select(starts_with("pn12_"), starts_with("tri3_"), -idbs)

# Extract and align species names
pn12_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "pn12_")]
tri3_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "tri3_")]

species_pn12 <- gsub("^pn12_", "", pn12_vars)  # Remove 'pn12_' prefix
species_tri3 <- gsub("^tri3_", "", tri3_vars)  # Remove 'tri3_' prefix

# Ensure alignment and limit to top 10 species
aligned_species <- intersect(species_pn12, species_tri3)  # Find shared species
aligned_species <- aligned_species[aligned_species %in% top_shared_species]  # Restrict to top 10 species
pn12_vars <- paste0("pn12_", aligned_species)  # Recreate pn12 variable names
tri3_vars <- paste0("tri3_", aligned_species)  # Recreate tri3 variable names

# Compute correlation matrix
cor_mat <- cor(
  corr_data[, pn12_vars, drop = FALSE],
  corr_data[, tri3_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Compute p-values for correlations
cor_test <- psych::corr.test(
  corr_data[, pn12_vars, drop = FALSE],
  corr_data[, tri3_vars, drop = FALSE],
  method = "spearman"
)
cor_test_mat <- cor_test$p.adj  # Extract p-values

# Plot heatmap of correlations
plot_corr <- {
  corrplot::corrplot(
    cor_mat,
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,  # Remove correlation coefficients
    p.mat = cor_test_mat,  # Add p-values for significance testing
    sig.level = c(0.001, 0.01, 0.05),  # Define significance levels
    insig = "label_sig",  # Show stars for significant correlations
    pch.cex = 1,  # Adjust size of significance stars
    pch.col = "black",  # Color for significance stars
    tl.cex = 0.7,  # Adjust text size of variable labels
    tl.col = "black",  # Label color
    title = "Correlation Heatmap (Top 10 pn12_ vs. tri3_)",
    mar = c(0, 0, 1, 0)  # Adjust margins for better spacing
  )
  recordPlot()
}

#svglite::svglite(
#  filename="./forISRHML/heatmap_tri3_pn12.svg",
#  width=5, height=5
#  )
#plot_corr
#dev.off()


## infant pn12 & mother pn12

# Filter shared species present at both time points
shared_species <- dyads_species %>%
  filter(timepoint == "pn12") %>%
  group_by(species, child) %>%
  filter(n() >= 10) %>%  # Ensure at least 20 IDs at each timepoint
  ungroup() %>%
  group_by(species) %>%
  filter(n_distinct(child) == 2) %>%  # Ensure species are present at both timepoints
  ungroup()

# Calculate average abundance for shared species
top_shared_species <- shared_species %>%
  group_by(species) %>%
  dplyr::summarise(avg_abundance = mean(Abundance, na.rm = TRUE)) %>%
  arrange(desc(avg_abundance)) %>%  # Sort by descending average abundance
  slice_head(n = 10) %>%  # Select the top 10 species
  pull(species)  # Extract species names

# Filter the dataset for the top 10 shared species
filtered_shared_species <- shared_species %>%
  filter(species %in% top_shared_species)

# Construct the wide-format data
genera_infantgut_mothergut_wide <- filtered_shared_species %>%
  mutate(timepoint_species = paste(child, species, sep = "_")) %>%  # Combine timepoint and species
  select(idbs, timepoint_species, Abundance) %>%                       # Select relevant columns
  pivot_wider(names_from = timepoint_species, values_from = Abundance) # Pivot to wider format

# Replace NA values with 0
genera_infantgut_mothergut_wide[is.na(genera_infantgut_mothergut_wide)] <- 0

# Filter relevant columns for correlation
corr_data <- genera_infantgut_mothergut_wide %>%
  dplyr::select(starts_with("yes_"), starts_with("no_"), -idbs)

# Extract and align species names
inf_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "yes_")]
mat_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "no_")]

species_inf <- gsub("^yes_", "", inf_vars)  # Remove 'pn12_' prefix
species_mat <- gsub("^no_", "", mat_vars)  # Remove 'tri3_' prefix

# Ensure alignment and limit to top 10 species
aligned_species <- intersect(species_inf, species_mat)  # Find shared species
aligned_species <- aligned_species[aligned_species %in% top_shared_species]  # Restrict to top 10 species
inf_vars <- paste0("yes_", aligned_species)  # Recreate pn12 variable names
mat_vars <- paste0("no_", aligned_species)  # Recreate tri3 variable names

# Compute correlation matrix
cor_mat <- cor(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Compute p-values for correlations
cor_test <- psych::corr.test(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  method = "spearman"
)
cor_test_mat <- cor_test$p.adj  # Extract p-values

# Plot heatmap of correlations
plot_corr <- {
  corrplot::corrplot(
    cor_mat,
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,  # Remove correlation coefficients
    p.mat = cor_test_mat,  # Add p-values for significance testing
    sig.level = c(0.001, 0.01, 0.05),  # Define significance levels
    insig = "label_sig",  # Show stars for significant correlations
    pch.cex = 1,  # Adjust size of significance stars
    pch.col = "black",  # Color for significance stars
    tl.cex = 0.7,  # Adjust text size of variable labels
    tl.col = "black",  # Label color
    title = "Correlation Heatmap (Top 10 pn12e_ vs. pn12m_)",
    mar = c(0, 0, 1, 0)  # Adjust margins for better spacing
  )
  recordPlot()
}

# svglite::svglite(
#   filename="./forISRHML/heatmap_pn12_pn12.svg",
#   width=5, height=5
#   )
# plot_corr
# dev.off()



## infant pn12 & mother pn56

# Filter shared species present at both time points
shared_species <- dyads_species %>%
  filter((timepoint == "pn12" & child == "yes") | (timepoint == "pn56" & child == "no")) %>%
  group_by(species, child) %>%
  filter(n() >= 10) %>%  # Ensure at least 20 IDs at each timepoint
  ungroup() %>%
  group_by(species) %>%
  filter(n_distinct(child) == 2) %>%  # Ensure species are present at both timepoints
  ungroup()

# Calculate average abundance for shared species
top_shared_species <- shared_species %>%
  group_by(species) %>%
  dplyr::summarise(avg_abundance = mean(Abundance, na.rm = TRUE)) %>%
  arrange(desc(avg_abundance)) %>%  # Sort by descending average abundance
  slice_head(n = 10) %>%  # Select the top 10 species
  pull(species)  # Extract species names

# Filter the dataset for the top 10 shared species
filtered_shared_species <- shared_species %>%
  filter(species %in% top_shared_species)

# Construct the wide-format data
genera_infantgut_mothergut_wide <- filtered_shared_species %>%
  mutate(timepoint_species = paste(timepoint, species, sep = "_")) %>%  # Combine timepoint and species
  select(idbs, timepoint_species, Abundance) %>%                       # Select relevant columns
  pivot_wider(names_from = timepoint_species, values_from = Abundance) # Pivot to wider format

# Replace NA values with 0
genera_infantgut_mothergut_wide[is.na(genera_infantgut_mothergut_wide)] <- 0

# Filter relevant columns for correlation
corr_data <- genera_infantgut_mothergut_wide %>%
  dplyr::select(starts_with("pn12_"), starts_with("pn56_"), -idbs)

# Extract and align species names
inf_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "pn12_")]
mat_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "pn56_")]

species_inf <- gsub("^pn12_", "", inf_vars)  # Remove 'pn12_' prefix
species_mat <- gsub("^pn56_", "", mat_vars)  # Remove 'tri3_' prefix

# Ensure alignment and limit to top 10 species
aligned_species <- intersect(species_inf, species_mat)  # Find shared species
aligned_species <- aligned_species[aligned_species %in% top_shared_species]  # Restrict to top 10 species
inf_vars <- paste0("pn12_", aligned_species)  # Recreate pn12 variable names
mat_vars <- paste0("pn56_", aligned_species)  # Recreate tri3 variable names

# Compute correlation matrix
cor_mat <- cor(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Compute p-values for correlations
cor_test <- psych::corr.test(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  method = "spearman"
)
cor_test_mat <- cor_test$p.adj  # Extract p-values

# Plot heatmap of correlations
plot_corr <- {
  corrplot::corrplot(
    cor_mat,
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,  # Remove correlation coefficients
    p.mat = cor_test_mat,  # Add p-values for significance testing
    sig.level = c(0.001, 0.01, 0.05),  # Define significance levels
    insig = "label_sig",  # Show stars for significant correlations
    pch.cex = 1,  # Adjust size of significance stars
    pch.col = "black",  # Color for significance stars
    tl.cex = 0.7,  # Adjust text size of variable labels
    tl.col = "black",  # Label color
    title = "Correlation Heatmap (Top 10 pn12e_ vs. pn56m_)",
    mar = c(0, 0, 1, 0)  # Adjust margins for better spacing
  )
  recordPlot()
}

# svglite::svglite(
#   filename="./forISRHML/heatmap_pn12e_pn56m.svg",
#   width=5, height=5
#   )
# plot_corr
# dev.off()



## infant pn56 & pregnancy tri3

# Filter shared species present at both time points
shared_species <- dyads_species %>%
  filter(timepoint == "tri3" | (timepoint == "pn56" & child == "no")) %>%
  group_by(species, timepoint) %>%
  filter(n() >= 20) %>%  # Ensure at least 20 IDs at each timepoint
  ungroup() %>%
  group_by(species) %>%
  filter(n_distinct(timepoint) == 2) %>%  # Ensure species are present at both timepoints
  ungroup()

# Calculate average abundance for shared species
top_shared_species <- shared_species %>%
  group_by(species) %>%
  dplyr::summarise(avg_abundance = mean(Abundance, na.rm = TRUE)) %>%
  arrange(desc(avg_abundance)) %>%  # Sort by descending average abundance
  slice_head(n = 10) %>%  # Select the top 10 species
  pull(species)  # Extract species names

# Filter the dataset for the top 10 shared species
filtered_shared_species <- shared_species %>%
  filter(species %in% top_shared_species)

# Construct the wide-format data
genera_infantgut_mothergut_wide <- filtered_shared_species %>%
  mutate(timepoint_species = paste(timepoint, species, sep = "_")) %>%  # Combine timepoint and species
  select(idbs, timepoint_species, Abundance) %>%                       # Select relevant columns
  pivot_wider(names_from = timepoint_species, values_from = Abundance) # Pivot to wider format

# Replace NA values with 0
genera_infantgut_mothergut_wide[is.na(genera_infantgut_mothergut_wide)] <- 0

# Filter relevant columns for correlation
corr_data <- genera_infantgut_mothergut_wide %>%
  dplyr::select(starts_with("pn56_"), starts_with("tri3_"), -idbs)

# Extract and align species names
pn56_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "pn56_")]
tri3_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "tri3_")]

species_pn56 <- gsub("^pn56_", "", pn56_vars)  # Remove 'pn56_' prefix
species_tri3 <- gsub("^tri3_", "", tri3_vars)  # Remove 'tri3_' prefix

# Ensure alignment and limit to top 10 species
aligned_species <- intersect(species_pn56, species_tri3)  # Find shared species
aligned_species <- aligned_species[aligned_species %in% top_shared_species]  # Restrict to top 10 species
pn56_vars <- paste0("pn56_", aligned_species)  # Recreate pn56 variable names
tri3_vars <- paste0("tri3_", aligned_species)  # Recreate tri3 variable names

# Compute correlation matrix
cor_mat <- cor(
  corr_data[, pn56_vars, drop = FALSE],
  corr_data[, tri3_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Compute p-values for correlations
cor_test <- psych::corr.test(
  corr_data[, pn56_vars, drop = FALSE],
  corr_data[, tri3_vars, drop = FALSE],
  method = "spearman"
)
cor_test_mat <- cor_test$p.adj  # Extract p-values

# Plot heatmap of correlations
plot_corr <- {
  corrplot::corrplot(
    cor_mat,
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,  # Remove correlation coefficients
    p.mat = cor_test_mat,  # Add p-values for significance testing
    sig.level = c(0.001, 0.01, 0.05),  # Define significance levels
    insig = "label_sig",  # Show stars for significant correlations
    pch.cex = 1,  # Adjust size of significance stars
    pch.col = "black",  # Color for significance stars
    tl.cex = 0.7,  # Adjust text size of variable labels
    tl.col = "black",  # Label color
    title = "Correlation Heatmap (Top 10 pn56_ vs. tri3_)",
    mar = c(0, 0, 1, 0)  # Adjust margins for better spacing
  )
  recordPlot()
}

# svglite::svglite(
#   filename="./forISRHML/heatmap_tri3_pn56.svg",
#   width=5, height=5
#   )
# plot_corr
# dev.off()



## infant pn56 & mother pn12

# Filter shared species present at both time points
shared_species <- dyads_species %>%
  filter((timepoint == "pn56" & child == "yes") | (timepoint == "pn12" & child == "no")) %>%
  group_by(species, child) %>%
  filter(n() >= 10) %>%  # Ensure at least 20 IDs at each timepoint
  ungroup() %>%
  group_by(species) %>%
  filter(n_distinct(child) == 2) %>%  # Ensure species are present at both timepoints
  ungroup()

# Calculate average abundance for shared species
top_shared_species <- shared_species %>%
  group_by(species) %>%
  dplyr::summarise(avg_abundance = mean(Abundance, na.rm = TRUE)) %>%
  arrange(desc(avg_abundance)) %>%  # Sort by descending average abundance
  slice_head(n = 10) %>%  # Select the top 10 species
  pull(species)  # Extract species names

# Filter the dataset for the top 10 shared species
filtered_shared_species <- shared_species %>%
  filter(species %in% top_shared_species)

# Construct the wide-format data
genera_infantgut_mothergut_wide <- filtered_shared_species %>%
  mutate(timepoint_species = paste(timepoint, species, sep = "_")) %>%  # Combine timepoint and species
  select(idbs, timepoint_species, Abundance) %>%                       # Select relevant columns
  pivot_wider(names_from = timepoint_species, values_from = Abundance) # Pivot to wider format

# Replace NA values with 0
genera_infantgut_mothergut_wide[is.na(genera_infantgut_mothergut_wide)] <- 0

# Filter relevant columns for correlation
corr_data <- genera_infantgut_mothergut_wide %>%
  dplyr::select(starts_with("pn56_"), starts_with("pn12_"), -idbs)

# Extract and align species names
inf_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "pn56_")]
mat_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "pn12_")]

species_inf <- gsub("^pn56_", "", inf_vars)  
species_mat <- gsub("^pn12_", "", mat_vars)  

# Ensure alignment and limit to top 10 species
aligned_species <- intersect(species_inf, species_mat)  # Find shared species
aligned_species <- aligned_species[aligned_species %in% top_shared_species]  # Restrict to top 10 species
inf_vars <- paste0("pn56_", aligned_species)  
mat_vars <- paste0("pn12_", aligned_species)  

# Compute correlation matrix
cor_mat <- cor(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Compute p-values for correlations
cor_test <- psych::corr.test(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  method = "spearman"
)
cor_test_mat <- cor_test$p.adj  # Extract p-values

# Plot heatmap of correlations
plot_corr <- {
  corrplot::corrplot(
    cor_mat,
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,  # Remove correlation coefficients
    p.mat = cor_test_mat,  # Add p-values for significance testing
    sig.level = c(0.001, 0.01, 0.05),  # Define significance levels
    insig = "label_sig",  # Show stars for significant correlations
    pch.cex = 1,  # Adjust size of significance stars
    pch.col = "black",  # Color for significance stars
    tl.cex = 0.7,  # Adjust text size of variable labels
    tl.col = "black",  # Label color
    title = "Correlation Heatmap (Top 10 pn56e_ vs. pn12m_)",
    mar = c(0, 0, 1, 0)  # Adjust margins for better spacing
  )
  recordPlot()
}

#svglite::svglite(
#  filename="./forISRHML/heatmap_pn56e_pn12m.svg",
#  width=5, height=5
#  )
#plot_corr
#dev.off()



## infant pn56 & mother pn56

# Filter shared species present at both time points
shared_species <- dyads_species %>%
  filter(timepoint == "pn56") %>%
  group_by(species, child) %>%
  filter(n() >= 10) %>%  # Ensure at least 20 IDs at each timepoint
  ungroup() %>%
  group_by(species) %>%
  filter(n_distinct(child) == 2) %>%  # Ensure species are present at both timepoints
  ungroup()

# Calculate average abundance for shared species
top_shared_species <- shared_species %>%
  group_by(species) %>%
  dplyr::summarise(avg_abundance = mean(Abundance, na.rm = TRUE)) %>%
  arrange(desc(avg_abundance)) %>%  # Sort by descending average abundance
  slice_head(n = 10) %>%  # Select the top 10 species
  pull(species)  # Extract species names

# Filter the dataset for the top 10 shared species
filtered_shared_species <- shared_species %>%
  filter(species %in% top_shared_species)

# Construct the wide-format data
genera_infantgut_mothergut_wide <- filtered_shared_species %>%
  mutate(timepoint_species = paste(child, species, sep = "_")) %>%  # Combine timepoint and species
  select(idbs, timepoint_species, Abundance) %>%                       # Select relevant columns
  pivot_wider(names_from = timepoint_species, values_from = Abundance) # Pivot to wider format

# Replace NA values with 0
genera_infantgut_mothergut_wide[is.na(genera_infantgut_mothergut_wide)] <- 0

# Filter relevant columns for correlation
corr_data <- genera_infantgut_mothergut_wide %>%
  dplyr::select(starts_with("yes_"), starts_with("no_"), -idbs)

# Extract and align species names
inf_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "yes_")]
mat_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "no_")]

species_inf <- gsub("^yes_", "", inf_vars) 
species_mat <- gsub("^no_", "", mat_vars)  

# Ensure alignment and limit to top 10 species
aligned_species <- intersect(species_inf, species_mat)  # Find shared species
aligned_species <- aligned_species[aligned_species %in% top_shared_species]  # Restrict to top 10 species
inf_vars <- paste0("yes_", aligned_species)  
mat_vars <- paste0("no_", aligned_species)  

# Compute correlation matrix
cor_mat <- cor(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Compute p-values for correlations
cor_test <- psych::corr.test(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  method = "spearman"
)
cor_test_mat <- cor_test$p.adj  # Extract p-values

# Plot heatmap of correlations
plot_corr <- {
  corrplot::corrplot(
    cor_mat,
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,  # Remove correlation coefficients
    p.mat = cor_test_mat,  # Add p-values for significance testing
    sig.level = c(0.001, 0.01, 0.05),  # Define significance levels
    insig = "label_sig",  # Show stars for significant correlations
    pch.cex = 1,  # Adjust size of significance stars
    pch.col = "black",  # Color for significance stars
    tl.cex = 0.7,  # Adjust text size of variable labels
    tl.col = "black",  # Label color
    title = "Correlation Heatmap (Top 10 pn56e_ vs. pn56m_)",
    mar = c(0, 0, 1, 0)  # Adjust margins for better spacing
  )
  recordPlot()
}

#svglite::svglite(
#  filename="./forISRHML/heatmap_pn56_pn56.svg",
#  width=5, height=5
#  )
#plot_corr
#dev.off()


```

## Fig4D infant gut & milk

```{r}

infant_pn12_genus <- infant_genus %>%
  filter(timepoint=="Pn12") %>%
  mutate(timepoint="Pn12e") %>%
  select(genus, Abundance, idbs, timepoint)

milk_1421_genus <- milk_genus %>%
  filter(timepoint=="1421") %>%
  mutate(timepoint="1421h") %>%
  select(genus, Abundance, idbs, timepoint)

infant12_milk1421_genus <- rbind(infant_pn12_genus, milk_1421_genus)

# Filter shared species present at both time points
shared_infant12_milk1421_genus <- infant12_milk1421_genus %>%
  group_by(genus, timepoint) %>%
  filter(n() >= 5) %>%  # Ensure at least 20 IDs at each timepoint
  ungroup() %>%
  group_by(genus) %>%
  filter(n_distinct(timepoint) == 2) %>%  # Ensure species are present at both timepoints
  ungroup()

# Calculate average abundance for shared species
top_shared_genus <- shared_infant12_milk1421_genus %>%
  group_by(genus) %>%
  dplyr::summarise(avg_abundance = mean(Abundance, na.rm = TRUE)) %>%
  arrange(desc(avg_abundance)) %>%  # Sort by descending average abundance
  slice_head(n = 10) %>%  # Select the top 10 species
  pull(genus)  # Extract species names

# Filter the dataset for the top 10 shared species
filtered_shared_genus <- shared_infant12_milk1421_genus %>%
  filter(genus %in% top_shared_genus)

# Construct the wide-format data
genera_infantgut_milk_wide <- filtered_shared_genus %>%
  mutate(timepoint_genus = paste(timepoint, genus, sep = "_")) %>%  # Combine timepoint and species
  select(idbs, timepoint_genus, Abundance) %>%                       # Select relevant columns
  pivot_wider(names_from = timepoint_genus, values_from = Abundance) # Pivot to wider format

# Replace NA values with 0
genera_infantgut_milk_wide[is.na(genera_infantgut_milk_wide)] <- 0
colnames(genera_infantgut_milk_wide)

# Filter relevant columns for correlation
corr_data <- genera_infantgut_milk_wide %>%
  dplyr::select(starts_with("Pn12e_"), starts_with("1421h_"), -idbs)

# Extract and align species names
inf_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "Pn12e_")]
mat_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "1421h_")]

genus_inf <- gsub("^Pn12e_", "", inf_vars) 
genus_mat <- gsub("^1421h_", "", mat_vars)  

# Ensure alignment and limit to top 10 species
aligned_genus <- intersect(genus_inf, genus_mat)  # Find shared species
aligned_genus <- aligned_genus[aligned_genus %in% top_shared_genus]  # Restrict to top 10 species
inf_vars <- paste0("Pn12e_", aligned_genus)  
mat_vars <- paste0("1421h_", aligned_genus)  

# Compute correlation matrix
cor_mat <- cor(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Compute p-values for correlations
cor_test <- psych::corr.test(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  method = "spearman"
)
cor_test_mat <- cor_test$p.adj  # Extract p-values

# Plot heatmap of correlations
plot_corr <- {
  corrplot::corrplot(
    cor_mat,
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,  # Remove correlation coefficients
    p.mat = cor_test_mat,  # Add p-values for significance testing
    sig.level = c(0.001, 0.01, 0.05),  # Define significance levels
    insig = "label_sig",  # Show stars for significant correlations
    pch.cex = 1,  # Adjust size of significance stars
    pch.col = "black",  # Color for significance stars
    tl.cex = 0.7,  # Adjust text size of variable labels
    tl.col = "black",  # Label color
    title = "Correlation Heatmap (Top 10 pn12 vs. 1421)",
    mar = c(0, 0, 1, 0)  # Adjust margins for better spacing
  )
  recordPlot()
}

#svglite::svglite(
#  filename="./forISRHML/heatmap_pn12e_1421h.svg",
#  width=5, height=5
#  )
#plot_corr
#dev.off()


## infant pn12e & milk Pn12h


infant_pn12_genus <- infant_genus %>%
  filter(timepoint=="Pn12") %>%
  mutate(timepoint="Pn12e") %>%
  select(genus, Abundance, idbs, timepoint)

milk_Pn12_genus <- milk_genus %>%
  filter(timepoint=="Pn12") %>%
  mutate(timepoint="Pn12h") %>%
  select(genus, Abundance, idbs, timepoint)

infant12_milkPn12_genus <- rbind(infant_pn12_genus, milk_Pn12_genus)

# Filter shared species present at both time points
shared_infant12_milkPn12_genus <- infant12_milkPn12_genus %>%
  group_by(genus, timepoint) %>%
  filter(n() >= 5) %>%  # Ensure at least 20 IDs at each timepoint
  ungroup() %>%
  group_by(genus) %>%
  filter(n_distinct(timepoint) == 2) %>%  # Ensure species are present at both timepoints
  ungroup()

# Calculate average abundance for shared species
top_shared_genus <- shared_infant12_milkPn12_genus %>%
  group_by(genus) %>%
  dplyr::summarise(avg_abundance = mean(Abundance, na.rm = TRUE)) %>%
  arrange(desc(avg_abundance)) %>%  # Sort by descending average abundance
  slice_head(n = 10) %>%  # Select the top 10 species
  pull(genus)  # Extract species names

# Filter the dataset for the top 10 shared species
filtered_shared_genus <- shared_infant12_milkPn12_genus %>%
  filter(genus %in% top_shared_genus)

# Construct the wide-format data
genera_infantgut_milk_wide <- filtered_shared_genus %>%
  mutate(timepoint_genus = paste(timepoint, genus, sep = "_")) %>%  # Combine timepoint and species
  select(idbs, timepoint_genus, Abundance) %>%                       # Select relevant columns
  pivot_wider(names_from = timepoint_genus, values_from = Abundance) # Pivot to wider format

# Replace NA values with 0
genera_infantgut_milk_wide[is.na(genera_infantgut_milk_wide)] <- 0
colnames(genera_infantgut_milk_wide)

# Filter relevant columns for correlation
corr_data <- genera_infantgut_milk_wide %>%
  dplyr::select(starts_with("Pn12e_"), starts_with("Pn12h_"), -idbs)

# Extract and align species names
inf_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "Pn12e_")]
mat_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "Pn12h_")]

genus_inf <- gsub("^Pn12e_", "", inf_vars) 
genus_mat <- gsub("^Pn12h_", "", mat_vars)  

# Ensure alignment and limit to top 10 species
aligned_genus <- intersect(genus_inf, genus_mat)  # Find shared species
aligned_genus <- aligned_genus[aligned_genus %in% top_shared_genus]  # Restrict to top 10 species
inf_vars <- paste0("Pn12e_", aligned_genus)  
mat_vars <- paste0("Pn12h_", aligned_genus)  

# Compute correlation matrix
cor_mat <- cor(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Compute p-values for correlations
cor_test <- psych::corr.test(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  method = "spearman"
)
cor_test_mat <- cor_test$p.adj  # Extract p-values

# Plot heatmap of correlations
plot_corr <- {
  corrplot::corrplot(
    cor_mat,
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,  # Remove correlation coefficients
    p.mat = cor_test_mat,  # Add p-values for significance testing
    sig.level = c(0.001, 0.01, 0.05),  # Define significance levels
    insig = "label_sig",  # Show stars for significant correlations
    pch.cex = 1,  # Adjust size of significance stars
    pch.col = "black",  # Color for significance stars
    tl.cex = 0.7,  # Adjust text size of variable labels
    tl.col = "black",  # Label color
    title = "Correlation Heatmap (Top 10 pn12 vs. Pn12)",
    mar = c(0, 0, 1, 0)  # Adjust margins for better spacing
  )
  recordPlot()
}

#svglite::svglite(
#  filename="./forISRHML/heatmap_pn12e_Pn12h.svg",
#  width=5, height=5
#  )
#plot_corr
#dev.off()


## infant pn12e & milk Pn34h


infant_pn12_genus <- infant_genus %>%
  filter(timepoint=="Pn12") %>%
  mutate(timepoint="Pn12e") %>%
  select(genus, Abundance, idbs, timepoint)

milk_Pn34_genus <- milk_genus %>%
  filter(timepoint=="Pn34") %>%
  mutate(timepoint="Pn34h") %>%
  select(genus, Abundance, idbs, timepoint)

infant12_milkPn34_genus <- rbind(infant_pn12_genus, milk_Pn34_genus)

# Filter shared species present at both time points
shared_infant12_milkPn34_genus <- infant12_milkPn34_genus %>%
  group_by(genus, timepoint) %>%
  filter(n() >= 5) %>%  # Ensure at least 20 IDs at each timepoint
  ungroup() %>%
  group_by(genus) %>%
  filter(n_distinct(timepoint) == 2) %>%  # Ensure species are present at both timepoints
  ungroup()

# Calculate average abundance for shared species
top_shared_genus <- shared_infant12_milkPn34_genus %>%
  group_by(genus) %>%
  dplyr::summarise(avg_abundance = mean(Abundance, na.rm = TRUE)) %>%
  arrange(desc(avg_abundance)) %>%  # Sort by descending average abundance
  slice_head(n = 10) %>%  # Select the top 10 species
  pull(genus)  # Extract species names

# Filter the dataset for the top 10 shared species
filtered_shared_genus <- shared_infant12_milkPn34_genus %>%
  filter(genus %in% top_shared_genus)

# Construct the wide-format data
genera_infantgut_milk_wide <- filtered_shared_genus %>%
  mutate(timepoint_genus = paste(timepoint, genus, sep = "_")) %>%  # Combine timepoint and species
  select(idbs, timepoint_genus, Abundance) %>%                       # Select relevant columns
  pivot_wider(names_from = timepoint_genus, values_from = Abundance) # Pivot to wider format

# Replace NA values with 0
genera_infantgut_milk_wide[is.na(genera_infantgut_milk_wide)] <- 0
colnames(genera_infantgut_milk_wide)

# Filter relevant columns for correlation
corr_data <- genera_infantgut_milk_wide %>%
  dplyr::select(starts_with("Pn12e_"), starts_with("Pn34h_"), -idbs)

# Extract and align species names
inf_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "Pn12e_")]
mat_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "Pn34h_")]

genus_inf <- gsub("^Pn12e_", "", inf_vars) 
genus_mat <- gsub("^Pn34h_", "", mat_vars)  

# Ensure alignment and limit to top 10 species
aligned_genus <- intersect(genus_inf, genus_mat)  # Find shared species
aligned_genus <- aligned_genus[aligned_genus %in% top_shared_genus]  # Restrict to top 10 species
inf_vars <- paste0("Pn12e_", aligned_genus)  
mat_vars <- paste0("Pn34h_", aligned_genus)  

# Compute correlation matrix
cor_mat <- cor(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Compute p-values for correlations
cor_test <- psych::corr.test(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  method = "spearman"
)
cor_test_mat <- cor_test$p.adj  # Extract p-values

# Plot heatmap of correlations
plot_corr <- {
  corrplot::corrplot(
    cor_mat,
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,  # Remove correlation coefficients
    p.mat = cor_test_mat,  # Add p-values for significance testing
    sig.level = c(0.001, 0.01, 0.05),  # Define significance levels
    insig = "label_sig",  # Show stars for significant correlations
    pch.cex = 1,  # Adjust size of significance stars
    pch.col = "black",  # Color for significance stars
    tl.cex = 0.7,  # Adjust text size of variable labels
    tl.col = "black",  # Label color
    title = "Correlation Heatmap (Top 10 pn12e vs. Pn34h)",
    mar = c(0, 0, 1, 0)  # Adjust margins for better spacing
  )
  recordPlot()
}

#svglite::svglite(
#  filename="./forISRHML/heatmap_pn12e_Pn34h.svg",
#  width=5, height=5
#  )
#plot_corr
#dev.off()


## infant Pn56e & milk 1421h


infant_Pn56_genus <- infant_genus %>%
  filter(timepoint=="Pn56") %>%
  mutate(timepoint="Pn56e") %>%
  select(genus, Abundance, idbs, timepoint)

milk_1421_genus <- milk_genus %>%
  filter(timepoint=="1421") %>%
  mutate(timepoint="1421h") %>%
  select(genus, Abundance, idbs, timepoint)

infant12_milk1421_genus <- rbind(infant_Pn56_genus, milk_1421_genus)

# Filter shared species present at both time points
shared_infant12_milk1421_genus <- infant12_milk1421_genus %>%
  group_by(genus, timepoint) %>%
  filter(n() >= 5) %>%  # Ensure at least 20 IDs at each timepoint
  ungroup() %>%
  group_by(genus) %>%
  filter(n_distinct(timepoint) == 2) %>%  # Ensure species are present at both timepoints
  ungroup()

# Calculate average abundance for shared species
top_shared_genus <- shared_infant12_milk1421_genus %>%
  group_by(genus) %>%
  dplyr::summarise(avg_abundance = mean(Abundance, na.rm = TRUE)) %>%
  arrange(desc(avg_abundance)) %>%  # Sort by descending average abundance
  slice_head(n = 10) %>%  # Select the top 10 species
  pull(genus)  # Extract species names

# Filter the dataset for the top 10 shared species
filtered_shared_genus <- shared_infant12_milk1421_genus %>%
  filter(genus %in% top_shared_genus)

# Construct the wide-format data
genera_infantgut_milk_wide <- filtered_shared_genus %>%
  mutate(timepoint_genus = paste(timepoint, genus, sep = "_")) %>%  # Combine timepoint and species
  select(idbs, timepoint_genus, Abundance) %>%                       # Select relevant columns
  pivot_wider(names_from = timepoint_genus, values_from = Abundance) # Pivot to wider format

# Replace NA values with 0
genera_infantgut_milk_wide[is.na(genera_infantgut_milk_wide)] <- 0
colnames(genera_infantgut_milk_wide)

# Filter relevant columns for correlation
corr_data <- genera_infantgut_milk_wide %>%
  dplyr::select(starts_with("Pn56e_"), starts_with("1421h_"), -idbs)

# Extract and align species names
inf_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "Pn56e_")]
mat_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "1421h_")]

genus_inf <- gsub("^Pn56e_", "", inf_vars) 
genus_mat <- gsub("^1421h_", "", mat_vars)  

# Ensure alignment and limit to top 10 species
aligned_genus <- intersect(genus_inf, genus_mat)  # Find shared species
aligned_genus <- aligned_genus[aligned_genus %in% top_shared_genus]  # Restrict to top 10 species
inf_vars <- paste0("Pn56e_", aligned_genus)  
mat_vars <- paste0("1421h_", aligned_genus)  

# Compute correlation matrix
cor_mat <- cor(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Compute p-values for correlations
cor_test <- psych::corr.test(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  method = "spearman"
)
cor_test_mat <- cor_test$p.adj  # Extract p-values

# Plot heatmap of correlations
plot_corr <- {
  corrplot::corrplot(
    cor_mat,
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,  # Remove correlation coefficients
    p.mat = cor_test_mat,  # Add p-values for significance testing
    sig.level = c(0.001, 0.01, 0.05),  # Define significance levels
    insig = "label_sig",  # Show stars for significant correlations
    pch.cex = 1,  # Adjust size of significance stars
    pch.col = "black",  # Color for significance stars
    tl.cex = 0.7,  # Adjust text size of variable labels
    tl.col = "black",  # Label color
    title = "Correlation Heatmap (Top 10 Pn56e vs. 1421h)",
    mar = c(0, 0, 1, 0)  # Adjust margins for better spacing
  )
  recordPlot()
}

# svglite::svglite(
#   filename="./forISRHML/heatmap_Pn56e_1421h.svg",
#   width=5, height=5
#   )
# plot_corr
# dev.off()


## infant Pn56e & milk Pn12h


infant_Pn56_genus <- infant_genus %>%
  filter(timepoint=="Pn56") %>%
  mutate(timepoint="Pn56e") %>%
  select(genus, Abundance, idbs, timepoint)

milk_Pn12_genus <- milk_genus %>%
  filter(timepoint=="Pn12") %>%
  mutate(timepoint="Pn12h") %>%
  select(genus, Abundance, idbs, timepoint)

infantPn56_milkPn12_genus <- rbind(infant_Pn56_genus, milk_Pn12_genus)

# Filter shared species present at both time points
shared_infantPn56_milkPn12_genus <- infantPn56_milkPn12_genus %>%
  group_by(genus, timepoint) %>%
  filter(n() >= 5) %>%  # Ensure at least 20 IDs at each timepoint
  ungroup() %>%
  group_by(genus) %>%
  filter(n_distinct(timepoint) == 2) %>%  # Ensure species are present at both timepoints
  ungroup()

# Calculate average abundance for shared species
top_shared_genus <- shared_infantPn56_milkPn12_genus %>%
  group_by(genus) %>%
  dplyr::summarise(avg_abundance = mean(Abundance, na.rm = TRUE)) %>%
  arrange(desc(avg_abundance)) %>%  # Sort by descending average abundance
  slice_head(n = 10) %>%  # Select the top 10 species
  pull(genus)  # Extract species names

# Filter the dataset for the top 10 shared species
filtered_shared_genus <- shared_infantPn56_milkPn12_genus %>%
  filter(genus %in% top_shared_genus)

# Construct the wide-format data
genera_infantgut_milk_wide <- filtered_shared_genus %>%
  mutate(timepoint_genus = paste(timepoint, genus, sep = "_")) %>%  # Combine timepoint and species
  select(idbs, timepoint_genus, Abundance) %>%                       # Select relevant columns
  pivot_wider(names_from = timepoint_genus, values_from = Abundance) # Pivot to wider format

# Replace NA values with 0
genera_infantgut_milk_wide[is.na(genera_infantgut_milk_wide)] <- 0
colnames(genera_infantgut_milk_wide)

# Filter relevant columns for correlation
corr_data <- genera_infantgut_milk_wide %>%
  dplyr::select(starts_with("Pn56e_"), starts_with("Pn12h_"), -idbs)

# Extract and align species names
inf_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "Pn56e_")]
mat_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "Pn12h_")]

genus_inf <- gsub("^Pn56e_", "", inf_vars) 
genus_mat <- gsub("^Pn12h_", "", mat_vars)  

# Ensure alignment and limit to top 10 species
aligned_genus <- intersect(genus_inf, genus_mat)  # Find shared species
aligned_genus <- aligned_genus[aligned_genus %in% top_shared_genus]  # Restrict to top 10 species
inf_vars <- paste0("Pn56e_", aligned_genus)  
mat_vars <- paste0("Pn12h_", aligned_genus)  

# Compute correlation matrix
cor_mat <- cor(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Compute p-values for correlations
cor_test <- psych::corr.test(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  method = "spearman"
)
cor_test_mat <- cor_test$p.adj  # Extract p-values

# Plot heatmap of correlations
plot_corr <- {
  corrplot::corrplot(
    cor_mat,
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,  # Remove correlation coefficients
    p.mat = cor_test_mat,  # Add p-values for significance testing
    sig.level = c(0.001, 0.01, 0.05),  # Define significance levels
    insig = "label_sig",  # Show stars for significant correlations
    pch.cex = 1,  # Adjust size of significance stars
    pch.col = "black",  # Color for significance stars
    tl.cex = 0.7,  # Adjust text size of variable labels
    tl.col = "black",  # Label color
    title = "Correlation Heatmap (Top 10 pn12 vs. Pn12)",
    mar = c(0, 0, 1, 0)  # Adjust margins for better spacing
  )
  recordPlot()
}

# svglite::svglite(
#   filename="./forISRHML/heatmap_Pn56e_Pn12h.svg",
#   width=5, height=5
#   )
# plot_corr
# dev.off()


## infant Pn56e & milk Pn34h


infant_Pn56_genus <- infant_genus %>%
  filter(timepoint=="Pn56") %>%
  mutate(timepoint="Pn56e") %>%
  select(genus, Abundance, idbs, timepoint)

milk_Pn34_genus <- milk_genus %>%
  filter(timepoint=="Pn34") %>%
  mutate(timepoint="Pn34h") %>%
  select(genus, Abundance, idbs, timepoint)

infant12_milkPn34_genus <- rbind(infant_Pn56_genus, milk_Pn34_genus)

# Filter shared species present at both time points
shared_infant12_milkPn34_genus <- infant12_milkPn34_genus %>%
  group_by(genus, timepoint) %>%
  filter(n() >= 5) %>%  # Ensure at least 20 IDs at each timepoint
  ungroup() %>%
  group_by(genus) %>%
  filter(n_distinct(timepoint) == 2) %>%  # Ensure species are present at both timepoints
  ungroup()

# Calculate average abundance for shared species
top_shared_genus <- shared_infant12_milkPn34_genus %>%
  group_by(genus) %>%
  dplyr::summarise(avg_abundance = mean(Abundance, na.rm = TRUE)) %>%
  arrange(desc(avg_abundance)) %>%  # Sort by descending average abundance
  slice_head(n = 10) %>%  # Select the top 10 species
  pull(genus)  # Extract species names

# Filter the dataset for the top 10 shared species
filtered_shared_genus <- shared_infant12_milkPn34_genus %>%
  filter(genus %in% top_shared_genus)

# Construct the wide-format data
genera_infantgut_milk_wide <- filtered_shared_genus %>%
  mutate(timepoint_genus = paste(timepoint, genus, sep = "_")) %>%  # Combine timepoint and species
  select(idbs, timepoint_genus, Abundance) %>%                       # Select relevant columns
  pivot_wider(names_from = timepoint_genus, values_from = Abundance) # Pivot to wider format

# Replace NA values with 0
genera_infantgut_milk_wide[is.na(genera_infantgut_milk_wide)] <- 0
colnames(genera_infantgut_milk_wide)

# Filter relevant columns for correlation
corr_data <- genera_infantgut_milk_wide %>%
  dplyr::select(starts_with("Pn56e_"), starts_with("Pn34h_"), -idbs)

# Extract and align species names
inf_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "Pn56e_")]
mat_vars <- colnames(corr_data)[str_starts(colnames(corr_data), "Pn34h_")]

genus_inf <- gsub("^Pn56e_", "", inf_vars) 
genus_mat <- gsub("^Pn34h_", "", mat_vars)  

# Ensure alignment and limit to top 10 species
aligned_genus <- intersect(genus_inf, genus_mat)  # Find shared species
aligned_genus <- aligned_genus[aligned_genus %in% top_shared_genus]  # Restrict to top 10 species
inf_vars <- paste0("Pn56e_", aligned_genus)  
mat_vars <- paste0("Pn34h_", aligned_genus)  

# Compute correlation matrix
cor_mat <- cor(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Compute p-values for correlations
cor_test <- psych::corr.test(
  corr_data[, inf_vars, drop = FALSE],
  corr_data[, mat_vars, drop = FALSE],
  method = "spearman"
)
cor_test_mat <- cor_test$p.adj  # Extract p-values

# Plot heatmap of correlations
plot_corr <- {
  corrplot::corrplot(
    cor_mat,
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,  # Remove correlation coefficients
    p.mat = cor_test_mat,  # Add p-values for significance testing
    sig.level = c(0.001, 0.01, 0.05),  # Define significance levels
    insig = "label_sig",  # Show stars for significant correlations
    pch.cex = 1,  # Adjust size of significance stars
    pch.col = "black",  # Color for significance stars
    tl.cex = 0.7,  # Adjust text size of variable labels
    tl.col = "black",  # Label color
    title = "Correlation Heatmap (Top 10 Pn56e vs. Pn34h)",
    mar = c(0, 0, 1, 0)  # Adjust margins for better spacing
  )
  recordPlot()
}

# svglite::svglite(
#   filename="./forISRHML/heatmap_Pn56e_Pn34h.svg",
#   width=5, height=5
#   )
# plot_corr
# dev.off()

```

## Fig5C infant gut & hmo

```{r}

## infant pn12e & hmo 1421
infant_species_pn12 <- infant_species %>%
  filter(timepoint == "pn12") %>%
  filter(Abundance >= 0.05) %>%
  select(idbs, species, Abundance) %>%
  pivot_wider(names_from = species, values_from = Abundance) %>%
  dplyr::select(idbs, where(~ mean(is.na(.)) <= 0.95))

infant_species_pn12$idbs <- as.character(infant_species_pn12$idbs )

hmo_1421 <- hmoMeta %>%
  filter(timepoint == "1421") %>%
  rename_with(~ str_replace(., "_nmol\\.mL$", ""), contains("_nmol.mL")) %>%
  select(idbs, "Secretor","X2.FL", "X3FL","LNT", "LNFP.II", "LNFP.I","X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", "X3.SL", "LSTc","DSLNT","FDSLNH", "DSLNH", "LNH","LSTb","DFLNH", "LNFP.III")

infant_hmo_pn12milk1421 <- hmo_1421 %>%
  left_join(infant_species_pn12, by = "idbs") %>%
  #left_join(row_annotation_idbs, by = "idbs")  %>% # Perform the join
  #left_join(metadata %>% dplyr::select(idbs, code, GWG, hh_child5)) %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) %>%
  select(-idbs)

# Step 1: Reshape the data
# Assuming infant_hmo_pn12milk1421 is your dataframe with species and HMO columns

results_list <- lapply(names(infant_hmo_pn12milk1421)[grepl("X2.FL|X3FL|LNT|LNFP.II|LNFP.I|X6.SL|DFLNT|DFLac|LNnT|FLNH|X3.SL|LSTc|DSLNT|FDSLNH|DSLNH|LNH|LSTb|DFLNH|LNFP.III", names(infant_hmo_pn12milk1421))], function(hmo_column) {
  lapply(names(infant_hmo_pn12milk1421)[!grepl("code|Secretor|X2.FL|X3FL|LNT|LNFP.II|LNFP.I|X6.SL|DFLNT|DFLac|LNnT|FLNH|X3.SL|LSTc|DSLNT|FDSLNH|DSLNH|LNH|LSTb|DFLNH|LNFP.III", names(infant_hmo_pn12milk1421))], function(species_column) {
    
    # Log-transform species data before performing linear regression
    log_species <- log1p(infant_hmo_pn12milk1421[[species_column]])  # Apply log(1 + x) transformation
    
    # Log-transform HMO levels before performing linear regression
    log_hmo <- log1p(infant_hmo_pn12milk1421[[hmo_column]])  # Apply log(1 + x) transformation
    
    # Perform linear regression for each species vs each HMO 
    lm_result <- lm(log_species ~ log_hmo + infant_hmo_pn12milk1421$code + infant_hmo_pn12milk1421$Secretor)
    # Extract coefficient and p-value
    coef_val <- coef(lm_result)[2]  # Coefficient of the HMO
    p_val <- summary(lm_result)$coefficients[2, 4]  # p-value for HMO
    
    # Return results as a data frame
    tibble(species = species_column, HMO = hmo_column, coefficient = coef_val, p_value = p_val)
  })
})

# Flatten the list into a single data frame
results_df <- bind_rows(unlist(results_list, recursive = TRUE))

# Step 1: Convert the dataframe to a matrix
results_matrix <- as.matrix(results_df)

# Step 2: Reshape the matrix into a new matrix where each row has 4 columns
reshaped_matrix <- matrix(results_matrix, ncol = 4, byrow = TRUE)

# Step 3: Convert the reshaped matrix back into a dataframe
results_table <- as.data.frame(reshaped_matrix)

# Optionally, assign column names (optional step)
colnames(results_table) <- c("Species", "HMO", "Coefficient", "P_value")

# View the resulting table
print(results_table)

# Step 3: FDR correction of p-values using BH method
results_adj <- results_table %>%
  dplyr::mutate(adj_p_value = p.adjust(P_value, method = "BH"))

# Step 4: Define significance based on adjusted p-values
results_adj <- results_adj %>%
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      P_value <= 0.05 & adj_p_value > 0.1 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )
# Check the output
head(results_adj)

results_adj$Coefficient <- as.numeric(results_adj$Coefficient)
hmo_order <- c("X2.FL", "X3FL", "LNT", "LNFP.II", "LNFP.I", "X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", 
               "X3.SL", "LSTc", "DSLNT", "FDSLNH", "DSLNH", "LNH", "LSTb", "DFLNH", "LNFP.III")
results_adj$HMO <- factor(results_adj$HMO, levels = hmo_order)

max_coef <- max(abs(results_adj$Coefficient), na.rm = TRUE)

# Plot the heatmap using ggplot2
infant_hmo_pn12milk1421_Heatmap <- ggplot(results_adj, aes(x = HMO, y = Species, fill = Coefficient)) +
  geom_tile(color = "white", width = 0.9, height = 0.9) +  # Create heatmap tiles
  geom_text(aes(label = significance), color = "black", size = 6) +  # Add significance labels inside cells
  scale_fill_gradientn(
    colours = divergingx_hcl(5, palette = "RdBu"),  # perceptually uniform
    limits = c(-max_coef, max_coef),
    name = "Coefficient"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        axis.text.y = element_text(size = 10), 
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        ) +
  labs(
       x = "HMO at 14-21 days", 
       y = "Infant gut at 1-2 months")
infant_hmo_pn12milk1421_Heatmap

# Save as SVG with a 1.5 aspect ratio
#ggsave("./forISRHML/Jun2_infant_hmo_pn12milk1421_Heatmap_codeSecretor.svg", infant_hmo_pn12milk1421_Heatmap, width = 6, height = 4, dpi = 300)

## infant pn12e & hmo pn12

hmo_pn12 <- hmoMeta %>%
  filter(timepoint == "pn12") %>%
  rename_with(~ str_replace(., "_nmol\\.mL$", ""), contains("_nmol.mL")) %>%
  select(idbs, "Secretor","X2.FL", "X3FL","LNT", "LNFP.II", "LNFP.I","X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", "X3.SL", "LSTc","DSLNT","FDSLNH", "DSLNH", "LNH","LSTb","DFLNH", "LNFP.III")

infant_hmo_pn12 <- hmo_pn12 %>%
#  filter(Secretor == 1) %>%
    left_join(infant_species_pn12, by = "idbs") %>%
  #left_join(row_annotation_idbs, by = "idbs")  %>% # Perform the join
  #left_join(metadata %>% dplyr::select(idbs, code, GWG, hh_child5)) %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) %>%
  select(-idbs)


# Step 2: Perform linear regression for each species and HMO
results_list <- lapply(names(infant_hmo_pn12)[grepl("X2.FL|X3FL|LNT|LNFP.II|LNFP.I|X6.SL|DFLNT|DFLac|LNnT|FLNH|X3.SL|LSTc|DSLNT|FDSLNH|DSLNH|LNH|LSTb|DFLNH|LNFP.III", names(infant_hmo_pn12))], function(hmo_column) {
  lapply(names(infant_hmo_pn12)[!grepl("code|Secretor|X2.FL|X3FL|LNT|LNFP.II|LNFP.I|X6.SL|DFLNT|DFLac|LNnT|FLNH|X3.SL|LSTc|DSLNT|FDSLNH|DSLNH|LNH|LSTb|DFLNH|LNFP.III", names(infant_hmo_pn12))], function(species_column) {
    
    # Log-transform species data before performing linear regression
    log_species <- log1p(infant_hmo_pn12[[species_column]])  # Apply log(1 + x) transformation
    
    # Log-transform HMO levels before performing linear regression
    log_hmo <- log1p(infant_hmo_pn12[[hmo_column]])  # Apply log(1 + x) transformation
    
    # Perform linear regression for each species vs each HMO
    lm_result <- lm(log_species ~ log_hmo + infant_hmo_pn12$code + infant_hmo_pn12$Secretor)
    
    # Extract coefficient and p-value
    coef_val <- coef(lm_result)[2]  # Coefficient of the HMO
    p_val <- summary(lm_result)$coefficients[2, 4]  # p-value for HMO
    
    # Return results as a data frame
    tibble(species = species_column, HMO = hmo_column, coefficient = coef_val, p_value = p_val)
  })
})

# Flatten the list into a single data frame
results_df <- bind_rows(unlist(results_list, recursive = TRUE))

# Step 1: Convert the dataframe to a matrix
results_matrix <- as.matrix(results_df)

# Step 2: Reshape the matrix into a new matrix where each row has 4 columns
reshaped_matrix <- matrix(results_matrix, ncol = 4, byrow = TRUE)

# Step 3: Convert the reshaped matrix back into a dataframe
results_table <- as.data.frame(reshaped_matrix)

# Optionally, assign column names (optional step)
colnames(results_table) <- c("Species", "HMO", "Coefficient", "P_value")

# View the resulting table
print(results_table)

# Step 3: FDR correction of p-values using BH method
results_adj <- results_table %>%
  dplyr::mutate(adj_p_value = p.adjust(P_value, method = "BH"))

# Step 4: Define significance based on adjusted p-values
results_adj <- results_adj %>%
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      P_value <= 0.05 & adj_p_value > 0.1 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )
# Check the output
head(results_adj)

results_adj$Coefficient <- as.numeric(results_adj$Coefficient)
hmo_order <- c("X2.FL", "X3FL", "LNT", "LNFP.II", "LNFP.I", "X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", 
               "X3.SL", "LSTc", "DSLNT", "FDSLNH", "DSLNH", "LNH", "LSTb", "DFLNH", "LNFP.III")
results_adj$HMO <- factor(results_adj$HMO, levels = hmo_order)

max_coef <- max(abs(results_adj$Coefficient), na.rm = TRUE)

# Plot the heatmap using ggplot2
infant_hmo_pn12_Heatmap <- ggplot(results_adj, aes(x = HMO, y = Species, fill = Coefficient)) +
  geom_tile(color = "white", width = 0.9, height = 0.9) +  # Create heatmap tiles
  geom_text(aes(label = significance), color = "black", size = 6) +  # Add significance labels inside cells
  scale_fill_gradientn(
    colours = divergingx_hcl(5, palette = "RdBu"),  # perceptually uniform
    limits = c(-max_coef, max_coef),
    name = "Coefficient"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        axis.text.y = element_text(size = 10), 
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        ) +
  labs(
       x = "HMO at 1-2 months", 
       y = "Infant gut at 1-2 months")
infant_hmo_pn12_Heatmap

#ggsave("./forISRHML/Jun2_infant_hmo_pn12_Heatmap_codeSecretor.svg", infant_hmo_pn12_Heatmap, width = 6, height = 4, dpi = 300)

## infant pn12e & hmo pn34

hmo_pn34 <- hmoMeta %>%
  filter(timepoint == "pn34") %>%
  rename_with(~ str_replace(., "_nmol\\.mL$", ""), contains("_nmol.mL")) %>%
  select(idbs, "Secretor","X2.FL", "X3FL","LNT", "LNFP.II", "LNFP.I","X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", "X3.SL", "LSTc","DSLNT","FDSLNH", "DSLNH", "LNH","LSTb","DFLNH", "LNFP.III")

infant_hmo_pn12pn34 <- hmo_pn34 %>%
    left_join(infant_species_pn12, by = "idbs") %>%
  #left_join(row_annotation_idbs, by = "idbs")  %>% # Perform the join
  #left_join(metadata %>% dplyr::select(idbs, code, GWG, hh_child5)) %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) %>%
  select(-idbs)


# Step 2: Perform linear regression for each species and HMO
results_list <- lapply(names(infant_hmo_pn12pn34)[grepl("X2.FL|X3FL|LNT|LNFP.II|LNFP.I|X6.SL|DFLNT|DFLac|LNnT|FLNH|X3.SL|LSTc|DSLNT|FDSLNH|DSLNH|LNH|LSTb|DFLNH|LNFP.III", names(infant_hmo_pn12pn34))], function(hmo_column) {
  lapply(names(infant_hmo_pn12pn34)[!grepl("code|Secretor|X2.FL|X3FL|LNT|LNFP.II|LNFP.I|X6.SL|DFLNT|DFLac|LNnT|FLNH|X3.SL|LSTc|DSLNT|FDSLNH|DSLNH|LNH|LSTb|DFLNH|LNFP.III", names(infant_hmo_pn12pn34))], function(species_column) {
    
    # Log-transform species data before performing linear regression
    log_species <- log1p(infant_hmo_pn12pn34[[species_column]])  # Apply log(1 + x) transformation
    
    # Log-transform HMO levels before performing linear regression
    log_hmo <- log1p(infant_hmo_pn12pn34[[hmo_column]])  # Apply log(1 + x) transformation
    
    # Perform linear regression for each species vs each HMO
    lm_result <- lm(log_species ~ log_hmo + infant_hmo_pn12pn34$code + infant_hmo_pn12pn34$Secretor )
    
    # Extract coefficient and p-value
    coef_val <- coef(lm_result)[2]  # Coefficient of the HMO
    p_val <- summary(lm_result)$coefficients[2, 4]  # p-value for HMO
    
    # Return results as a data frame
    tibble(species = species_column, HMO = hmo_column, coefficient = coef_val, p_value = p_val)
  })
})

# Flatten the list into a single data frame
results_df <- bind_rows(unlist(results_list, recursive = TRUE))

# Step 1: Convert the dataframe to a matrix
results_matrix <- as.matrix(results_df)

# Step 2: Reshape the matrix into a new matrix where each row has 4 columns
reshaped_matrix <- matrix(results_matrix, ncol = 4, byrow = TRUE)

# Step 3: Convert the reshaped matrix back into a dataframe
results_table <- as.data.frame(reshaped_matrix)

# Optionally, assign column names (optional step)
colnames(results_table) <- c("Species", "HMO", "Coefficient", "P_value")

# View the resulting table
print(results_table)

# Step 3: FDR correction of p-values using BH method
results_adj <- results_table %>%
  dplyr::mutate(adj_p_value = p.adjust(P_value, method = "BH"))

# Step 4: Define significance based on adjusted p-values
results_adj <- results_adj %>%
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      P_value <= 0.05 & adj_p_value > 0.1 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )
# Check the output
head(results_adj)

results_adj$Coefficient <- as.numeric(results_adj$Coefficient)
hmo_order <- c("X2.FL", "X3FL", "LNT", "LNFP.II", "LNFP.I", "X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", 
               "X3.SL", "LSTc", "DSLNT", "FDSLNH", "DSLNH", "LNH", "LSTb", "DFLNH", "LNFP.III")
results_adj$HMO <- factor(results_adj$HMO, levels = hmo_order)

max_coef <- max(abs(results_adj$Coefficient), na.rm = TRUE)
# Plot the heatmap using ggplot2
infant_hmo_pn12pn34_Heatmap <- ggplot(results_adj, aes(x = HMO, y = Species, fill = Coefficient)) +
  geom_tile(color = "white", width = 0.9, height = 0.9) +  # Create heatmap tiles
  geom_text(aes(label = significance), color = "black", size = 6) +  # Add significance labels inside cells
  scale_fill_gradientn(
    colours = divergingx_hcl(5, palette = "RdBu"),  # perceptually uniform
    limits = c(-max_coef, max_coef),
    name = "Coefficient"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        axis.text.y = element_text(size = 10), 
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        ) +
  labs(
       x = "HMO at 3-4 months", 
       y = "Infant gut at 1-2 months")
infant_hmo_pn12pn34_Heatmap

#ggsave("./forISRHML/Jun2_infant_hmo_pn12pn34_Heatmap_codeSecretor.svg", infant_hmo_pn12pn34_Heatmap, width = 6, height = 4, dpi = 300)


## infant pn56e & hmo 1421

infant_species_pn56 <- infant_species %>%
  filter(timepoint == "pn56") %>%
  filter(Abundance >= 0.05) %>%
  select(idbs, species, Abundance) %>%
  pivot_wider(names_from = species, values_from = Abundance) %>%
  dplyr::select(idbs, where(~ mean(is.na(.)) <= 0.95))
infant_species_pn56$idbs <- as.character(infant_species_pn56$idbs )

infant_hmo_pn56milk1421 <- hmo_1421 %>%
  left_join(infant_species_pn56, by = "idbs") %>%
  #left_join(row_annotation_idbs, by = "idbs")  %>% # Perform the join
  #left_join(metadata %>% dplyr::select(idbs, code, GWG, hh_child5)) %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) %>%
  select(-idbs)

# Step 1: Reshape the data
# Assuming infant_hmo_pn12milk1421 is your dataframe with species and HMO columns

results_list <- lapply(names(infant_hmo_pn56milk1421)[grepl("X2.FL|X3FL|LNT|LNFP.II|LNFP.I|X6.SL|DFLNT|DFLac|LNnT|FLNH|X3.SL|LSTc|DSLNT|FDSLNH|DSLNH|LNH|LSTb|DFLNH|LNFP.III", names(infant_hmo_pn56milk1421))], function(hmo_column) {
  lapply(names(infant_hmo_pn56milk1421)[!grepl("code|Secretor|X2.FL|X3FL|LNT|LNFP.II|LNFP.I|X6.SL|DFLNT|DFLac|LNnT|FLNH|X3.SL|LSTc|DSLNT|FDSLNH|DSLNH|LNH|LSTb|DFLNH|LNFP.III", names(infant_hmo_pn56milk1421))], function(species_column) {
    
    # Log-transform species data before performing linear regression
    log_species <- log1p(infant_hmo_pn56milk1421[[species_column]])  # Apply log(1 + x) transformation
    
    # Log-transform HMO levels before performing linear regression
    log_hmo <- log1p(infant_hmo_pn56milk1421[[hmo_column]])  # Apply log(1 + x) transformation
    
    # Perform linear regression for each species vs each HMO
    lm_result <- lm(log_species ~ log_hmo + infant_hmo_pn56milk1421$code+ infant_hmo_pn56milk1421$Secretor)
    
    # Extract coefficient and p-value
    coef_val <- coef(lm_result)[2]  # Coefficient of the HMO
    p_val <- summary(lm_result)$coefficients[2, 4]  # p-value for HMO
    
    # Return results as a data frame
    tibble(species = species_column, HMO = hmo_column, coefficient = coef_val, p_value = p_val)
  })
})

# Flatten the list into a single data frame
results_df <- bind_rows(unlist(results_list, recursive = TRUE))

# Step 1: Convert the dataframe to a matrix
results_matrix <- as.matrix(results_df)

# Step 2: Reshape the matrix into a new matrix where each row has 4 columns
reshaped_matrix <- matrix(results_matrix, ncol = 4, byrow = TRUE)

# Step 3: Convert the reshaped matrix back into a dataframe
results_table <- as.data.frame(reshaped_matrix)

# Optionally, assign column names (optional step)
colnames(results_table) <- c("Species", "HMO", "Coefficient", "P_value")

# View the resulting table
print(results_table)

# Step 3: FDR correction of p-values using BH method
results_adj <- results_table %>%
  dplyr::mutate(adj_p_value = p.adjust(P_value, method = "BH"))

# Step 4: Define significance based on adjusted p-values
results_adj <- results_adj %>%
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      P_value <= 0.05 & adj_p_value > 0.1 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )
# Check the output
head(results_adj)

results_adj$Coefficient <- as.numeric(results_adj$Coefficient)
hmo_order <- c("X2.FL", "X3FL", "LNT", "LNFP.II", "LNFP.I", "X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", 
               "X3.SL", "LSTc", "DSLNT", "FDSLNH", "DSLNH", "LNH", "LSTb", "DFLNH", "LNFP.III")
results_adj$HMO <- factor(results_adj$HMO, levels = hmo_order)

max_coef <- max(abs(results_adj$Coefficient), na.rm = TRUE)

# Plot the heatmap using ggplot2
infant_hmo_pn56milk1421_Heatmap <- ggplot(results_adj, aes(x = HMO, y = Species, fill = Coefficient)) +
  geom_tile(color = "white", width = 0.9, height = 0.9) +  # Create heatmap tiles
  geom_text(aes(label = significance), color = "black", size = 6) +  # Add significance labels inside cells
  scale_fill_gradientn(
    colours = divergingx_hcl(5, palette = "RdBu"),  # perceptually uniform
    limits = c(-max_coef, max_coef),
    name = "Coefficient"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        axis.text.y = element_text(size = 10), 
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        ) +
  labs(
       x = "HMO at 14-21 days", 
       y = "Infant gut at 5-6 months")
infant_hmo_pn56milk1421_Heatmap

#ggsave("./forISRHML/Jun2_infant_hmo_pn56milk1421_Heatmap_codeSecretor.svg", infant_hmo_pn56milk1421_Heatmap, width = 6, height = 4, dpi = 300)

infant_hmo_pn56milkpn12 <- hmo_pn12 %>%
  left_join(infant_species_pn56, by = "idbs") %>%
  #left_join(row_annotation_idbs, by = "idbs")  %>% # Perform the join
  #left_join(metadata %>% dplyr::select(idbs, code, GWG, hh_child5)) %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) %>%
  select(-idbs)

# Step 1: Reshape the data
# Assuming infant_hmo_pn12milk1421 is your dataframe with species and HMO columns

results_list <- lapply(names(infant_hmo_pn56milkpn12)[grepl("X2.FL|X3FL|LNT|LNFP.II|LNFP.I|X6.SL|DFLNT|DFLac|LNnT|FLNH|X3.SL|LSTc|DSLNT|FDSLNH|DSLNH|LNH|LSTb|DFLNH|LNFP.III", names(infant_hmo_pn56milkpn12))], function(hmo_column) {
  lapply(names(infant_hmo_pn56milkpn12)[!grepl("code|Secretor|X2.FL|X3FL|LNT|LNFP.II|LNFP.I|X6.SL|DFLNT|DFLac|LNnT|FLNH|X3.SL|LSTc|DSLNT|FDSLNH|DSLNH|LNH|LSTb|DFLNH|LNFP.III", names(infant_hmo_pn56milkpn12))], function(species_column) {
    
    # Log-transform species data before performing linear regression
    log_species <- log1p(infant_hmo_pn56milkpn12[[species_column]])  # Apply log(1 + x) transformation
    
    # Log-transform HMO levels before performing linear regression
    log_hmo <- log1p(infant_hmo_pn56milkpn12[[hmo_column]])  # Apply log(1 + x) transformation
    
    # Perform linear regression for each species vs each HMO
    lm_result <- lm(log_species ~ log_hmo + infant_hmo_pn56milkpn12$code + infant_hmo_pn56milkpn12$Secretor)
    
    # Extract coefficient and p-value
    coef_val <- coef(lm_result)[2]  # Coefficient of the HMO
    p_val <- summary(lm_result)$coefficients[2, 4]  # p-value for HMO
    
    # Return results as a data frame
    tibble(species = species_column, HMO = hmo_column, coefficient = coef_val, p_value = p_val)
  })
})

# Flatten the list into a single data frame
results_df <- bind_rows(unlist(results_list, recursive = TRUE))

# Step 1: Convert the dataframe to a matrix
results_matrix <- as.matrix(results_df)

# Step 2: Reshape the matrix into a new matrix where each row has 4 columns
reshaped_matrix <- matrix(results_matrix, ncol = 4, byrow = TRUE)

# Step 3: Convert the reshaped matrix back into a dataframe
results_table <- as.data.frame(reshaped_matrix)

# Optionally, assign column names (optional step)
colnames(results_table) <- c("Species", "HMO", "Coefficient", "P_value")

# View the resulting table
print(results_table)

# Step 3: FDR correction of p-values using BH method
results_adj <- results_table %>%
  dplyr::mutate(adj_p_value = p.adjust(P_value, method = "BH"))

# Step 4: Define significance based on adjusted p-values
results_adj <- results_adj %>%
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      P_value <= 0.05 & adj_p_value > 0.1 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )
# Check the output
head(results_adj)

results_adj$Coefficient <- as.numeric(results_adj$Coefficient)
hmo_order <- c("X2.FL", "X3FL", "LNT", "LNFP.II", "LNFP.I", "X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", 
               "X3.SL", "LSTc", "DSLNT", "FDSLNH", "DSLNH", "LNH", "LSTb", "DFLNH", "LNFP.III")
results_adj$HMO <- factor(results_adj$HMO, levels = hmo_order)

max_coef <- max(abs(results_adj$Coefficient), na.rm = TRUE)

# Plot the heatmap using ggplot2
infant_hmo_pn56milkpn12_Heatmap <- ggplot(results_adj, aes(x = HMO, y = Species, fill = Coefficient)) +
  geom_tile(color = "white", width = 0.9, height = 0.9) +  # Create heatmap tiles
  geom_text(aes(label = significance), color = "black", size = 6) +  # Add significance labels inside cells
  scale_fill_gradientn(
    colours = divergingx_hcl(5, palette = "RdBu"),  # perceptually uniform
    limits = c(-0.3,0.3),
    name = "Coefficient"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        axis.text.y = element_text(size = 10), 
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        ) +
  labs(
       x = "HMO at 1-2 months", 
       y = "Infant gut at 5-6 months")
infant_hmo_pn56milkpn12_Heatmap

#ggsave("./forISRHML/Jun2_infant_hmo_pn56milkpn12_Heatmap_codeSecretor.svg", infant_hmo_pn56milkpn12_Heatmap, width = 6, height = 4, dpi = 300)

infant_hmo_pn56milkpn34 <- hmo_pn34 %>%
  left_join(infant_species_pn56, by = "idbs") %>%
  #left_join(row_annotation_idbs, by = "idbs")  %>% # Perform the join
  #left_join(metadata %>% dplyr::select(idbs, code, GWG, hh_child5)) %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) %>%
  select(-idbs)

# Step 1: Reshape the data
# Assuming infant_hmo_pn12milk1421 is your dataframe with species and HMO columns

results_list <- lapply(names(infant_hmo_pn56milkpn34)[grepl("X2.FL|X3FL|LNT|LNFP.II|LNFP.I|X6.SL|DFLNT|DFLac|LNnT|FLNH|X3.SL|LSTc|DSLNT|FDSLNH|DSLNH|LNH|LSTb|DFLNH|LNFP.III", names(infant_hmo_pn56milkpn34))], function(hmo_column) {
  lapply(names(infant_hmo_pn56milkpn34)[!grepl("code|Secretor|X2.FL|X3FL|LNT|LNFP.II|LNFP.I|X6.SL|DFLNT|DFLac|LNnT|FLNH|X3.SL|LSTc|DSLNT|FDSLNH|DSLNH|LNH|LSTb|DFLNH|LNFP.III", names(infant_hmo_pn56milkpn34))], function(species_column) {
    
    # Log-transform species data before performing linear regression
    log_species <- log1p(infant_hmo_pn56milkpn34[[species_column]])  # Apply log(1 + x) transformation
    
    # Log-transform HMO levels before performing linear regression
    log_hmo <- log1p(infant_hmo_pn56milkpn34[[hmo_column]])  # Apply log(1 + x) transformation
    
    # Perform linear regression for each species vs each HMO
    lm_result <- lm(log_species ~ log_hmo + infant_hmo_pn56milkpn34$code + infant_hmo_pn56milkpn34$Secretor)
    
    # Extract coefficient and p-value
    coef_val <- coef(lm_result)[2]  # Coefficient of the HMO
    p_val <- summary(lm_result)$coefficients[2, 4]  # p-value for HMO
    
    # Return results as a data frame
    tibble(species = species_column, HMO = hmo_column, coefficient = coef_val, p_value = p_val)
  })
})

# Flatten the list into a single data frame
results_df <- bind_rows(unlist(results_list, recursive = TRUE))

# Step 1: Convert the dataframe to a matrix
results_matrix <- as.matrix(results_df)

# Step 2: Reshape the matrix into a new matrix where each row has 4 columns
reshaped_matrix <- matrix(results_matrix, ncol = 4, byrow = TRUE)

# Step 3: Convert the reshaped matrix back into a dataframe
results_table <- as.data.frame(reshaped_matrix)

# Optionally, assign column names (optional step)
colnames(results_table) <- c("Species", "HMO", "Coefficient", "P_value")

# View the resulting table
print(results_table)

# Step 3: FDR correction of p-values using BH method
results_adj <- results_table %>%
  dplyr::mutate(adj_p_value = p.adjust(P_value, method = "BH"))

# Step 4: Define significance based on adjusted p-values
results_adj <- results_adj %>%
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      P_value <= 0.05 & adj_p_value > 0.1 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )
# Check the output
head(results_adj)

results_adj$Coefficient <- as.numeric(results_adj$Coefficient)
hmo_order <- c("X2.FL", "X3FL", "LNT", "LNFP.II", "LNFP.I", "X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", 
               "X3.SL", "LSTc", "DSLNT", "FDSLNH", "DSLNH", "LNH", "LSTb", "DFLNH", "LNFP.III")
results_adj$HMO <- factor(results_adj$HMO, levels = hmo_order)

max_coef <- max(abs(results_adj$Coefficient), na.rm = TRUE)

# Plot the heatmap using ggplot2
infant_hmo_pn56pn34_Heatmap <- ggplot(results_adj, aes(x = HMO, y = Species, fill = Coefficient)) +
  geom_tile(color = "white", width = 0.9, height = 0.9) +  # Create heatmap tiles
  geom_text(aes(label = significance), color = "black", size = 6) +  # Add significance labels inside cells
  scale_fill_gradientn(
    colours = divergingx_hcl(5, palette = "RdBu"),  # perceptually uniform
    limits = c(-max_coef, max_coef),
    name = "Coefficient"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        axis.text.y = element_text(size = 10), 
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        ) +
  labs(
       x = "HMO at 3-4 months", 
       y = "Infant gut at 5-6 months")
infant_hmo_pn56pn34_Heatmap

#ggsave("./forISRHML/Jun2_infant_hmo_pn56pn34_Heatmap_codeSecretor.svg", infant_hmo_pn56pn34_Heatmap, width = 6, height = 4, dpi = 300)
```

## Fig6A top milk nutrients vs clusters

```{r message=FALSE}

# 1421 days

milkCluster_1421 <- milkMeta %>%
  filter(timepoint == "1421") %>%
  left_join(row_annotation_idbs, by = "idbs")  %>% # Perform the join
  select(idbs, code, Cluster, "FAT", "PROTEIN", "CARBOHYDRATE", "Kcal.L", "FGF.21", "FSH", "Insulin", "LH", "Leptin", "Calprotectin", "IgA", "Na", "Mg", "P.", "K.", "Ca", "Cr", "Fe", "Cu", "Zn", "Mo", "As", "Mn", "Se", "Ribo", "FMN", "FAD", "B2", "NAM", "NAD", "NMN", "NR", "B3", "Nufa", "PA", "PL", "PM", "PN", "PLP", "B6", "Bio", "TRP", "TPP", "TMP", "T", "B1", "B12", "g.tocopherol", "a.tocopherol", "vitamin.A")
head(milkCluster_1421)


# Step 1: Log-transform the nutrient values
# Step 1: Log-transform the nutrient values
# Create a list of nutrients (columns except for 'idbs' and 'Cluster')
nutrients <- colnames(milkCluster_1421)[!colnames(milkCluster_1421) %in% c("idbs", "code", "Cluster")]

# Apply log transformation to the nutrient columns
milkCluster_1421_log <- milkCluster_1421 %>%
  mutate(across(all_of(nutrients), ~ log(. + 1)))  # Log transform each nutrient with +1 to avoid log(0)

# Function to fit the model and extract coefficients and p-values for the three-group comparison (C1, C2, C3)
fit_model <- function(nutrient) {
  # Fit a linear model treating Cluster as a factor variable (factor comparison between C1, C2, C3)
  lm_result <- lm(as.formula(paste(nutrient, "~ Cluster + code" )), data = milkCluster_1421_log)
  
  # Extract the coefficients for each cluster
  coef_vals <- coef(lm_result)
  
  # C2 vs C1 coefficient is coef_vals["ClusterC2"] (the effect of C2 relative to C1)
  # C3 vs C1 coefficient is coef_vals["ClusterC3"] (the effect of C3 relative to C1)
  # C3 vs C2 coefficient is the difference between the coefficients for C3 and C2
  coef_val_C2vsC1 <- coef_vals["ClusterC2"]
  coef_val_C3vsC1 <- coef_vals["ClusterC3"]
  coef_val_C3vsC2 <- coef_val_C3vsC1 - coef_val_C2vsC1  # Coefficient for C3 vs C2
  
  # Extract the overall p-value for the Cluster effect (testing if Cluster has any effect on the nutrient)
  anova_result <- anova(lm_result)  # Get the ANOVA table
  p_val <- anova_result[["Pr(>F)"]][1]  # Extract the p-value for the overall Cluster effect
  
  return(c(coef_val_C2vsC1, coef_val_C3vsC1, coef_val_C3vsC2, p_val))  # Return the coefficients and p-value
}

# Apply the function to all nutrients
results <- sapply(nutrients, fit_model)

# Convert results into a data frame
results_df <- as.data.frame(t(results))  # Transpose the result to match the format
colnames(results_df) <- c("Coef_C2vsC1", "Coef_C3vsC1", "Coef_C3vsC2", "p_value_Cluster")  # Set column names for coefficients and p-values
results_df$Nutrient <- nutrients  # Add the Nutrient column

# Step 2: Apply BH FDR correction to p-values for each comparison
results_df$p_value_Cluster_adj <- p.adjust(results_df$p_value_Cluster, method = "BH")

# Step 3: Add significance stars based on the adjusted p-values
results_df$Significance <- case_when(
  results_df$p_value_Cluster_adj <= 0.001 ~ "***",
  results_df$p_value_Cluster_adj <= 0.01 ~ "**",
  results_df$p_value_Cluster_adj <= 0.05 ~ "*",
  results_df$p_value_Cluster_adj <= 0.1 ~ ".",
  results_df$p_value_Cluster <= 0.05 ~ "~",
  TRUE ~ ""
)

# Step 4: Normalize the coefficients to fit within the range [-1, 1] by rescaling
results_df_1421 <- results_df %>%
  mutate(across(starts_with("Coef"), ~ scale(.)))  # Standardize coefficients

# Check the structure of the results_df
head(results_df_1421)

## pn12

milkCluster_pn12 <- milkMeta %>%
  filter(timepoint == "pn12") %>%
  left_join(row_annotation_idbs, by = "idbs")  %>% # Perform the join
  select(idbs, code, Cluster, "FAT", "PROTEIN", "CARBOHYDRATE", "Kcal.L", "FGF.21", "FSH", "Insulin", "LH", "Leptin", "Calprotectin", "IgA", "Na", "Mg", "P.", "K.", "Ca", "Cr", "Fe", "Cu", "Zn", "Mo", "As", "Mn", "Se", "Ribo", "FMN", "FAD", "B2", "NAM", "NAD", "NMN", "NR", "B3", "Nufa", "PA", "PL", "PM", "PN", "PLP", "B6", "Bio", "TRP", "TPP", "TMP", "T", "B1", "B12", "g.tocopherol", "a.tocopherol", "vitamin.A")
head(milkCluster_pn12)


# Step 1: Log-transform the nutrient values
# Step 1: Log-transform the nutrient values
# Create a list of nutrients (columns except for 'idbs' and 'Cluster')
nutrients <- colnames(milkCluster_pn12)[!colnames(milkCluster_pn12) %in% c("idbs", "code", "Cluster")]

# Apply log transformation to the nutrient columns
milkCluster_pn12_log <- milkCluster_pn12 %>%
  mutate(across(all_of(nutrients), ~ log(. + 1)))  # Log transform each nutrient with +1 to avoid log(0)

# Function to fit the model and extract coefficients and p-values for the three-group comparison (C1, C2, C3)
fit_model <- function(nutrient) {
  # Fit a linear model treating Cluster as a factor variable (factor comparison between C1, C2, C3)
  lm_result <- lm(as.formula(paste(nutrient, "~ Cluster + code")), data = milkCluster_pn12_log)
  
  # Extract the coefficients for each cluster
  coef_vals <- coef(lm_result)
  
  # C2 vs C1 coefficient is coef_vals["ClusterC2"] (the effect of C2 relative to C1)
  # C3 vs C1 coefficient is coef_vals["ClusterC3"] (the effect of C3 relative to C1)
  # C3 vs C2 coefficient is the difference between the coefficients for C3 and C2
  coef_val_C2vsC1 <- coef_vals["ClusterC2"]
  coef_val_C3vsC1 <- coef_vals["ClusterC3"]
  coef_val_C3vsC2 <- coef_val_C3vsC1 - coef_val_C2vsC1  # Coefficient for C3 vs C2
  
  # Extract the overall p-value for the Cluster effect (testing if Cluster has any effect on the nutrient)
  anova_result <- anova(lm_result)  # Get the ANOVA table
  p_val <- anova_result[["Pr(>F)"]][1]  # Extract the p-value for the overall Cluster effect
  
  return(c(coef_val_C2vsC1, coef_val_C3vsC1, coef_val_C3vsC2, p_val))  # Return the coefficients and p-value
}

# Apply the function to all nutrients
results <- sapply(nutrients, fit_model)

# Convert results into a data frame
results_df <- as.data.frame(t(results))  # Transpose the result to match the format
colnames(results_df) <- c("Coef_C2vsC1", "Coef_C3vsC1", "Coef_C3vsC2", "p_value_Cluster")  # Set column names for coefficients and p-values
results_df$Nutrient <- nutrients  # Add the Nutrient column

# Step 2: Apply BH FDR correction to p-values for each comparison
results_df$p_value_Cluster_adj <- p.adjust(results_df$p_value_Cluster, method = "BH")

# Step 3: Add significance stars based on the adjusted p-values
results_df$Significance <- case_when(
  results_df$p_value_Cluster_adj <= 0.001 ~ "***",
  results_df$p_value_Cluster_adj <= 0.01 ~ "**",
  results_df$p_value_Cluster_adj <= 0.05 ~ "*",
  results_df$p_value_Cluster_adj <= 0.1 ~ ".",
  results_df$p_value_Cluster <= 0.05 ~ "~",
  TRUE ~ ""
)

# Step 4: Normalize the coefficients to fit within the range [-1, 1] by rescaling
results_df_pn12 <- results_df %>%
  mutate(across(starts_with("Coef"), ~ scale(.)))  # Standardize coefficients

# Check the structure of the results_df
head(results_df_pn12)


## pn34

milkCluster_pn34 <- milkMeta %>%
  filter(timepoint == "pn34") %>%
  left_join(row_annotation_idbs, by = "idbs")  %>% # Perform the join
  select(idbs, code, Cluster, "FAT", "PROTEIN", "CARBOHYDRATE", "Kcal.L", "FGF.21", "FSH", "Insulin", "LH", "Leptin", "Calprotectin", "IgA", "Na", "Mg", "P.", "K.", "Ca", "Cr", "Fe", "Cu", "Zn", "Mo", "As", "Mn", "Se", "Ribo", "FMN", "FAD", "B2", "NAM", "NAD", "NMN", "NR", "B3", "Nufa", "PA", "PL", "PM", "PN", "PLP", "B6", "Bio", "TRP", "TPP", "TMP", "T", "B1", "B12", "g.tocopherol", "a.tocopherol", "vitamin.A")
head(milkCluster_pn34)


# Step 1: Log-transform the nutrient values
# Step 1: Log-transform the nutrient values
# Create a list of nutrients (columns except for 'idbs' and 'Cluster')
nutrients <- colnames(milkCluster_pn34)[!colnames(milkCluster_pn34) %in% c("idbs", "code", "Cluster")]

# Apply log transformation to the nutrient columns
milkCluster_pn34_log <- milkCluster_pn34 %>%
  mutate(across(all_of(nutrients), ~ log(. + 1)))  # Log transform each nutrient with +1 to avoid log(0)

# Function to fit the model and extract coefficients and p-values for the three-group comparison (C1, C2, C3)
fit_model <- function(nutrient) {
  # Fit a linear model treating Cluster as a factor variable (factor comparison between C1, C2, C3)
  lm_result <- lm(as.formula(paste(nutrient, "~ Cluster + code")), data = milkCluster_pn34_log)
  
  # Extract the coefficients for each cluster
  coef_vals <- coef(lm_result)
  
  # C2 vs C1 coefficient is coef_vals["ClusterC2"] (the effect of C2 relative to C1)
  # C3 vs C1 coefficient is coef_vals["ClusterC3"] (the effect of C3 relative to C1)
  # C3 vs C2 coefficient is the difference between the coefficients for C3 and C2
  coef_val_C2vsC1 <- coef_vals["ClusterC2"]
  coef_val_C3vsC1 <- coef_vals["ClusterC3"]
  coef_val_C3vsC2 <- coef_val_C3vsC1 - coef_val_C2vsC1  # Coefficient for C3 vs C2
  
  # Extract the overall p-value for the Cluster effect (testing if Cluster has any effect on the nutrient)
  anova_result <- anova(lm_result)  # Get the ANOVA table
  p_val <- anova_result[["Pr(>F)"]][1]  # Extract the p-value for the overall Cluster effect
  
  return(c(coef_val_C2vsC1, coef_val_C3vsC1, coef_val_C3vsC2, p_val))  # Return the coefficients and p-value
}

# Apply the function to all nutrients
results <- sapply(nutrients, fit_model)

# Convert results into a data frame
results_df <- as.data.frame(t(results))  # Transpose the result to match the format
colnames(results_df) <- c("Coef_C2vsC1", "Coef_C3vsC1", "Coef_C3vsC2", "p_value_Cluster")  # Set column names for coefficients and p-values
results_df$Nutrient <- nutrients  # Add the Nutrient column

# Step 2: Apply BH FDR correction to p-values for each comparison
results_df$p_value_Cluster_adj <- p.adjust(results_df$p_value_Cluster, method = "BH")

# Step 3: Add significance stars based on the adjusted p-values
results_df$Significance <- case_when(
  results_df$p_value_Cluster_adj <= 0.001 ~ "***",
  results_df$p_value_Cluster_adj <= 0.01 ~ "**",
  results_df$p_value_Cluster_adj <= 0.05 ~ "*",
  results_df$p_value_Cluster_adj <= 0.1 ~ ".",
  results_df$p_value_Cluster <= 0.05 ~ "~",
  TRUE ~ ""
)

# Step 4: Normalize the coefficients to fit within the range [-1, 1] by rescaling
results_df_pn34 <- results_df %>%
  mutate(across(starts_with("Coef"), ~ scale(.)))  # Standardize coefficients

# Check the structure of the results_df
head(results_df_pn34)

## Combined for plot

result_df <- results_df_1421 %>%
  select(Nutrient, Significance) %>%
  left_join(results_df_pn12 %>% select(Nutrient, Significance), by = "Nutrient") %>%
  left_join(results_df_pn34 %>% select(Nutrient, Significance), by = "Nutrient") %>%
  dplyr::mutate(d1421 = Significance.x) %>%
  dplyr::mutate(pn12 = Significance.y) %>%
  dplyr::mutate(pn34 = Significance) %>%
  select(-Significance.x, -Significance.y, -Significance)

nutrient_order <- c("FAT", "PROTEIN", "CARBOHYDRATE", "Kcal.L", "FGF.21", "FSH", "Insulin", "LH", "Leptin", "Calprotectin", "IgA", "Na", "Mg", "P.", "K.", "Ca", "Cr", "Fe", "Cu", "Zn", "Mo", "As", "Mn", "Se", "Ribo", "FMN", "FAD", "B2", "NAM", "NAD", "NMN", "NR", "B3", "Nufa", "PA", "PL", "PM", "PN", "PLP", "B6", "Bio", "TRP", "TPP",  "TMP", "T", "B1", "B12", "g.tocopherol", "a.tocopherol", "vitamin.A")
# Assuming 'result_df' is your dataset, we will pivot it to long format
result_long <- result_df %>%
  mutate(Nutrient = factor(Nutrient, levels = nutrient_order)) %>%
  pivot_longer(cols = c("d1421", "pn12", "pn34"), 
               names_to = "Significance_Type", 
               values_to = "Significance") 

# Plot the heatmap using ggplot2
milkClusterHeatmap <- ggplot(result_long, aes(x = Nutrient, y = Significance_Type, fill = Significance)) +
  geom_tile(color = "black", width = 0.9, height = 0.9) +  # Create heatmap tiles
  geom_text(aes(label = Significance), color = "darkred", size = 6) +  # Add significance labels inside cells
  scale_fill_manual(values = c("white", "plum3", "#483D8B", "skyblue")) +  # Customize the fill color
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        axis.text.y = element_text(size = 10), 
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        ) +
  labs(title = "Heatmap of Significance for Nutrients", 
       x = "Nutrient", 
       y = "Significance Type")
milkClusterHeatmap

#svglite::svglite(
#  filename="./forISRHML/milkClusterHeatmap_code2.svg",
#  width=10, height=2.83
#  )
#milkClusterHeatmap
#dev.off()

```

## Fig6A bottom infant gut pn12 vs nutrient pn34

```{r message=FALSE}

milkMeta <- vitbMeta %>%
  left_join(minMeta %>% dplyr::select(idbs, timepoint, Na, Mg, P., K., Ca, Cr, Fe, Cu, Zn, Mo, As, Mn, Se), by = c("idbs", "timepoint")) %>% 
  left_join(bioMeta %>% dplyr::select(idbs, timepoint, FGF.21, FSH, Insulin, LH, Leptin, Calprotectin, IgA), by = c("idbs", "timepoint")) %>%
  left_join(marMeta %>% dplyr::select(idbs, timepoint, FAT, PROTEIN, CARBOHYDRATE, Kcal.L), by = c("idbs", "timepoint")) %>%
  left_join(fvitMeta %>% dplyr::select(idbs, timepoint, "g.tocopherol", "a.tocopherol", "vitamin.A"), by = c("idbs", "timepoint"))

infant_species_pn12 <- infant_species %>%
  filter(timepoint == "pn12") %>%
  filter(Abundance >= 0.05) %>%
  select(idbs, species, Abundance) %>%
  pivot_wider(names_from = species, values_from = Abundance) %>%
  dplyr::select(idbs, where(~ mean(is.na(.)) <= 0.95))

infant_species_pn12$idbs <- as.character(infant_species_pn12$idbs )

milk_pn34 <- milkMeta %>%
  filter(timepoint == "pn34") %>%
  select(idbs, "FAT", "PROTEIN", "CARBOHYDRATE", "Kcal.L", "FGF.21", "FSH", "Insulin", "LH", "Leptin", "Calprotectin", "IgA", "Na", "Mg", "P.", "K.", "Ca", "Cr", "Fe", "Cu", "Zn", "Mo", "As", "Mn", "Se", "Ribo", "FMN", "FAD", "B2", "NAM", "NAD", "NMN", "NR", "B3", "Nufa", "PA", "PL", "PM", "PN", "PLP", "B6", "Bio", "TRP", "TPP", "TMP", "T", "B1", "B12", "g.tocopherol", "a.tocopherol", "vitamin.A")

infant_milk_pn12milkpn34 <- milk_pn34 %>%
  left_join(infant_species_pn12, by = "idbs") %>%
  #left_join(metadata %>% dplyr::select(idbs, code, GWG, hh_child5)) %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) %>% 
  filter(!is.na(code)) %>%
  select(-idbs) 


# Step 2: Perform linear regression for each species and HMO
results_list <- lapply(
  names(infant_milk_pn12milkpn34)[grepl("FAT|PROTEIN|CARBOHYDRATE|Kcal.L|FGF.21|FSH|Insulin|LH|Leptin|Calprotectin|IgA|Na|Mg|P.|K.|Ca|Cr|Fe|Cu|Zn|Mo|As|Mn|Se|Ribo|FMN|FAD|B2|NAM|NAD|NMN|NR|B3|Nufa|PA|PL|PM|PN|PLP|B6|Bio|TRP|TPP|TMP|T|B1|B12|g.tocopherol|a.tocopherol|vitamin.A", 
                                  names(infant_milk_pn12milkpn34))], 
  function(hmo_column) {
    
    lapply(
      names(infant_milk_pn12milkpn34)[grepl("Bifidobacterium infantis|Escherichia coli|Bacteroides fragilis_A|Klebsiella pneumoniae|Prevotella sp900544825|Streptococcus sp000187445|Parolsenella uli_B|Bifidobacterium longum|Prevotella sp900551985|Veillonella_A sp000431435|Bifidobacterium bifidum", 
                                           names(infant_milk_pn12milkpn34))], 
      function(species_column) {
        
        # Log-transform species and HMO data
        log_species <- log1p(infant_milk_pn12milkpn34[[species_column]])
        log_hmo <- log1p(infant_milk_pn12milkpn34[[hmo_column]])
        confounder_code <- infant_milk_pn12milkpn34$code  # Factor variable

        # Remove NAs and ensure correct alignment
        valid_idx <- complete.cases(log_species, log_hmo, confounder_code)
        log_species <- log_species[valid_idx]
        log_hmo <- log_hmo[valid_idx]
        confounder_code <- confounder_code[valid_idx]  # Keep only valid indices
        
        # Skip if not enough data points
        if (length(log_species) < 3 || length(unique(log_species)) < 2) {
          message(paste("Skipping:", species_column, "due to insufficient data."))
          return(NULL)
        }
        
        if (length(log_hmo) < 3 || length(unique(log_hmo)) < 2) {
          message(paste("Skipping:", hmo_column, "due to insufficient data."))
          return(NULL)
        }
        
        # Perform linear regression with confounder
        lm_result <- tryCatch({
          lm(log_hmo ~ log_species + confounder_code)
        }, error = function(e) {
          message(paste("Skipping:", species_column, "vs", hmo_column, "due to regression failure."))
          return(NULL)
        })
        
        # Check if model has at least 2 coefficients
        if (!is.null(lm_result) && length(coef(lm_result)) > 2) {
          coef_val <- coef(lm_result)[2]  # Coefficient of the HMO
          p_val <- summary(lm_result)$coefficients[2, 4]  # p-value for HMO
        } else {
          coef_val <- NA
          p_val <- NA
        }
        
        # Return results as a data frame
        tibble(species = species_column, HMO = hmo_column, coefficient = coef_val, p_value = p_val)
      }
    )
  }
)

# Flatten the list into a single data frame
results_df <- bind_rows(unlist(results_list, recursive = TRUE))

# Step 1: Convert the dataframe to a matrix
results_matrix <- as.matrix(results_df)

# Step 2: Reshape the matrix into a new matrix where each row has 4 columns
reshaped_matrix <- matrix(results_matrix, ncol = 4, byrow = TRUE)

# Step 3: Convert the reshaped matrix back into a dataframe
results_table <- reshaped_matrix %>%
  as.data.frame() %>%
  filter(!V2 %in% c("Klebsiella pneumoniae", "Prevotella sp900544825", "Parolsenella uli_B", "Prevotella sp900551985"))

# Optionally, assign column names (optional step)
colnames(results_table) <- c("Species", "HMO", "Coefficient", "P_value")

# View the resulting table
print(results_table)

# Step 3: FDR correction of p-values using BH method
results_adj <- results_table %>%
  dplyr::mutate(adj_p_value = p.adjust(P_value, method = "BH"))

# Step 4: Define significance based on adjusted p-values
results_adj <- results_adj %>%
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      P_value <= 0.05 & adj_p_value > 0.1 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )
# Check the output
head(results_adj)

results_adj$Coefficient <- as.numeric(results_adj$Coefficient)
hmo_order <- c("FAT", "PROTEIN", "CARBOHYDRATE", "Kcal.L", "FGF.21", "FSH", "Insulin", "LH", "Leptin", "Calprotectin", "IgA", "Na", "Mg", "P.", "K.", "Ca", "Cr", "Fe", "Cu", "Zn", "Mo", "As", "Mn", "Se", "Ribo", "FMN", "FAD", "B2", "NAM", "NAD", "NMN", "NR", "B3", "Nufa", "PA", "PL", "PM", "PN", "PLP", "B6", "Bio", "TRP", "TPP", "TMP", "T", "B1", "B12", "g.tocopherol", "a.tocopherol", "vitamin.A")
results_adj$HMO <- factor(results_adj$HMO, levels = hmo_order)

max_coef <- max(abs(results_adj$Coefficient), na.rm = TRUE)

# Plot the heatmap using ggplot2
infant_milk_pn12milkpn34_Heatmap <- ggplot(results_adj, aes(x = HMO, y = Species, fill = Coefficient)) +
  geom_tile(color = "white", width = 0.9, height = 0.9) +  # Create heatmap tiles
  geom_text(aes(label = significance), color = "darkred", size = 6) +  # Add significance labels inside cells
  scale_fill_gradientn(
    colours = divergingx_hcl(5, palette = "RdBu"),  # perceptually uniform
    limits = c(-20,20),
    name = "Coefficient"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        axis.text.y = element_text(size = 10), 
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        ) +
  labs(
       x = "Milk at 3-4 months", 
       y = "Infant gut at 1-2 months")
infant_milk_pn12milkpn34_Heatmap

#ggsave("./forISRHML/infant_milk_pn12milkpn34_Heatmap3.svg", infant_milk_pn12milkpn34_Heatmap, width = 14, height = 5, dpi = 300)

```

## FigS7 infant gut pn12 vs nutrients pn12

```{r}

milk_pn12 <- milkMeta %>%
  filter(timepoint == "pn12") %>%
  select(idbs, "FAT", "PROTEIN", "CARBOHYDRATE", "Kcal.L", "FGF.21", "FSH", "Insulin", "LH", "Leptin", "Calprotectin", "IgA", "Na", "Mg", "P.", "K.", "Ca", "Cr", "Fe", "Cu", "Zn", "Mo", "As", "Mn", "Se", "Ribo", "FMN", "FAD", "B2", "NAM", "NAD", "NMN", "NR", "B3", "Nufa", "PA", "PL", "PM", "PN", "PLP", "B6", "Bio", "TRP", "TPP", "TMP", "T", "B1", "B12", "g.tocopherol", "a.tocopherol", "vitamin.A")

infant_milk_pn12milkpn12 <- milk_pn12 %>%
  left_join(infant_species_pn12, by = "idbs") %>%
  #left_join(metadata %>% dplyr::select(idbs, code, GWG, hh_child5)) %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) %>% 
  filter(!is.na(code)) %>%
  select(-idbs) 


# Step 2: Perform linear regression for each species and HMO
results_list <- lapply(
  names(infant_milk_pn12milkpn12)[grepl("FAT|PROTEIN|CARBOHYDRATE|Kcal.L|FGF.21|FSH|Insulin|LH|Leptin|Calprotectin|IgA|Na|Mg|P.|K.|Ca|Cr|Fe|Cu|Zn|Mo|As|Mn|Se|Ribo|FMN|FAD|B2|NAM|NAD|NMN|NR|B3|Nufa|PA|PL|PM|PN|PLP|B6|Bio|TRP|TPP|TMP|T|B1|B12|g.tocopherol|a.tocopherol|vitamin.A", 
                                  names(infant_milk_pn12milkpn12))], 
  function(hmo_column) {
    
    lapply(
      names(infant_milk_pn12milkpn12)[grepl("Bifidobacterium infantis|Escherichia coli|Bacteroides fragilis_A|Klebsiella pneumoniae|Prevotella sp900544825|Streptococcus sp000187445|Parolsenella uli_B|Bifidobacterium longum|Prevotella sp900551985|Veillonella_A sp000431435|Bifidobacterium bifidum", 
                                           names(infant_milk_pn12milkpn12))], 
      function(species_column) {
        
        # Log-transform species and HMO data
        log_species <- log1p(infant_milk_pn12milkpn12[[species_column]])
        log_hmo <- log1p(infant_milk_pn12milkpn12[[hmo_column]])
        confounder_code <- infant_milk_pn12milkpn12$code  # Factor variable

        # Remove NAs and ensure correct alignment
        valid_idx <- complete.cases(log_species, log_hmo, confounder_code)
        log_species <- log_species[valid_idx]
        log_hmo <- log_hmo[valid_idx]
        confounder_code <- confounder_code[valid_idx]  # Keep only valid indices
        
        # Skip if not enough data points
        if (length(log_species) < 3 || length(unique(log_species)) < 2) {
          message(paste("Skipping:", species_column, "due to insufficient data."))
          return(NULL)
        }
        
        if (length(log_hmo) < 3 || length(unique(log_hmo)) < 2) {
          message(paste("Skipping:", hmo_column, "due to insufficient data."))
          return(NULL)
        }
        
        # Perform linear regression with confounder
        lm_result <- tryCatch({
          lm(log_hmo ~ log_species + confounder_code)
        }, error = function(e) {
          message(paste("Skipping:", species_column, "vs", hmo_column, "due to regression failure."))
          return(NULL)
        })
        
        # Check if model has at least 2 coefficients
        if (!is.null(lm_result) && length(coef(lm_result)) > 2) {
          coef_val <- coef(lm_result)[2]  # Coefficient of the HMO
          p_val <- summary(lm_result)$coefficients[2, 4]  # p-value for HMO
        } else {
          coef_val <- NA
          p_val <- NA
        }
        
        # Return results as a data frame
        tibble(species = species_column, HMO = hmo_column, coefficient = coef_val, p_value = p_val)
      }
    )
  }
)

# Flatten the list into a single data frame
results_df <- bind_rows(unlist(results_list, recursive = TRUE))

# Step 1: Convert the dataframe to a matrix
results_matrix <- as.matrix(results_df)

# Step 2: Reshape the matrix into a new matrix where each row has 4 columns
reshaped_matrix <- matrix(results_matrix, ncol = 4, byrow = TRUE)

# Step 3: Convert the reshaped matrix back into a dataframe
results_table <- reshaped_matrix %>%
  as.data.frame() %>%
  filter(!V2 %in% c("Klebsiella pneumoniae", "Prevotella sp900544825", "Parolsenella uli_B", "Prevotella sp900551985"))

# Optionally, assign column names (optional step)
colnames(results_table) <- c("Species", "HMO", "Coefficient", "P_value")

# View the resulting table
print(results_table)

# Step 3: FDR correction of p-values using BH method
results_adj <- results_table %>%
  dplyr::mutate(adj_p_value = p.adjust(P_value, method = "BH"))

# Step 4: Define significance based on adjusted p-values
results_adj <- results_adj %>%
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      P_value <= 0.05 & adj_p_value > 0.1 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )
# Check the output
head(results_adj)

results_adj$Coefficient <- as.numeric(results_adj$Coefficient)
hmo_order <- c("FAT", "PROTEIN", "CARBOHYDRATE", "Kcal.L", "FGF.21", "FSH", "Insulin", "LH", "Leptin", "Calprotectin", "IgA", "Na", "Mg", "P.", "K.", "Ca", "Cr", "Fe", "Cu", "Zn", "Mo", "As", "Mn", "Se", "Ribo", "FMN", "FAD", "B2", "NAM", "NAD", "NMN", "NR", "B3", "Nufa", "PA", "PL", "PM", "PN", "PLP", "B6", "Bio", "TRP", "TPP", "TMP", "T", "B1", "B12", "g.tocopherol", "a.tocopherol", "vitamin.A")
results_adj$HMO <- factor(results_adj$HMO, levels = hmo_order)

max_coef <- max(abs(results_adj$Coefficient), na.rm = TRUE)

# Plot the heatmap using ggplot2
infant_milk_pn12milkpn12_Heatmap <- ggplot(results_adj, aes(x = HMO, y = Species, fill = Coefficient)) +
  geom_tile(color = "white", width = 0.9, height = 0.9) +  # Create heatmap tiles
  geom_text(aes(label = significance), color = "black", size = 6) +  # Add significance labels inside cells
  scale_fill_gradientn(
    colours = divergingx_hcl(5, palette = "RdBu"),  # perceptually uniform
    #limits = c(-15,15),
    name = "Coefficient"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        axis.text.y = element_text(size = 10), 
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        ) +
  labs(
       x = "Milk at 1-2 months", 
       y = "Infant gut at 1-2 months")
infant_milk_pn12milkpn12_Heatmap

#ggsave("./forISRHML/Jun2_infant_milk_pn12milkpn12_Heatmap3.svg", infant_milk_pn12milkpn12_Heatmap, width = 14, height = 5, dpi = 300)

```

## FigS8 infant gut pn56 vs nutrients pn34

```{r}

milk_pn34 <- milkMeta %>%
  filter(timepoint == "pn34") %>%
  select(idbs, "FAT", "PROTEIN", "CARBOHYDRATE", "Kcal.L", "FGF.21", "FSH", "Insulin", "LH", "Leptin", "Calprotectin", "IgA", "Na", "Mg", "P.", "K.", "Ca", "Cr", "Fe", "Cu", "Zn", "Mo", "As", "Mn", "Se", "Ribo", "FMN", "FAD", "B2", "NAM", "NAD", "NMN", "NR", "B3", "Nufa", "PA", "PL", "PM", "PN", "PLP", "B6", "Bio", "TRP", "TPP", "TMP", "T", "B1", "B12", "g.tocopherol", "a.tocopherol", "vitamin.A")

infant_milk_pn56milkpn34 <- milk_pn34 %>%
  left_join(infant_species_pn56, by = "idbs") %>%
  #left_join(metadata %>% dplyr::select(idbs, code, GWG, hh_child5)) %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) %>% 
  filter(!is.na(code)) %>%
  select(-idbs) 


# Step 2: Perform linear regression for each species and HMO
results_list <- lapply(
  names(infant_milk_pn56milkpn34)[grepl("FAT|PROTEIN|CARBOHYDRATE|Kcal.L|FGF.21|FSH|Insulin|LH|Leptin|Calprotectin|IgA|Na|Mg|P.|K.|Ca|Cr|Fe|Cu|Zn|Mo|As|Mn|Se|Ribo|FMN|FAD|B2|NAM|NAD|NMN|NR|B3|Nufa|PA|PL|PM|PN|PLP|B6|Bio|TRP|TPP|TMP|T|B1|B12|g.tocopherol|a.tocopherol|vitamin.A", 
                                  names(infant_milk_pn56milkpn34))], 
  function(hmo_column) {
    
    lapply(
      names(infant_milk_pn56milkpn34)[grepl("Escherichia coli|Bifidobacterium infantis|Parolsenella uli_B|Bacteroides fragilis|Bacteroides fragilis_A|Veillonella_A sp000431435|Bifidobacterium bifidum|Phocaeicola dorei|Campylobacter_D jejuni|Prevotella sp900544825|Bacteroides thetaiotaomicron|Bifidobacterium longum", 
                                           names(infant_milk_pn56milkpn34))], 
      function(species_column) {
        
        # Log-transform species and HMO data
        log_species <- log1p(infant_milk_pn56milkpn34[[species_column]])
        log_hmo <- log1p(infant_milk_pn56milkpn34[[hmo_column]])
        confounder_code <- infant_milk_pn56milkpn34$code  # Factor variable

        # Remove NAs and ensure correct alignment
        valid_idx <- complete.cases(log_species, log_hmo, confounder_code)
        log_species <- log_species[valid_idx]
        log_hmo <- log_hmo[valid_idx]
        confounder_code <- confounder_code[valid_idx]  # Keep only valid indices
        
        # Skip if not enough data points
        if (length(log_species) < 3 || length(unique(log_species)) < 2) {
          message(paste("Skipping:", species_column, "due to insufficient data."))
          return(NULL)
        }
        
        if (length(log_hmo) < 3 || length(unique(log_hmo)) < 2) {
          message(paste("Skipping:", hmo_column, "due to insufficient data."))
          return(NULL)
        }
        
        # Perform linear regression with confounder
        lm_result <- tryCatch({
          lm(log_species ~ log_hmo + confounder_code)
        }, error = function(e) {
          message(paste("Skipping:", species_column, "vs", hmo_column, "due to regression failure."))
          return(NULL)
        })
        
        # Check if model has at least 2 coefficients
        if (!is.null(lm_result) && length(coef(lm_result)) > 2) {
          coef_val <- coef(lm_result)[2]  # Coefficient of the HMO
          p_val <- summary(lm_result)$coefficients[2, 4]  # p-value for HMO
        } else {
          coef_val <- NA
          p_val <- NA
        }
        
        # Return results as a data frame
        tibble(species = species_column, HMO = hmo_column, coefficient = coef_val, p_value = p_val)
      }
    )
  }
)

# Flatten the list into a single data frame
results_df <- bind_rows(unlist(results_list, recursive = TRUE))

# Step 1: Convert the dataframe to a matrix
results_matrix <- as.matrix(results_df)

# Step 2: Reshape the matrix into a new matrix where each row has 4 columns
reshaped_matrix <- matrix(results_matrix, ncol = 4, byrow = TRUE)

# Step 3: Convert the reshaped matrix back into a dataframe
results_table <- reshaped_matrix %>%
  as.data.frame() %>%
  filter(!V2 %in% c("Klebsiella pneumoniae", "Prevotella sp900544825", "Parolsenella uli_B", "Prevotella sp900551985"))

# Optionally, assign column names (optional step)
colnames(results_table) <- c("Species", "HMO", "Coefficient", "P_value")

# View the resulting table
print(results_table)

# Step 3: FDR correction of p-values using BH method
results_adj <- results_table %>%
  dplyr::mutate(adj_p_value = p.adjust(P_value, method = "BH"))

# Step 4: Define significance based on adjusted p-values
results_adj <- results_adj %>%
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      P_value <= 0.05 & adj_p_value > 0.1 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  ) %>%
  filter(!is.na(HMO))
# Check the output
head(results_adj)

results_adj$Coefficient <- as.numeric(results_adj$Coefficient)
hmo_order <- c("FAT", "PROTEIN", "CARBOHYDRATE", "Kcal.L", "FGF.21", "FSH", "Insulin", "LH", "Leptin", "Calprotectin", "IgA", "Na", "Mg", "P.", "K.", "Ca", "Cr", "Fe", "Cu", "Zn", "Mo", "As", "Mn", "Se", "Ribo", "FMN", "FAD", "B2", "NAM", "NAD", "NMN", "NR", "B3", "Nufa", "PA", "PL", "PM", "PN", "PLP", "B6", "Bio", "TRP", "TPP", "TMP", "T", "B1", "B12", "g.tocopherol", "a.tocopherol", "vitamin.A")
results_adj$HMO <- factor(results_adj$HMO, levels = hmo_order)
results_adj <- results_adj %>%
  filter(!is.na(HMO))

# Plot the heatmap using ggplot2
infant_milk_pn56milkpn34_Heatmap <- ggplot(results_adj, aes(x = HMO, y = Species, fill = Coefficient)) +
  geom_tile(color = "black", width = 0.9, height = 0.9) +  # Create heatmap tiles
  geom_text(aes(label = significance), color = "darkred", size = 6) +  # Add significance labels inside cells
    scale_fill_gradientn(
    colours = divergingx_hcl(5, palette = "RdBu"),  # perceptually uniform
    limits = c(-0.5,0.5),
    name = "Coefficient"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        axis.text.y = element_text(size = 10), 
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        ) +
  labs(
       x = "Milk at 3-4 months", 
       y = "Infant gut at 1-2 months")
infant_milk_pn56milkpn34_Heatmap

#ggsave("./forISRHML/Jun2_infant_milk_pn56milkpn34_Heatmap.svg", infant_milk_pn56milkpn34_Heatmap, width = 14, height = 5, dpi = 300)

```

## Fig6C top milk metabolites vs clusters

```{r}

metabolite_1421 <- metab_raw %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  filter(timepoint=="1421") %>%
  dplyr::select(-timepoint)

metabolite_pn12 <- metab_raw %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  filter(timepoint=="pn12") %>%
  dplyr::select(-timepoint)

metabolite_pn34 <- metab_raw %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  filter(timepoint=="pn34") %>%
  dplyr::select(-timepoint)

## metabolite 1421

metaboliteCluster_1421 <- metabolite_1421 %>%
  left_join(row_annotation_idbs, by = "idbs") %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) 


# Step 1: Log-transform the nutrient values
# Step 1: Log-transform the nutrient values
# Create a list of nutrients (columns except for 'idbs' and 'Cluster')
nutrients <- colnames(metaboliteCluster_1421)[!colnames(metaboliteCluster_1421) %in% c("idbs", "code", "Cluster")]

# Apply log transformation to the nutrient columns
metaboliteCluster_1421_log <- metaboliteCluster_1421 %>%
  mutate(across(all_of(nutrients), ~ log(. + 1)))  # Log transform each nutrient with +1 to avoid log(0)

# Function to fit the model and extract coefficients and p-values for the three-group comparison (C1, C2, C3)
fit_model <- function(nutrient) {
  # Fit a linear model treating Cluster as a factor variable (factor comparison between C1, C2, C3)
  lm_result <- lm(as.formula(paste(nutrient, "~ Cluster + code")), data = metaboliteCluster_1421_log)
  
  # Extract the coefficients for each cluster
  coef_vals <- coef(lm_result)
  
  # C2 vs C1 coefficient is coef_vals["ClusterC2"] (the effect of C2 relative to C1)
  # C3 vs C1 coefficient is coef_vals["ClusterC3"] (the effect of C3 relative to C1)
  # C3 vs C2 coefficient is the difference between the coefficients for C3 and C2
  coef_val_C2vsC1 <- coef_vals["ClusterC2"]
  coef_val_C3vsC1 <- coef_vals["ClusterC3"]
  coef_val_C3vsC2 <- coef_val_C3vsC1 - coef_val_C2vsC1  # Coefficient for C3 vs C2
  
  # Extract the overall p-value for the Cluster effect (testing if Cluster has any effect on the nutrient)
  anova_result <- anova(lm_result)  # Get the ANOVA table
  p_val <- anova_result[["Pr(>F)"]][1]  # Extract the p-value for the overall Cluster effect
  
  return(c(coef_val_C2vsC1, coef_val_C3vsC1, coef_val_C3vsC2, p_val))  # Return the coefficients and p-value
}

# Apply the function to all nutrients
results <- sapply(nutrients, fit_model)

# Convert results into a data frame
results_df <- as.data.frame(t(results))  # Transpose the result to match the format
colnames(results_df) <- c("Coef_C2vsC1", "Coef_C3vsC1", "Coef_C3vsC2", "p_value_Cluster")  # Set column names for coefficients and p-values
results_df$Nutrient <- nutrients  # Add the Nutrient column

# Step 2: Apply BH FDR correction to p-values for each comparison
results_df$p_value_Cluster_adj <- p.adjust(results_df$p_value_Cluster, method = "BH")

# Step 3: Add significance stars based on the adjusted p-values
results_df$Significance <- case_when(
  results_df$p_value_Cluster_adj <= 0.001 ~ "***",
  results_df$p_value_Cluster_adj <= 0.01 ~ "**",
  results_df$p_value_Cluster_adj <= 0.05 ~ "*",
  results_df$p_value_Cluster_adj <= 0.1 ~ ".",
  results_df$p_value_Cluster <= 0.05 ~ "~",
  TRUE ~ ""
)

# Step 4: Normalize the coefficients to fit within the range [-1, 1] by rescaling
results_cluster_1421 <- results_df %>%
  mutate(across(starts_with("Coef"), ~ scale(.)))  # Standardize coefficients

# Check the structure of the results_df
head(results_cluster_1421)

## metabolites pn12

metaboliteCluster_pn12 <- metabolite_pn12 %>%
  left_join(row_annotation_idbs, by = "idbs") %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) 


# Step 1: Log-transform the nutrient values
# Step 1: Log-transform the nutrient values
# Create a list of nutrients (columns except for 'idbs' and 'Cluster')
nutrients <- colnames(metaboliteCluster_pn12)[!colnames(metaboliteCluster_pn12) %in% c("idbs", "code", "Cluster")]

# Apply log transformation to the nutrient columns
metaboliteCluster_pn12_log <- metaboliteCluster_pn12 %>%
  mutate(across(all_of(nutrients), ~ log(. + 1)))  # Log transform each nutrient with +1 to avoid log(0)

# Function to fit the model and extract coefficients and p-values for the three-group comparison (C1, C2, C3)
fit_model <- function(nutrient) {
  # Fit a linear model treating Cluster as a factor variable (factor comparison between C1, C2, C3)
  lm_result <- lm(as.formula(paste(nutrient, "~ Cluster + code")), data = metaboliteCluster_pn12_log)
  
  # Extract the coefficients for each cluster
  coef_vals <- coef(lm_result)
  
  # C2 vs C1 coefficient is coef_vals["ClusterC2"] (the effect of C2 relative to C1)
  # C3 vs C1 coefficient is coef_vals["ClusterC3"] (the effect of C3 relative to C1)
  # C3 vs C2 coefficient is the difference between the coefficients for C3 and C2
  coef_val_C2vsC1 <- coef_vals["ClusterC2"]
  coef_val_C3vsC1 <- coef_vals["ClusterC3"]
  coef_val_C3vsC2 <- coef_val_C3vsC1 - coef_val_C2vsC1  # Coefficient for C3 vs C2
  
  # Extract the overall p-value for the Cluster effect (testing if Cluster has any effect on the nutrient)
  anova_result <- anova(lm_result)  # Get the ANOVA table
  p_val <- anova_result[["Pr(>F)"]][1]  # Extract the p-value for the overall Cluster effect
  
  return(c(coef_val_C2vsC1, coef_val_C3vsC1, coef_val_C3vsC2, p_val))  # Return the coefficients and p-value
}

# Apply the function to all nutrients
results <- sapply(nutrients, fit_model)

# Convert results into a data frame
results_df <- as.data.frame(t(results))  # Transpose the result to match the format
colnames(results_df) <- c("Coef_C2vsC1", "Coef_C3vsC1", "Coef_C3vsC2", "p_value_Cluster")  # Set column names for coefficients and p-values
results_df$Nutrient <- nutrients  # Add the Nutrient column

# Step 2: Apply BH FDR correction to p-values for each comparison
results_df$p_value_Cluster_adj <- p.adjust(results_df$p_value_Cluster, method = "BH")

# Step 3: Add significance stars based on the adjusted p-values
results_df$Significance <- case_when(
  results_df$p_value_Cluster_adj <= 0.001 ~ "***",
  results_df$p_value_Cluster_adj <= 0.01 ~ "**",
  results_df$p_value_Cluster_adj <= 0.05 ~ "*",
  results_df$p_value_Cluster_adj <= 0.1 ~ ".",
  results_df$p_value_Cluster <= 0.05 ~ "~",
  TRUE ~ ""
)

# Step 4: Normalize the coefficients to fit within the range [-1, 1] by rescaling
results_cluster_pn12 <- results_df %>%
  mutate(across(starts_with("Coef"), ~ scale(.)))  # Standardize coefficients

# Check the structure of the results_df
head(results_cluster_pn12)


## metabolite pn34

metaboliteCluster_pn34 <- metabolite_pn34 %>%
  left_join(row_annotation_idbs, by = "idbs") %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) 

# Step 1: Log-transform the nutrient values
# Step 1: Log-transform the nutrient values
# Create a list of nutrients (columns except for 'idbs' and 'Cluster')
nutrients <- colnames(metaboliteCluster_pn34)[!colnames(metaboliteCluster_pn34) %in% c("idbs", "code", "Cluster")]

# Apply log transformation to the nutrient columns
metaboliteCluster_pn34_log <- metaboliteCluster_pn34 %>%
  mutate(across(all_of(nutrients), ~ log(. + 1)))  # Log transform each nutrient with +1 to avoid log(0)

# Function to fit the model and extract coefficients and p-values for the three-group comparison (C1, C2, C3)
fit_model <- function(nutrient) {
  # Fit a linear model treating Cluster as a factor variable (factor comparison between C1, C2, C3)
  lm_result <- lm(as.formula(paste(nutrient, "~ Cluster + code")), data = metaboliteCluster_pn34_log)
  
  # Extract the coefficients for each cluster
  coef_vals <- coef(lm_result)
  
  # C2 vs C1 coefficient is coef_vals["ClusterC2"] (the effect of C2 relative to C1)
  # C3 vs C1 coefficient is coef_vals["ClusterC3"] (the effect of C3 relative to C1)
  # C3 vs C2 coefficient is the difference between the coefficients for C3 and C2
  coef_val_C2vsC1 <- coef_vals["ClusterC2"]
  coef_val_C3vsC1 <- coef_vals["ClusterC3"]
  coef_val_C3vsC2 <- coef_val_C3vsC1 - coef_val_C2vsC1  # Coefficient for C3 vs C2
  
  # Extract the overall p-value for the Cluster effect (testing if Cluster has any effect on the nutrient)
  anova_result <- anova(lm_result)  # Get the ANOVA table
  p_val <- anova_result[["Pr(>F)"]][1]  # Extract the p-value for the overall Cluster effect
  
  return(c(coef_val_C2vsC1, coef_val_C3vsC1, coef_val_C3vsC2, p_val))  # Return the coefficients and p-value
}

# Apply the function to all nutrients
results <- sapply(nutrients, fit_model)

# Convert results into a data frame
results_df <- as.data.frame(t(results))  # Transpose the result to match the format
colnames(results_df) <- c("Coef_C2vsC1", "Coef_C3vsC1", "Coef_C3vsC2", "p_value_Cluster")  # Set column names for coefficients and p-values
results_df$Nutrient <- nutrients  # Add the Nutrient column

# Step 2: Apply BH FDR correction to p-values for each comparison
results_df$p_value_Cluster_adj <- p.adjust(results_df$p_value_Cluster, method = "BH")

# Step 3: Add significance stars based on the adjusted p-values
results_df$Significance <- case_when(
  results_df$p_value_Cluster_adj <= 0.001 ~ "***",
  results_df$p_value_Cluster_adj <= 0.01 ~ "**",
  results_df$p_value_Cluster_adj <= 0.05 ~ "*",
  results_df$p_value_Cluster_adj <= 0.1 ~ ".",
  results_df$p_value_Cluster <= 0.05 ~ "~",
  TRUE ~ ""
)

# Step 4: Normalize the coefficients to fit within the range [-1, 1] by rescaling
results_cluster_pn34 <- results_df %>%
  mutate(across(starts_with("Coef"), ~ scale(.)))  # Standardize coefficients

# Check the structure of the results_df
head(results_cluster_pn34)

## Combined for plot

result_cluster <- results_cluster_1421 %>%
  select(Nutrient, Significance) %>%
  left_join(results_cluster_pn12 %>% select(Nutrient, Significance), by = "Nutrient") %>%
  left_join(results_cluster_pn34 %>% select(Nutrient, Significance), by = "Nutrient") %>%
  dplyr::mutate(d1421 = Significance.x) %>%
  dplyr::mutate(pn12 = Significance.y) %>%
  dplyr::mutate(pn34 = Significance) %>%
  select(-Significance.x, -Significance.y, -Significance)

library(ggplot2)
library(tidyr)
# Assuming 'result_df' is your dataset, we will pivot it to long format
result_long <- result_cluster %>%
  pivot_longer(cols = c("d1421", "pn12", "pn34"), 
               names_to = "Significance_Type", 
               values_to = "Significance") 

# Plot the heatmap using ggplot2
milkMetaboliteClusterHeatmap <- ggplot(result_long, aes(x = Nutrient, y = Significance_Type, fill = Significance)) +
  geom_tile(color = "black", width = 0.9, height = 0.9) +  # Create heatmap tiles
  #geom_text(aes(label = Significance), color = "darkred", size = 6) +  # Add significance labels inside cells
  scale_fill_manual(values = c("white", "plum3", "#483D8B", "skyblue")) +  # Customize the fill color
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        axis.text.y = element_text(size = 10), 
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        ) +
  labs(title = "Heatmap of Significance for Nutrients", 
       x = "Nutrient", 
       y = "Significance Type")
milkMetaboliteClusterHeatmap

#svglite::svglite(
#  filename="./forISRHML/milkMetaboliteClusterHeatmap_code2.svg",
#  width=10, height=2.83
#  )
#milkMetaboliteClusterHeatmap
#dev.off()


```

## Fig6C bottom infant gut pn12 vs metabolites pn34

```{r}

infant_species_pn12 <- infant_species %>%
  filter(timepoint == "pn12") %>%
  filter(Abundance >= 0.05) %>%
  select(idbs, species, Abundance) %>%
  pivot_wider(names_from = species, values_from = Abundance) %>%
  dplyr::select(idbs, where(~ mean(is.na(.)) <= 0.95))

infant12_metabolitepn34all <- metabolite_pn34 %>%
  left_join(infant_species_pn12, by = "idbs") %>%
  #left_join(row_annotation_idbs, by = "idbs")  %>% # Perform the join
  #left_join(metadata %>% dplyr::select(idbs, code, GWG, hh_child5)) %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) %>%
  select(-idbs)

library(tidyverse)
library(caret)
library(emmeans)

# Step 1: Reshape the data
# Assuming infant_hmo_pn12milk1421 is your dataframe with species and HMO columns

results_list <- lapply(names(infant12_metabolitepn34all)[
  !grepl("code|Bifidobacterium infantis|Escherichia coli|Bacteroides fragilis_A|Klebsiella pneumoniae|Prevotella sp900544825|Streptococcus sp000187445|Parolsenella uli_B|Bifidobacterium longum|Prevotella sp900551985|Veillonella_A sp000431435|Bifidobacterium bifidum", 
         names(infant12_metabolitepn34all))], function(hmo_column) {
           
  lapply(names(infant12_metabolitepn34all)[
    grepl("Bifidobacterium infantis|Escherichia coli|Bacteroides fragilis_A|Klebsiella pneumoniae|Prevotella sp900544825|Streptococcus sp000187445|Parolsenella uli_B|Bifidobacterium longum|Prevotella sp900551985|Veillonella_A sp000431435|Bifidobacterium bifidum", 
          names(infant12_metabolitepn34all))], function(species_column) {
    
    # Ensure variables are numeric before applying log1p()
    log_species <- as.numeric(as.character(infant12_metabolitepn34all[[species_column]]))
    log_hmo <- as.numeric(as.character(infant12_metabolitepn34all[[hmo_column]]))
    
    # Convert factor confounder to factor if it's not already
    confounder_code <- as.factor(infant12_metabolitepn34all$code)  

    # Remove NAs and ensure correct alignment
    valid_idx <- complete.cases(log_species, log_hmo, confounder_code)
    log_species <- log_species[valid_idx]
    log_hmo <- log_hmo[valid_idx]
    confounder_code <- confounder_code[valid_idx]  # Keep only valid indices
    
    # Skip if not enough data points
    if (length(log_species) < 3 || length(unique(log_species)) < 2) {
      message(paste("Skipping:", species_column, "due to insufficient data."))
      return(NULL)
    }
    
    if (length(log_hmo) < 3 || length(unique(log_hmo)) < 2) {
      message(paste("Skipping:", hmo_column, "due to insufficient data."))
      return(NULL)
    }
    
    # Perform linear regression with confounder
    lm_result <- tryCatch({
      lm(log1p(log_hmo) ~ log1p(log_species) + confounder_code)
    }, error = function(e) {
      message(paste("Skipping:", species_column, "vs", hmo_column, "due to regression failure."))
      return(NULL)
    })
    
    # Check if model has at least 2 coefficients
    if (!is.null(lm_result) && length(coef(lm_result)) > 2) {
      coef_val <- coef(lm_result)[2]  # Coefficient of the HMO
      p_val <- summary(lm_result)$coefficients[2, 4]  # p-value for HMO
    } else {
      coef_val <- NA
      p_val <- NA
    }
    
    # Return results as a data frame
    tibble(species = species_column, HMO = hmo_column, coefficient = coef_val, p_value = p_val)
  })
})

# Flatten the list into a single data frame
results_df <- bind_rows(unlist(results_list, recursive = TRUE))

# Step 1: Convert the dataframe to a matrix
results_matrix <- as.matrix(results_df)

# Step 2: Reshape the matrix into a new matrix where each row has 4 columns
reshaped_matrix <- matrix(results_matrix, ncol = 4, byrow = TRUE)

# Step 3: Convert the reshaped matrix back into a dataframe
results_table <- as.data.frame(reshaped_matrix)

# Optionally, assign column names (optional step)
colnames(results_table) <- c("Species", "HMO", "Coefficient", "P_value")

# View the resulting table
print(results_table)

# Step 3: FDR correction of p-values using BH method
results_adj <- results_table %>%
  dplyr::mutate(adj_p_value = p.adjust(P_value, method = "BH"))


# Step 4: Define significance based on adjusted p-values
results_adj <- results_adj %>%
  mutate(Coefficient = as.numeric(Coefficient)) %>%
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      P_value <= 0.05 & adj_p_value > 0.1 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )
# Check the output
head(results_adj)

# Plot the heatmap using ggplot2
infant12_metabolitepn34all_Heatmap <- ggplot(results_adj, aes(x = HMO, y = Species, fill = Coefficient)) +
  geom_tile(color = "white", width = 1, height = 1) +  # Create heatmap tiles
  geom_text(aes(label = significance), color = "darkred", size = 1) +  # Add significance labels inside cells
  scale_fill_gradientn(
    colours = divergingx_hcl(5, palette = "RdBu"),  # perceptually uniform
    limits = c(-12,12),
    name = "Coefficient"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),  # Remove x-axis text
    axis.ticks.x = element_blank(),  # Remove x-axis ticks
    axis.text.y = element_text(size = 10),
    legend.position = "bottom",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  labs(
       x = "Metabolites at 3-4 months", 
       y = "Infant gut at 1-2 months")
infant12_metabolitepn34all_Heatmap

# Save as SVG with a 1.5 aspect ratio
#ggsave("./forISRHML/infant12_metabolitepn34all_heatmap_code3.svg", infant12_metabolitepn34all_Heatmap, width = 10, height = 4, dpi = 300)

```

## FigS6 SCFAs vs infant gut species

## pn12

```{r}

scfa_pn12 <- scfa_cleaned %>%
  filter(timepoint=="pn12") %>%
  select(-timepoint, -child, -Cluster)

infant_species_pn12 <- infant_species %>%
  filter(timepoint == "pn12") %>%
  filter(Abundance >= 0.05) %>%
  select(idbs, species, Abundance) %>%
  pivot_wider(names_from = species, values_from = Abundance) %>%
  dplyr::select(idbs, where(~ mean(is.na(.)) <= 0.94))

infant_species_pn12$idbs <- as.character(infant_species_pn12$idbs )

infant12_scfa <- 
scfa_pn12 %>%
  left_join(infant_species_pn12, by = "idbs") 

corr_data <- infant12_scfa %>%
  dplyr::select(-idbs) 

# Sort species-related variables (y-axis)
inf_vars <- sort(colnames(corr_data)[colnames(corr_data) %in% colnames(infant_species_pn12)])

# Sort SCFA-related variables (x-axis)
scfa_vars <- sort(colnames(corr_data)[colnames(corr_data) %in% colnames(scfa_pn12)])

# Ensure all selected columns are numeric
corr_data_numeric <- corr_data %>%
  dplyr::mutate(across(all_of(c(inf_vars, scfa_vars)), as.numeric))

# Now compute the correlation matrix
cor_mat <- cor(
  corr_data_numeric[, inf_vars, drop = FALSE],
  corr_data_numeric[, scfa_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Step 7: Compute p-values for correlations
# Use numeric-only data for correlation test
cor_test <- psych::corr.test(
  corr_data_numeric[, inf_vars, drop = FALSE],
  corr_data_numeric[, scfa_vars, drop = FALSE],
  method = "spearman"
)

cor_test_mat <- cor_test$p  # Extract p-values

# Step 8: Plot heatmap of correlations
plot_corr <- {
  corrplot::corrplot(
    t(cor_mat),                    # Transpose the correlation matrix
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,
    p.mat = t(cor_test_mat),       # Also transpose the p-value matrix
    sig.level = c(0.001, 0.01, 0.05),
    insig = "label_sig",
    pch.cex = 1,
    pch.col = "black",
    tl.cex = 0.7,
    tl.col = "black",
    mar = c(0.5, 0.5, 0.5, 0.5),
    addgrid.col = "white"
  )
  recordPlot()
}
#svglite::svglite(
#  filename="./forISRHML/Jun2_heatmap_infant12_scfa.svg",
#  width=6, height=4
#  )
#plot_corr
#dev.off()


## pn56
library(dplyr)
# Step 1: Clean SCFA data
scfa_pn56 <- scfa_cleaned %>%
  filter(timepoint == "pn56") %>%
  select(-timepoint, -child, -Cluster)

# Step 2: Clean species data
infant_species_pn56 <- infant_species %>%
  filter(timepoint == "pn56") %>%
  filter(Abundance >= 0.05) %>%
  select(idbs, species, Abundance) %>%
  pivot_wider(names_from = species, values_from = Abundance) %>%
  dplyr::select(idbs, where(~ mean(is.na(.)) <= 0.93))  # <- updated: keep only species with ‚â§ 50% missing

infant_species_pn56$idbs <- as.character(infant_species_pn56$idbs)

# Step 3: Merge species and SCFA
infant56_scfa <- scfa_pn56 %>%
  left_join(infant_species_pn56, by = "idbs")

# Step 4: Prepare correlation data
corr_data <- infant56_scfa %>% select(-idbs)

# Step 5: Identify variable sets
# Sort species-related variables (y-axis)
inf_vars <- sort(colnames(corr_data)[colnames(corr_data) %in% colnames(infant_species_pn56)])

# Sort SCFA-related variables (x-axis)
scfa_vars <- sort(colnames(corr_data)[colnames(corr_data) %in% colnames(scfa_pn56)])

# Step 6: Keep only numeric columns and clean NAs
corr_data_numeric <- corr_data %>%
  dplyr::mutate(across(all_of(c(inf_vars, scfa_vars)), as.numeric))

# Step 7: Filter out any all-NA species columns again
inf_vars <- inf_vars[colSums(!is.na(corr_data_numeric[inf_vars])) > 0]

# Step 8: Compute correlation
cor_mat <- cor(
  corr_data_numeric[, inf_vars, drop = FALSE],
  corr_data_numeric[, scfa_vars, drop = FALSE],
  use = "pairwise.complete.obs",
  method = "spearman"
)

# Step 9: Compute p-values
cor_test <- psych::corr.test(
  corr_data_numeric[, inf_vars, drop = FALSE],
  corr_data_numeric[, scfa_vars, drop = FALSE],
  method = "spearman"
)

cor_test_p <- cor_test$p[inf_vars, scfa_vars]

# Step 10: Plot heatmap
plot_corr <- {
  corrplot::corrplot(
    t(cor_mat),                    # Transpose the correlation matrix
    is.corr = TRUE,
    method = "color",
    addCoef.col = NULL,
    p.mat = t(cor_test_mat),       # Also transpose the p-value matrix
    sig.level = c(0.001, 0.01, 0.05),
    insig = "label_sig",
    pch.cex = 1,
    pch.col = "black",
    tl.cex = 0.7,
    tl.col = "black",
    mar = c(0.5, 0.5, 0.5, 0.5),
    addgrid.col = "white"
  )
  recordPlot()
}
# Step 11: Save as SVG
#svglite::svglite(
#  filename = "./forISRHML/Jun2_heatmap_infant56_scfa.svg",
#  width = 5,
#  height = 4
#)
#plot_corr
#dev.off()
```

# GSEA pn12e

```{r}
set.seed(1234)

COLOR_SCHEME2 <- c(
  "#1565A9",
  "#00A98F",
  "#FFC000",
  "#C00000")

ONLY_STANFORD_PATHWAYS <- FALSE

message(
  paste0(
    "The `ONLY_STANFORD_PATHWAYS` parameter is set to: ",
    ONLY_STANFORD_PATHWAYS,
    ifelse(
      ONLY_STANFORD_PATHWAYS, 
      " i.e., only microbially related pathways are used.", 
      " i.e., all KEGG pathways are used."
      )
    )
  )

if (ONLY_STANFORD_PATHWAYS) {
  # filtering microbial pathways
  microbial_pathways <- read.csv(microbial_pathways_path, sep="\t")$KO
  gene_to_pathway <- gene_to_pathway[gene_to_pathway$gene %in% microbial_pathways, ]
  pathway_to_gene <- pathway_to_gene[pathway_to_gene$gene %in% microbial_pathways, ]
  pathway_to_description <- pathway_to_description[pathway_to_description$V1 %in% pathway_to_gene$pathway, ]
}

DT::datatable(gene_to_pathway)

metadata_inf <- metadataGut2[metadataGut2$child == "yes", ]
metadata_inf_pn12_C2vC1 <-metadata_inf %>%
  filter(timepoint == "pn12") %>%
  filter(Cluster != "C3") %>%
  mutate(Cluster = relevel(factor(Cluster), ref = "C1"))
metadata_inf_pn12_C2vC3 <-metadata_inf %>%
  filter(timepoint == "pn12") %>%
  filter(Cluster != "C1") %>%
  dplyr::mutate(Cluster = relevel(factor(Cluster), ref = "C3"))
metadata_inf_pn12_C1vC3 <-metadata_inf %>%
  filter(timepoint == "pn12") %>%
  filter(Cluster != "C2") %>%
  dplyr::mutate(Cluster = relevel(factor(Cluster), ref = "C3"))

# counts
gene_counts_inf <- gene_counts[, rownames(metadata_inf)]
gene_counts_inf <- gene_counts_inf[rowSums(gene_counts_inf) != 0, ]
gene_counts_inf_pn12_C2vC1 <- gene_counts_inf[, rownames(metadata_inf_pn12_C2vC1)]
gene_counts_inf_pn12_C2vC3 <- gene_counts_inf[, rownames(metadata_inf_pn12_C2vC3)]
gene_counts_inf_pn12_C1vC3 <- gene_counts_inf[, rownames(metadata_inf_pn12_C1vC3)]


# hierarchy
anno_inf <- gene_anno[rownames(gene_counts_inf), ]
phylogenetic_tree_inf <- TreeSummarizedExperiment::toTree(
  data = anno_inf
  )

# fix order
metadata_inf_pn12_C2vC1 <- metadata_inf_pn12_C2vC1[colnames(gene_counts_inf_pn12_C2vC1), ]
metadata_inf_pn12_C2vC3 <- metadata_inf_pn12_C2vC3[colnames(gene_counts_inf_pn12_C2vC3), ]
metadata_inf_pn12_C1vC3 <- metadata_inf_pn12_C1vC3[colnames(gene_counts_inf_pn12_C1vC3), ]

tse_object_scaled_inf_pn12_C2vC1 <- TreeSummarizedExperiment::TreeSummarizedExperiment(
  assays = list(count = as.matrix(gene_counts_inf_pn12_C2vC1)),
  rowData = anno_inf,
  colData = metadata_inf_pn12_C2vC1,
  rowTree = phylogenetic_tree_inf,
  rowNodeLab = rownames(gene_counts_inf_pn12_C2vC1)
)
tse_object_scaled_inf_pn12_C2vC3 <- TreeSummarizedExperiment::TreeSummarizedExperiment(
  assays = list(count = as.matrix(gene_counts_inf_pn12_C2vC3)),
  rowData = anno_inf,
  colData = metadata_inf_pn12_C2vC3,
  rowTree = phylogenetic_tree_inf,
  rowNodeLab = rownames(gene_counts_inf_pn12_C2vC3)
)
tse_object_scaled_inf_pn12_C1vC3 <- TreeSummarizedExperiment::TreeSummarizedExperiment(
  assays = list(count = as.matrix(gene_counts_inf_pn12_C1vC3)),
  rowData = anno_inf,
  colData = metadata_inf_pn12_C1vC3,
  rowTree = phylogenetic_tree_inf,
  rowNodeLab = rownames(gene_counts_inf_pn12_C1vC3)
)

#' Create a volcano plot from the outputs of a differential abundance analysis
#'
#' @param results A list containing the DA results as outputted in the
#' `treeclimbR::evalCand` function.
#' @param alpha a numeric alpha level on which to cut off p-values
#' @param effect_cutoff a numeric log fold change on which to cut off log FCs
#' @param color_scheme a list of hex valued colors indicating a scheme.
#' @param title title for the plot to export
#'
#' @examples volcano_plot(results, color_scheme)
#' @export
volcano_plot <- function(results,
                         alpha = 0.1,
                         effect_cutoff = 2,
                         color_scheme, 
                         title = "Differential abundance analysis: Volcano plot") {
  # extract elements
  scores <- results$output

  # color on significance groups and add tooltips
  volcano_plot_df <- scores %>%
    mutate(
      significance_group = dplyr::if_else(
        abs(logFC) < effect_cutoff & PValue > alpha,
        "Non-significant",
        dplyr::if_else(
          abs(logFC) < effect_cutoff,
          "Statistically significant (p-values)",
          dplyr::if_else(
            PValue > alpha,
            "Biologically significant (FC)",
            "Biologically & statistically significant"
          )
        )
      ),
      text = paste0(
        "Taxon: ", names, "\n",
        "p-value: ", PValue, "\n",
        "log FC: ", round(logFC, 4), "\n"
      )
    )

  p <- ggplot2::ggplot(
    volcano_plot_df,
    ggplot2::aes(
      x = logFC, y = -log10(PValue),
      color = significance_group,
      text = text
    )
  ) +
    ggplot2::geom_point(size = 3, alpha = 0.8) +
    ggplot2::theme_bw() +
    ggplot2::scale_color_manual(
      values = c(
        "Non-significant" = "#9EA0A5",
        "Biologically significant (FC)" = color_scheme[1],
        "Statistically significant (p-values)" = color_scheme[3],
        "Biologically & statistically significant" = color_scheme[2]
      )
    ) +
    ggplot2::labs(
      title = title,
      x = "Fold change (Log2)",
      y = "p-value (-Log10)"
    ) +
    ggplot2::theme(
      plot.title = ggplot2::element_text(face = "bold"),
      axis.text.x = ggplot2::element_text(vjust = 0.4, hjust = 1),
      axis.text.y = ggplot2::element_text(vjust = 0.4, hjust = 1),
      legend.title = ggplot2::element_blank(),
      legend.position = "right",
      text = ggplot2::element_text(size = 10)
    ) +
    ggplot2::geom_vline(
      xintercept = c(-effect_cutoff, effect_cutoff),
      linetype = "dashed"
    ) +
    ggplot2::geom_hline(
      yintercept = -log10(alpha),
      linetype = "dashed"
    )

  return(plotly::ggplotly(p, tooltip = "text"))
}
```

## FigS5B top volcano plot for infant gut genes pn12

```{r treeclimbR infants pn12 TSS, include=FALSE}

res_scaled_inf_pn12_C2vC1 <- treeclimbR::runDA(
  TSE = tse_object_scaled_inf_pn12_C2vC1,
  feature_on_row = TRUE,
  assay = 1,
  design_terms = "Cluster"
  )
res_table_scaled_inf_pn12_C2vC1 <- treeclimbR::nodeResult(
  object = res_scaled_inf_pn12_C2vC1,
  n = Inf
  )
candidates_scaled_inf_pn12_C2vC1 <- treeclimbR::getCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_inf_pn12_C2vC1),
  score_data = res_table_scaled_inf_pn12_C2vC1,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC"
  )
da_results_scaled_inf_pn12_C2vC1 <- treeclimbR::evalCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_inf_pn12_C2vC1),
  type = "single",
  levels = candidates_scaled_inf_pn12_C2vC1$candidate_list,
  limit_rej = 0.1,
  score_data = res_table_scaled_inf_pn12_C2vC1,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC",
  use_pseudo_leaf = FALSE
  )

da_results_scaled_inf_pn12_C2vC1$output$names <- TreeSummarizedExperiment::convertNode(
  phylogenetic_tree_inf,
  da_results_scaled_inf_pn12_C2vC1$output$node
  )

# adjusted p-values plot
gene_daa_pn12e_C2vC1 <- da_results_scaled_inf_pn12_C2vC1$output
DT::datatable(gene_daa_pn12e_C2vC1)

#write.xlsx(gene_daa_pn12e_C2vC1, "./forISRHML/gene_daa_pn12e_C2vC1.xlsx")

gene_volcano_pn12e_C2vC1 <- gene_daa_pn12e_C2vC1 |>
  mutate(`adj.p`=-log10(`adj.p`)) |>
  mutate(label=if_else(abs(`logFC`)>1, names, NA_character_)) |>
  mutate(label=if_else(`adj.p` >1.3, names, NA_character_)) |>
  mutate(color=if_else(`logFC`>0, "steelblue", "darkred")) |>
  mutate(color=if_else(is.na(label), "#000000", color)) |>
  ggplot(mapping = aes(`logFC`, `adj.p`, color=I(color), label=label, shape=I(1))) +
  geom_point() +
  geom_hline(linetype = "dotted", yintercept = 1.3) +
  geom_vline(linetype = "dotted", xintercept = 1) +
  geom_vline(linetype = "dotted", xintercept = -1) +
  geom_label_repel(min.segment.length = 0, force = 10, max.overlaps = 20, na.rm = TRUE) +
  labs(title = "Gene counts infant Pn12: C2vC1",
       x = expression(~Log[2]~FoldChange),
       y = expression(-~Log[10]~Q)) +
  theme_bw() + xlim(-2, 2)

gene_volcano_pn12e_C2vC1

#ggsave("./forISRHML/gene_volcano_pn12e_C2vC1.svg", gene_volcano_pn12e_C2vC1, width = 4, height = 4.5, dpi = 300)

res_scaled_inf_pn12_C2vC3 <- treeclimbR::runDA(
  TSE = tse_object_scaled_inf_pn12_C2vC3,
  feature_on_row = TRUE,
  assay = 1,
  design_terms = "Cluster"
  )
res_table_scaled_inf_pn12_C2vC3 <- treeclimbR::nodeResult(
  object = res_scaled_inf_pn12_C2vC3,
  n = Inf
  )
candidates_scaled_inf_pn12_C2vC3 <- treeclimbR::getCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_inf_pn12_C2vC3),
  score_data = res_table_scaled_inf_pn12_C2vC3,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC"
  )
da_results_scaled_inf_pn12_C2vC3 <- treeclimbR::evalCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_inf_pn12_C2vC3),
  type = "single",
  levels = candidates_scaled_inf_pn12_C2vC3$candidate_list,
  limit_rej = 0.1,
  score_data = res_table_scaled_inf_pn12_C2vC3,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC",
  use_pseudo_leaf = FALSE
  )

da_results_scaled_inf_pn12_C2vC3$output$names <- TreeSummarizedExperiment::convertNode(
  phylogenetic_tree_inf,
  da_results_scaled_inf_pn12_C2vC3$output$node
  )

# adjusted p-values plot
gene_daa_pn12e_C2vC3 <- da_results_scaled_inf_pn12_C2vC3$output
DT::datatable(gene_daa_pn12e_C2vC3)

#write.xlsx(gene_daa_pn12e_C2vC3, "./forISRHML/gene_daa_pn12e_C2vC3.xlsx")


gene_volcano_pn12e_C2vC3 <- gene_daa_pn12e_C2vC3 |>
  mutate(`adj.p`=-log10(`adj.p`)) |>
  mutate(label=if_else(abs(`logFC`)>1, names, NA_character_)) |>
  mutate(label=if_else(`adj.p` >1.3, names, NA_character_)) |>
  mutate(color=if_else(`logFC`>0, "steelblue", "darkred")) |>
  mutate(color=if_else(is.na(label), "#000000", color)) |>
  ggplot(mapping = aes(`logFC`, `adj.p`, color=I(color), label=label, shape=I(1))) +
  geom_point() +
  geom_hline(linetype = "dotted", yintercept = 1.3) +
  geom_vline(linetype = "dotted", xintercept = 1) +
  geom_vline(linetype = "dotted", xintercept = -1) +
  geom_label_repel(min.segment.length = 0, force = 10, max.overlaps = 20, na.rm = TRUE) +
  labs(title = "Gene counts infant Pn12: C2vC3",
       x = expression(~Log[2]~FoldChange),
       y = expression(-~Log[10]~Q)) +
  theme_bw() + xlim(-2, 2)

gene_volcano_pn12e_C2vC3

#ggsave("./forISRHML/gene_volcano_pn12e_C2vC3.svg", gene_volcano_pn12e_C2vC3, width = 4, height = 4.5, dpi = 300)

res_scaled_inf_pn12_C1vC3 <- treeclimbR::runDA(
  TSE = tse_object_scaled_inf_pn12_C1vC3,
  feature_on_row = TRUE,
  assay = 1,
  design_terms = "Cluster"
  )
res_table_scaled_inf_pn12_C1vC3 <- treeclimbR::nodeResult(
  object = res_scaled_inf_pn12_C1vC3,
  n = Inf
  )
candidates_scaled_inf_pn12_C1vC3 <- treeclimbR::getCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_inf_pn12_C1vC3),
  score_data = res_table_scaled_inf_pn12_C1vC3,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC"
  )
da_results_scaled_inf_pn12_C1vC3 <- treeclimbR::evalCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_inf_pn12_C1vC3),
  type = "single",
  levels = candidates_scaled_inf_pn12_C1vC3$candidate_list,
  limit_rej = 0.1,
  score_data = res_table_scaled_inf_pn12_C1vC3,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC",
  use_pseudo_leaf = FALSE
  )

da_results_scaled_inf_pn12_C1vC3$output$names <- TreeSummarizedExperiment::convertNode(
  phylogenetic_tree_inf,
  da_results_scaled_inf_pn12_C1vC3$output$node
  )

# adjusted p-values plot
gene_daa_pn12e_C1vC3 <- da_results_scaled_inf_pn12_C1vC3$output
DT::datatable(gene_daa_pn12e_C1vC3)

#write.xlsx(gene_daa_pn12e_C1vC3, "./forISRHML/gene_daa_pn12e_C1vC3.xlsx")

gene_volcano_pn12e_C1vC3 <- gene_daa_pn12e_C1vC3 |>
  mutate(`adj.p`=-log10(`adj.p`)) |>
  mutate(label=if_else(abs(`logFC`)>1, names, NA_character_)) |>
  mutate(label=if_else(`adj.p` >1.3, names, NA_character_)) |>
  mutate(color=if_else(`logFC`>0, "steelblue", "darkred")) |>
  mutate(color=if_else(is.na(label), "#000000", color)) |>
  ggplot(mapping = aes(`logFC`, `adj.p`, color=I(color), label=label, shape=I(1))) +
  geom_point() +
  geom_hline(linetype = "dotted", yintercept = 1.3) +
  geom_vline(linetype = "dotted", xintercept = 1) +
  geom_vline(linetype = "dotted", xintercept = -1) +
  geom_label_repel(min.segment.length = 0, force = 10, max.overlaps = 20, na.rm = TRUE) +
  labs(title = "Gene counts infant Pn12: C1vC3",
       x = expression(~Log[2]~FoldChange),
       y = expression(-~Log[10]~Q)) +
  theme_bw() + xlim(-2, 2)

gene_volcano_pn12e_C1vC3

#ggsave("./forISRHML/gene_volcano_pn12e_C1vC3.svg", gene_volcano_pn12e_C1vC3, width = 4, height = 4.5, dpi = 300)


```

# GESA pn56e

```{r}

ONLY_STANFORD_PATHWAYS <- FALSE

message(
  paste0(
    "The `ONLY_STANFORD_PATHWAYS` parameter is set to: ",
    ONLY_STANFORD_PATHWAYS,
    ifelse(
      ONLY_STANFORD_PATHWAYS, 
      " i.e., only microbially related pathways are used.", 
      " i.e., all KEGG pathways are used."
      )
    )
  )

if (ONLY_STANFORD_PATHWAYS) {
  # filtering microbial pathways
  microbial_pathways <- read.csv(microbial_pathways_path, sep="\t")$KO
  gene_to_pathway <- gene_to_pathway[gene_to_pathway$gene %in% microbial_pathways, ]
  pathway_to_gene <- pathway_to_gene[pathway_to_gene$gene %in% microbial_pathways, ]
  pathway_to_description <- pathway_to_description[pathway_to_description$V1 %in% pathway_to_gene$pathway, ]
}

DT::datatable(gene_to_pathway)

metadata_inf <- metadataGut2[metadataGut2$child == "yes", ]
metadata_inf_pn56_C2vC1 <-metadata_inf %>%
  filter(timepoint == "pn56") %>%
  filter(Cluster != "C3") %>%
  droplevels()  # Drop unused levels
metadata_inf_pn56_C2vC3 <-metadata_inf %>%
  filter(timepoint == "pn56") %>%
  filter(Cluster != "C1") %>%
  mutate(Cluster = relevel(factor(Cluster), ref = "C3")) %>%
  droplevels()  # Drop unused levels
metadata_inf_pn56_C1vC3 <-metadata_inf %>%
  filter(timepoint == "pn56") %>%
  filter(Cluster != "C2") %>%
  mutate(Cluster = relevel(factor(Cluster), ref = "C3")) %>%
  droplevels()  # Drop unused levels

# counts
gene_counts_inf <- gene_counts[, rownames(metadata_inf)]
gene_counts_inf <- gene_counts_inf[rowSums(gene_counts_inf) != 0, ]
gene_counts_inf_pn56_C2vC1 <- gene_counts_inf[, rownames(metadata_inf_pn56_C2vC1)]
gene_counts_inf_pn56_C2vC3 <- gene_counts_inf[, rownames(metadata_inf_pn56_C2vC3)]
gene_counts_inf_pn56_C1vC3 <- gene_counts_inf[, rownames(metadata_inf_pn56_C1vC3)]


# hierarchy
anno_inf <- gene_anno[rownames(gene_counts_inf), ]
phylogenetic_tree_inf <- TreeSummarizedExperiment::toTree(
  data = anno_inf
  )

# fix order
metadata_inf_pn56_C2vC1 <- metadata_inf_pn56_C2vC1[colnames(gene_counts_inf_pn56_C2vC1), ]
metadata_inf_pn56_C2vC3 <- metadata_inf_pn56_C2vC3[colnames(gene_counts_inf_pn56_C2vC3), ]
metadata_inf_pn56_C1vC3 <- metadata_inf_pn56_C1vC3[colnames(gene_counts_inf_pn56_C1vC3), ]

tse_object_scaled_inf_pn56_C2vC1 <- TreeSummarizedExperiment::TreeSummarizedExperiment(
  assays = list(count = as.matrix(gene_counts_inf_pn56_C2vC1)),
  rowData = anno_inf,
  colData = metadata_inf_pn56_C2vC1,
  rowTree = phylogenetic_tree_inf,
  rowNodeLab = rownames(gene_counts_inf_pn56_C2vC1)
)
tse_object_scaled_inf_pn56_C2vC3 <- TreeSummarizedExperiment::TreeSummarizedExperiment(
  assays = list(count = as.matrix(gene_counts_inf_pn56_C2vC3)),
  rowData = anno_inf,
  colData = metadata_inf_pn56_C2vC3,
  rowTree = phylogenetic_tree_inf,
  rowNodeLab = rownames(gene_counts_inf_pn56_C2vC3)
)
tse_object_scaled_inf_pn56_C1vC3 <- TreeSummarizedExperiment::TreeSummarizedExperiment(
  assays = list(count = as.matrix(gene_counts_inf_pn56_C1vC3)),
  rowData = anno_inf,
  colData = metadata_inf_pn56_C1vC3,
  rowTree = phylogenetic_tree_inf,
  rowNodeLab = rownames(gene_counts_inf_pn56_C1vC3)
)

#' Create a volcano plot from the outputs of a differential abundance analysis
#'
#' @param results A list containing the DA results as outputted in the
#' `treeclimbR::evalCand` function.
#' @param alpha a numeric alpha level on which to cut off p-values
#' @param effect_cutoff a numeric log fold change on which to cut off log FCs
#' @param color_scheme a list of hex valued colors indicating a scheme.
#' @param title title for the plot to export
#'
#' @examples volcano_plot(results, color_scheme)
#' @export
volcano_plot <- function(results,
                         alpha = 0.1,
                         effect_cutoff = 2,
                         color_scheme, 
                         title = "Differential abundance analysis: Volcano plot") {
  # extract elements
  scores <- results$output

  # color on significance groups and add tooltips
  volcano_plot_df <- scores %>%
    mutate(
      significance_group = dplyr::if_else(
        abs(logFC) < effect_cutoff & PValue > alpha,
        "Non-significant",
        dplyr::if_else(
          abs(logFC) < effect_cutoff,
          "Statistically significant (p-values)",
          dplyr::if_else(
            PValue > alpha,
            "Biologically significant (FC)",
            "Biologically & statistically significant"
          )
        )
      ),
      text = paste0(
        "Taxon: ", names, "\n",
        "p-value: ", PValue, "\n",
        "log FC: ", round(logFC, 4), "\n"
      )
    )

  p <- ggplot2::ggplot(
    volcano_plot_df,
    ggplot2::aes(
      x = logFC, y = -log10(PValue),
      color = significance_group,
      text = text
    )
  ) +
    ggplot2::geom_point(size = 3, alpha = 0.8) +
    ggplot2::theme_bw() +
    ggplot2::scale_color_manual(
      values = c(
        "Non-significant" = "#9EA0A5",
        "Biologically significant (FC)" = color_scheme[1],
        "Statistically significant (p-values)" = color_scheme[3],
        "Biologically & statistically significant" = color_scheme[2]
      )
    ) +
    ggplot2::labs(
      title = title,
      x = "Fold change (Log2)",
      y = "p-value (-Log10)"
    ) +
    ggplot2::theme(
      plot.title = ggplot2::element_text(face = "bold"),
      axis.text.x = ggplot2::element_text(vjust = 0.4, hjust = 1),
      axis.text.y = ggplot2::element_text(vjust = 0.4, hjust = 1),
      legend.title = ggplot2::element_blank(),
      legend.position = "right",
      text = ggplot2::element_text(size = 10)
    ) +
    ggplot2::geom_vline(
      xintercept = c(-effect_cutoff, effect_cutoff),
      linetype = "dashed"
    ) +
    ggplot2::geom_hline(
      yintercept = -log10(alpha),
      linetype = "dashed"
    )

  return(plotly::ggplotly(p, tooltip = "text"))
}

```

## FigS5B bottom volcano plot for infant gut genes pn56

```{r treeclimbR infants pn56 TSS, include=FALSE}

res_scaled_inf_pn56_C2vC1 <- treeclimbR::runDA(
  TSE = tse_object_scaled_inf_pn56_C2vC1,
  feature_on_row = TRUE,
  assay = 1,
  design_terms = "Cluster"
  )
res_table_scaled_inf_pn56_C2vC1 <- treeclimbR::nodeResult(
  object = res_scaled_inf_pn56_C2vC1,
  n = Inf
  )
candidates_scaled_inf_pn56_C2vC1 <- treeclimbR::getCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_inf_pn56_C2vC1),
  score_data = res_table_scaled_inf_pn56_C2vC1,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC"
  )
da_results_scaled_inf_pn56_C2vC1 <- treeclimbR::evalCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_inf_pn56_C2vC1),
  type = "single",
  levels = candidates_scaled_inf_pn56_C2vC1$candidate_list,
  limit_rej = 0.1,
  score_data = res_table_scaled_inf_pn56_C2vC1,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC",
  use_pseudo_leaf = FALSE
  )

da_results_scaled_inf_pn56_C2vC1$output$names <- TreeSummarizedExperiment::convertNode(
  phylogenetic_tree_inf,
  da_results_scaled_inf_pn56_C2vC1$output$node
  )

# adjusted p-values plot
gene_daa_pn56e_C2vC1 <- da_results_scaled_inf_pn56_C2vC1$output
DT::datatable(gene_daa_pn56e_C2vC1)

#write.xlsx(gene_daa_pn56e_C2vC1, "./forISRHML/gene_daa_pn56e_C2vC1.xlsx")


gene_volcano_pn56e_C2vC1 <- gene_daa_pn56e_C2vC1 |>
  mutate(`adj.p`=-log10(`adj.p`)) |>
  mutate(label=if_else(abs(`logFC`)>1, names, NA_character_)) |>
  mutate(label=if_else(`adj.p` >1.3, names, NA_character_)) |>
  mutate(color=if_else(`logFC`>0, "steelblue", "darkred")) |>
  mutate(color=if_else(is.na(label), "#000000", color)) |>
  ggplot(mapping = aes(`logFC`, `adj.p`, color=I(color), label=label, shape=I(1))) +
  geom_point() +
  geom_hline(linetype = "dotted", yintercept = 1.3) +
  geom_vline(linetype = "dotted", xintercept = 1) +
  geom_vline(linetype = "dotted", xintercept = -1) +
  geom_label_repel(min.segment.length = 0, force = 10, max.overlaps = 20, na.rm = TRUE) +
  labs(title = "Gene counts infant pn56: C2vC1",
       x = expression(~Log[2]~FoldChange),
       y = expression(-~Log[10]~Q)) +
  theme_bw() + xlim(-2, 2)

gene_volcano_pn56e_C2vC1

#ggsave("./forISRHML/gene_volcano_pn56e_C2vC1.svg", gene_volcano_pn56e_C2vC1, width = 4, height = 4.5, dpi = 300)

res_scaled_inf_pn56_C2vC3 <- treeclimbR::runDA(
  TSE = tse_object_scaled_inf_pn56_C2vC3,
  feature_on_row = TRUE,
  assay = 1,
  design_terms = "Cluster"
  )
res_table_scaled_inf_pn56_C2vC3 <- treeclimbR::nodeResult(
  object = res_scaled_inf_pn56_C2vC3,
  n = Inf
  )
candidates_scaled_inf_pn56_C2vC3 <- treeclimbR::getCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_inf_pn56_C2vC3),
  score_data = res_table_scaled_inf_pn56_C2vC3,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC"
  )
da_results_scaled_inf_pn56_C2vC3 <- treeclimbR::evalCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_inf_pn56_C2vC3),
  type = "single",
  levels = candidates_scaled_inf_pn56_C2vC3$candidate_list,
  limit_rej = 0.1,
  score_data = res_table_scaled_inf_pn56_C2vC3,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC",
  use_pseudo_leaf = FALSE
  )

da_results_scaled_inf_pn56_C2vC3$output$names <- TreeSummarizedExperiment::convertNode(
  phylogenetic_tree_inf,
  da_results_scaled_inf_pn56_C2vC3$output$node
  )

# adjusted p-values plot
gene_daa_pn56e_C2vC3 <- da_results_scaled_inf_pn56_C2vC3$output
DT::datatable(gene_daa_pn56e_C2vC3)

#write.xlsx(gene_daa_pn56e_C2vC3, "./forISRHML/gene_daa_pn56e_C2vC3.xlsx")

gene_volcano_pn56e_C2vC3 <- gene_daa_pn56e_C2vC3 |>
  mutate(`adj.p`=-log10(`adj.p`)) |>
  mutate(label=if_else(abs(`logFC`)>1, names, NA_character_)) |>
  mutate(label=if_else(`adj.p` >1.3, names, NA_character_)) |>
  mutate(color=if_else(`logFC`>0, "steelblue", "darkred")) |>
  mutate(color=if_else(is.na(label), "#000000", color)) |>
  ggplot(mapping = aes(`logFC`, `adj.p`, color=I(color), label=label, shape=I(1))) +
  geom_point() +
  geom_hline(linetype = "dotted", yintercept = 1.3) +
  geom_vline(linetype = "dotted", xintercept = 1) +
  geom_vline(linetype = "dotted", xintercept = -1) +
  geom_label_repel(min.segment.length = 0, force = 10, max.overlaps = 20, na.rm = TRUE) +
  labs(title = "Gene counts infant pn56: C2vC3",
       x = expression(~Log[2]~FoldChange),
       y = expression(-~Log[10]~Q)) +
  theme_bw() + xlim(-2, 2)

gene_volcano_pn56e_C2vC3

#ggsave("./forISRHML/gene_volcano_pn56e_C2vC3.svg", gene_volcano_pn56e_C2vC3, width = 4, height = 4.5, dpi = 300)

res_scaled_inf_pn56_C1vC3 <- treeclimbR::runDA(
  TSE = tse_object_scaled_inf_pn56_C1vC3,
  feature_on_row = TRUE,
  assay = 1,
  design_terms = "Cluster"
  )
res_table_scaled_inf_pn56_C1vC3 <- treeclimbR::nodeResult(
  object = res_scaled_inf_pn56_C1vC3,
  n = Inf
  )
candidates_scaled_inf_pn56_C1vC3 <- treeclimbR::getCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_inf_pn56_C1vC3),
  score_data = res_table_scaled_inf_pn56_C1vC3,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC"
  )
da_results_scaled_inf_pn56_C1vC3 <- treeclimbR::evalCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_inf_pn56_C1vC3),
  type = "single",
  levels = candidates_scaled_inf_pn56_C1vC3$candidate_list,
  limit_rej = 0.1,
  score_data = res_table_scaled_inf_pn56_C1vC3,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC",
  use_pseudo_leaf = FALSE
  )

da_results_scaled_inf_pn56_C1vC3$output$names <- TreeSummarizedExperiment::convertNode(
  phylogenetic_tree_inf,
  da_results_scaled_inf_pn56_C1vC3$output$node
  )

# adjusted p-values plot
gene_daa_pn56e_C1vC3 <- da_results_scaled_inf_pn56_C1vC3$output
DT::datatable(gene_daa_pn56e_C1vC3)

#write.xlsx(gene_daa_pn56e_C1vC3, "./forISRHML/gene_daa_pn56e_C1vC3.xlsx")

gene_volcano_pn56e_C1vC3 <- gene_daa_pn56e_C1vC3 |>
  mutate(`adj.p`=-log10(`adj.p`)) |>
  mutate(label=if_else(abs(`logFC`)>1, names, NA_character_)) |>
  mutate(label=if_else(`adj.p` >1.3, names, NA_character_)) |>
  mutate(color=if_else(`logFC`>0, "steelblue", "darkred")) |>
  mutate(color=if_else(is.na(label), "#000000", color)) |>
  ggplot(mapping = aes(`logFC`, `adj.p`, color=I(color), label=label, shape=I(1))) +
  geom_point() +
  geom_hline(linetype = "dotted", yintercept = 1.3) +
  geom_vline(linetype = "dotted", xintercept = 1) +
  geom_vline(linetype = "dotted", xintercept = -1) +
  geom_label_repel(min.segment.length = 0, force = 10, max.overlaps = 20, na.rm = TRUE) +
  labs(title = "Gene counts infant pn56: C1vC3",
       x = expression(~Log[2]~FoldChange),
       y = expression(-~Log[10]~Q)) +
  theme_bw() + xlim(-2, 2)

gene_volcano_pn56e_C1vC3

#ggsave("./forISRHML/gene_volcano_pn56e_C1vC3.svg", gene_volcano_pn56e_C1vC3, width = 4, height = 4.5, dpi = 300)

```

# GESA tri3

```{r}
set.seed(1234)
ONLY_STANFORD_PATHWAYS <- FALSE

message(
  paste0(
    "The `ONLY_STANFORD_PATHWAYS` parameter is set to: ",
    ONLY_STANFORD_PATHWAYS,
    ifelse(
      ONLY_STANFORD_PATHWAYS, 
      " i.e., only microbially related pathways are used.", 
      " i.e., all KEGG pathways are used."
      )
    )
  )

if (ONLY_STANFORD_PATHWAYS) {
  # filtering microbial pathways
  microbial_pathways <- read.csv(microbial_pathways_path, sep="\t")$KO
  gene_to_pathway <- gene_to_pathway[gene_to_pathway$gene %in% microbial_pathways, ]
  pathway_to_gene <- pathway_to_gene[pathway_to_gene$gene %in% microbial_pathways, ]
  pathway_to_description <- pathway_to_description[pathway_to_description$V1 %in% pathway_to_gene$pathway, ]
}

DT::datatable(gene_to_pathway)

metadata_mat <- metadataGut2[metadataGut2$child == "no", ]
metadata_mat_tri3_C2vC1 <-metadata_mat %>%
  filter(timepoint == "tri3") %>%
  filter(Cluster != "C3") %>%
  droplevels()  # Drop unused levels
metadata_mat_tri3_C2vC3 <-metadata_mat %>%
  filter(timepoint == "tri3") %>%
  filter(Cluster != "C1") %>%
  mutate(Cluster = relevel(factor(Cluster), ref = "C3")) %>%
  droplevels()  # Drop unused levels
metadata_mat_tri3_C1vC3 <-metadata_mat %>%
  filter(timepoint == "tri3") %>%
  filter(Cluster != "C2") %>%
  mutate(Cluster = relevel(factor(Cluster), ref = "C3")) %>%
  droplevels()  # Drop unused levels

# counts
gene_counts_mat <- gene_counts[, rownames(metadata_mat)]
gene_counts_mat <- gene_counts_mat[rowSums(gene_counts_mat) != 0, ]
gene_counts_mat_tri3_C2vC1 <- gene_counts_mat[, rownames(metadata_mat_tri3_C2vC1)]
gene_counts_mat_tri3_C2vC3 <- gene_counts_mat[, rownames(metadata_mat_tri3_C2vC3)]
gene_counts_mat_tri3_C1vC3 <- gene_counts_mat[, rownames(metadata_mat_tri3_C1vC3)]


# hierarchy
anno_mat <- gene_anno[rownames(gene_counts_mat), ]
phylogenetic_tree_mat <- TreeSummarizedExperiment::toTree(
  data = anno_mat
  )

# fix order
metadata_mat_tri3_C2vC1 <- metadata_mat_tri3_C2vC1[colnames(gene_counts_mat_tri3_C2vC1), ]
metadata_mat_tri3_C2vC3 <- metadata_mat_tri3_C2vC3[colnames(gene_counts_mat_tri3_C2vC3), ]
metadata_mat_tri3_C1vC3 <- metadata_mat_tri3_C1vC3[colnames(gene_counts_mat_tri3_C1vC3), ]

tse_object_scaled_mat_tri3_C2vC1 <- TreeSummarizedExperiment::TreeSummarizedExperiment(
  assays = list(count = as.matrix(gene_counts_mat_tri3_C2vC1)),
  rowData = anno_mat,
  colData = metadata_mat_tri3_C2vC1,
  rowTree = phylogenetic_tree_mat,
  rowNodeLab = rownames(gene_counts_mat_tri3_C2vC1)
)
tse_object_scaled_mat_tri3_C2vC3 <- TreeSummarizedExperiment::TreeSummarizedExperiment(
  assays = list(count = as.matrix(gene_counts_mat_tri3_C2vC3)),
  rowData = anno_mat,
  colData = metadata_mat_tri3_C2vC3,
  rowTree = phylogenetic_tree_mat,
  rowNodeLab = rownames(gene_counts_mat_tri3_C2vC3)
)
tse_object_scaled_mat_tri3_C1vC3 <- TreeSummarizedExperiment::TreeSummarizedExperiment(
  assays = list(count = as.matrix(gene_counts_mat_tri3_C1vC3)),
  rowData = anno_mat,
  colData = metadata_mat_tri3_C1vC3,
  rowTree = phylogenetic_tree_mat,
  rowNodeLab = rownames(gene_counts_mat_tri3_C1vC3)
)

#' Create a volcano plot from the outputs of a differential abundance analysis
#'
#' @param results A list containing the DA results as outputted in the
#' `treeclimbR::evalCand` function.
#' @param alpha a numeric alpha level on which to cut off p-values
#' @param effect_cutoff a numeric log fold change on which to cut off log FCs
#' @param color_scheme a list of hex valued colors indicating a scheme.
#' @param title title for the plot to export
#'
#' @examples volcano_plot(results, color_scheme)
#' @export
volcano_plot <- function(results,
                         alpha = 0.1,
                         effect_cutoff = 2,
                         color_scheme, 
                         title = "Differential abundance analysis: Volcano plot") {
  # extract elements
  scores <- results$output

  # color on significance groups and add tooltips
  volcano_plot_df <- scores %>%
    mutate(
      significance_group = dplyr::if_else(
        abs(logFC) < effect_cutoff & PValue > alpha,
        "Non-significant",
        dplyr::if_else(
          abs(logFC) < effect_cutoff,
          "Statistically significant (p-values)",
          dplyr::if_else(
            PValue > alpha,
            "Biologically significant (FC)",
            "Biologically & statistically significant"
          )
        )
      ),
      text = paste0(
        "Taxon: ", names, "\n",
        "p-value: ", PValue, "\n",
        "log FC: ", round(logFC, 4), "\n"
      )
    )

  p <- ggplot2::ggplot(
    volcano_plot_df,
    ggplot2::aes(
      x = logFC, y = -log10(PValue),
      color = significance_group,
      text = text
    )
  ) +
    ggplot2::geom_point(size = 3, alpha = 0.8) +
    ggplot2::theme_bw() +
    ggplot2::scale_color_manual(
      values = c(
        "Non-significant" = "#9EA0A5",
        "Biologically significant (FC)" = color_scheme[1],
        "Statistically significant (p-values)" = color_scheme[3],
        "Biologically & statistically significant" = color_scheme[2]
      )
    ) +
    ggplot2::labs(
      title = title,
      x = "Fold change (Log2)",
      y = "p-value (-Log10)"
    ) +
    ggplot2::theme(
      plot.title = ggplot2::element_text(face = "bold"),
      axis.text.x = ggplot2::element_text(vjust = 0.4, hjust = 1),
      axis.text.y = ggplot2::element_text(vjust = 0.4, hjust = 1),
      legend.title = ggplot2::element_blank(),
      legend.position = "right",
      text = ggplot2::element_text(size = 10)
    ) +
    ggplot2::geom_vline(
      xintercept = c(-effect_cutoff, effect_cutoff),
      linetype = "dashed"
    ) +
    ggplot2::geom_hline(
      yintercept = -log10(alpha),
      linetype = "dashed"
    )

  return(plotly::ggplotly(p, tooltip = "text"))
}
```

## Fig3D dot plot for mother gut tri3

```{r treeclimbR mothers tri3 TSS, include=FALSE}

res_scaled_mat_tri3_C2vC1 <- treeclimbR::runDA(
  TSE = tse_object_scaled_mat_tri3_C2vC1,
  feature_on_row = TRUE,
  assay = 1,
  design_terms = "Cluster"
  )
res_table_scaled_mat_tri3_C2vC1 <- treeclimbR::nodeResult(
  object = res_scaled_mat_tri3_C2vC1,
  n = Inf
  )
candidates_scaled_mat_tri3_C2vC1 <- treeclimbR::getCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_mat_tri3_C2vC1),
  score_data = res_table_scaled_mat_tri3_C2vC1,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC"
  )
da_results_scaled_mat_tri3_C2vC1 <- treeclimbR::evalCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_mat_tri3_C2vC1),
  type = "single",
  levels = candidates_scaled_mat_tri3_C2vC1$candidate_list,
  limit_rej = 0.1,
  score_data = res_table_scaled_mat_tri3_C2vC1,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC",
  use_pseudo_leaf = FALSE
  )

da_results_scaled_mat_tri3_C2vC1$output$names <- TreeSummarizedExperiment::convertNode(
  phylogenetic_tree_mat,
  da_results_scaled_mat_tri3_C2vC1$output$node
  )

# adjusted p-values plot
gene_daa_tri3_C2vC1 <- da_results_scaled_mat_tri3_C2vC1$output
DT::datatable(gene_daa_tri3_C2vC1)


tmp <- data.frame(da_results_scaled_mat_tri3_C2vC1$output[, c("logFC", "names")])
# the DA lists also include CARD, CAZyme, and HMO genes, but we only have mappings for KEGG atm
kegg_genes_tmp <- tmp$names %in% gene_anno[gene_anno$database == "KEGG", "anno"]
tmp <- tmp[kegg_genes_tmp, ]
gene_list_scaled_mat_tri3_C2vC1 <- tmp[,1]
names(gene_list_scaled_mat_tri3_C2vC1) <- as.character(tmp[, 2])
gene_list_scaled_mat_tri3_C2vC1 <- sort(gene_list_scaled_mat_tri3_C2vC1, decreasing = TRUE)
#GSEA
kk_scaled_mat_tri3_C2vC1 <- clusterProfiler::GSEA(
  geneList = gene_list_scaled_mat_tri3_C2vC1, 
  minGSSize = 1,
  pvalueCutoff = 0.1,
  TERM2GENE = pathway_to_gene, 
  TERM2NAME = pathway_to_description
  )

# Extract data from dotplot object
enrich_mat_tri3_C2vC1 <- kk_scaled_mat_tri3_C2vC1@result  %>%
  mutate(Description = str_wrap(Description, width = 27)) %>%
  arrange(enrichmentScore) %>%
  mutate(Description = factor(Description, levels = Description)) %>%
  filter(setSize > 20)

#write.xlsx(enrich_inf_pn12_C2vC1, "./forISRHML/enrich_inf_pn12_C2vC1.xlsx")


# Create the customized dot plot manually
enrich_tri3_C2vC1 <- ggplot(enrich_mat_tri3_C2vC1, aes(x = enrichmentScore, y = Description)) +
    geom_segment(aes(x = 0, xend = enrichmentScore, y = Description, yend = Description),linetype = "solid", color = "grey50", size = 0.3) +
  geom_point(aes(
    color = p.adjust,
    size = setSize
  )) +
  scale_color_gradientn(
    colors = COLOR_SCHEME2[1:4],  # Apply color scale based on p.adjust
    limits = c(0, 0.1),  # Apply color scale based on p.adjust
    name = "p.adjust"
  ) +
  scale_size_continuous(
    breaks = c(20, 60, 100),  # Define size categories for count
    labels = c("20", "60", "100"),
    range = c(1, 7),  # Adjust point size range
    name = "setSize"
  ) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", size = 0.3) +
  xlim(-1, 1) +  
  # Remove grid lines while keeping background
  theme_bw() +  
  theme(
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    panel.border = element_rect(color = "black", size = 0.6),  # Keep border
    legend.position = "right",
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    axis.text.y = element_text(size = 10, lineheight = 0.7) 
  ) +
  labs(
    title = "Mother Tri3: C2vC1",
    x = "Enrichment Score",
    y = "Pathway"
  )

enrich_tri3_C2vC1

# Save as SVG with a 1.5 aspect ratio
#ggsave("./forISRHML/enrich_tri3_C2vC1.svg", enrich_tri3_C2vC1, width = 5.7, height = 4.5, dpi = 300)

res_scaled_mat_tri3_C2vC3 <- treeclimbR::runDA(
  TSE = tse_object_scaled_mat_tri3_C2vC3,
  feature_on_row = TRUE,
  assay = 1,
  design_terms = "Cluster"
  )
res_table_scaled_mat_tri3_C2vC3 <- treeclimbR::nodeResult(
  object = res_scaled_mat_tri3_C2vC3,
  n = Inf
  )
candidates_scaled_mat_tri3_C2vC3 <- treeclimbR::getCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_mat_tri3_C2vC3),
  score_data = res_table_scaled_mat_tri3_C2vC3,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC"
  )
da_results_scaled_mat_tri3_C2vC3 <- treeclimbR::evalCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_mat_tri3_C2vC3),
  type = "single",
  levels = candidates_scaled_mat_tri3_C2vC3$candidate_list,
  limit_rej = 0.1,
  score_data = res_table_scaled_mat_tri3_C2vC3,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC",
  use_pseudo_leaf = FALSE
  )

da_results_scaled_mat_tri3_C2vC3$output$names <- TreeSummarizedExperiment::convertNode(
  phylogenetic_tree_mat,
  da_results_scaled_mat_tri3_C2vC3$output$node
  )

# adjusted p-values plot
gene_daa_tri3_C2vC3 <- da_results_scaled_mat_tri3_C2vC3$output
DT::datatable(gene_daa_tri3_C2vC3)


tmp <- data.frame(da_results_scaled_mat_tri3_C2vC3$output[, c("logFC", "names")])
# the DA lists also include CARD, CAZyme, and HMO genes, but we only have mappings for KEGG atm
kegg_genes_tmp <- tmp$names %in% gene_anno[gene_anno$database == "KEGG", "anno"]
tmp <- tmp[kegg_genes_tmp, ]
gene_list_scaled_mat_tri3_C2vC3 <- tmp[,1]
names(gene_list_scaled_mat_tri3_C2vC3) <- as.character(tmp[, 2])
gene_list_scaled_mat_tri3_C2vC3 <- sort(gene_list_scaled_mat_tri3_C2vC3, decreasing = TRUE)
#GSEA
kk_scaled_mat_tri3_C2vC3 <- clusterProfiler::GSEA(
  geneList = gene_list_scaled_mat_tri3_C2vC3, 
  minGSSize = 1,
  pvalueCutoff = 0.1,
  TERM2GENE = pathway_to_gene, 
  TERM2NAME = pathway_to_description
  )

# Extract data from dotplot object
enrich_mat_tri3_C2vC3 <- kk_scaled_mat_tri3_C2vC3@result  %>%
  mutate(Description = str_wrap(Description, width = 27)) %>%
  arrange(enrichmentScore) %>%
  mutate(Description = factor(Description, levels = Description)) %>%
  filter(setSize > 20)

#write.xlsx(enrich_inf_pn12_C2vC1, "./forISRHML/enrich_inf_pn12_C2vC1.xlsx")


# Create the customized dot plot manually
enrich_tri3_C2vC3 <- ggplot(enrich_mat_tri3_C2vC3, aes(x = enrichmentScore, y = Description)) +
    geom_segment(aes(x = 0, xend = enrichmentScore, y = Description, yend = Description),linetype = "solid", color = "grey50", size = 0.3) +
  geom_point(aes(
    color = p.adjust,
    size = setSize
  )) +
  scale_color_gradientn(
    colors = COLOR_SCHEME2[1:4],  # Apply color scale based on p.adjust
    limits = c(0, 0.1),  # Apply color scale based on p.adjust
    name = "p.adjust"
  ) +
  scale_size_continuous(
    breaks = c(20, 60, 100),  # Define size categories for count
    labels = c("20", "60", "100"),
    range = c(1, 7),  # Adjust point size range
    name = "setSize"
  ) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", size = 0.3) +
  xlim(-1, 1) +  
  # Remove grid lines while keeping background
  theme_bw() +  
  theme(
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    panel.border = element_rect(color = "black", size = 0.6),  # Keep border
    legend.position = "right",
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    axis.text.y = element_text(size = 10, lineheight = 0.7) 
  ) +
  labs(
    title = "Mother Tri3: C2vC3",
    x = "Enrichment Score",
    y = "Pathway"
  )

enrich_tri3_C2vC3

# Save as SVG with a 1.5 aspect ratio
#ggsave("./forISRHML/enrich_tri3_C2vC3.svg", enrich_tri3_C2vC3, width = 5.7, height = 4.5, dpi = 300)

res_scaled_mat_tri3_C1vC3 <- treeclimbR::runDA(
  TSE = tse_object_scaled_mat_tri3_C1vC3,
  feature_on_row = TRUE,
  assay = 1,
  design_terms = "Cluster"
  )
res_table_scaled_mat_tri3_C1vC3 <- treeclimbR::nodeResult(
  object = res_scaled_mat_tri3_C1vC3,
  n = Inf
  )
candidates_scaled_mat_tri3_C1vC3 <- treeclimbR::getCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_mat_tri3_C1vC3),
  score_data = res_table_scaled_mat_tri3_C1vC3,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC"
  )
da_results_scaled_mat_tri3_C1vC3 <- treeclimbR::evalCand(
  tree = TreeSummarizedExperiment::rowTree(tse_object_scaled_mat_tri3_C1vC3),
  type = "single",
  levels = candidates_scaled_mat_tri3_C1vC3$candidate_list,
  limit_rej = 0.1,
  score_data = res_table_scaled_mat_tri3_C1vC3,
  node_column = "node",
  p_column = "PValue",
  sign_column = "logFC",
  use_pseudo_leaf = FALSE
  )

da_results_scaled_mat_tri3_C1vC3$output$names <- TreeSummarizedExperiment::convertNode(
  phylogenetic_tree_mat,
  da_results_scaled_mat_tri3_C1vC3$output$node
  )

# adjusted p-values plot
gene_daa_tri3_C1vC3 <- da_results_scaled_mat_tri3_C1vC3$output
DT::datatable(gene_daa_tri3_C1vC3)


tmp <- data.frame(da_results_scaled_mat_tri3_C1vC3$output[, c("logFC", "names")])
# the DA lists also include CARD, CAZyme, and HMO genes, but we only have mappings for KEGG atm
kegg_genes_tmp <- tmp$names %in% gene_anno[gene_anno$database == "KEGG", "anno"]
tmp <- tmp[kegg_genes_tmp, ]
gene_list_scaled_mat_tri3_C1vC3 <- tmp[,1]
names(gene_list_scaled_mat_tri3_C1vC3) <- as.character(tmp[, 2])
gene_list_scaled_mat_tri3_C1vC3 <- sort(gene_list_scaled_mat_tri3_C1vC3, decreasing = TRUE)
#GSEA
kk_scaled_mat_tri3_C1vC3 <- clusterProfiler::GSEA(
  geneList = gene_list_scaled_mat_tri3_C1vC3, 
  minGSSize = 1,
  pvalueCutoff = 0.1,
  TERM2GENE = pathway_to_gene, 
  TERM2NAME = pathway_to_description
  )


# Extract data from dotplot object
enrich_mat_tri3_C1vC3 <- kk_scaled_mat_tri3_C1vC3@result  %>%
  mutate(Description = str_wrap(Description, width = 27)) %>%
  arrange(enrichmentScore) %>%
  mutate(Description = factor(Description, levels = Description)) %>%
  filter(setSize > 20)

#write.xlsx(enrich_inf_pn12_C2vC1, "./forISRHML/enrich_inf_pn12_C2vC1.xlsx")


# Create the customized dot plot manually
enrich_tri3_C1vC3 <- ggplot(enrich_mat_tri3_C1vC3, aes(x = enrichmentScore, y = Description)) +
    geom_segment(aes(x = 0, xend = enrichmentScore, y = Description, yend = Description),linetype = "solid", color = "grey50", size = 0.3) +
  geom_point(aes(
    color = p.adjust,
    size = setSize
  )) +
  scale_color_gradientn(
    colors = COLOR_SCHEME2[1:4],  # Apply color scale based on p.adjust
    limits = c(0, 0.1),  # Apply color scale based on p.adjust
    name = "p.adjust"
  ) +
  scale_size_continuous(
    breaks = c(20, 60, 100),  # Define size categories for count
    labels = c("20", "60", "100"),
    range = c(1, 7),  # Adjust point size range
    name = "setSize"
  ) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", size = 0.3) +
  xlim(-1, 1) +  
  # Remove grid lines while keeping background
  theme_bw() +  
  theme(
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    panel.border = element_rect(color = "black", size = 0.6),  # Keep border
    legend.position = "right",
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    axis.text.y = element_text(size = 10, lineheight = 0.7) 
  ) +
  labs(
    title = "Mother Tri3: C1vC3",
    x = "Enrichment Score",
    y = "Pathway"
  )

enrich_tri3_C1vC3

# Save as SVG with a 1.5 aspect ratio
#ggsave("./forISRHML/enrich_tri3_C1vC3.svg", enrich_tri3_C1vC3, width = 5.7, height = 4.5, dpi = 300)

```

# HMO

## Fig5A bar plot

```{r}

hmo_names <- c("X2.FL_nmol.mL", "X3FL_nmol.mL", "DFLac_nmol.mL", "X3.SL_nmol.mL", "X6.SL_nmol.mL", "LNT_nmol.mL", "LNnT_nmol.mL", "LNFP.I_nmol.mL", "LNFP.II_nmol.mL", "LNFP.III_nmol.mL", "LSTb_nmol.mL", "LSTc_nmol.mL", "DFLNT_nmol.mL", "LNH_nmol.mL", "DSLNT_nmol.mL", "FLNH_nmol.mL", "DFLNH_nmol.mL", "FDSLNH_nmol.mL", "DSLNH_nmol.mL")
hmo_colors <- c("#228585", "bisque3","#f4cccc", "#d0f679", "#e69138", "lightblue", "coral1", "#cfe2f3", "cadetblue", "#2986cc", "#cd0000", "#6aa84f",  "gray", "#28E2E5","#483D8B", "#2F4F4F", "#8B0A50", "#104E8E", "#A6611A", "brown")

library(stringr)

# Convert to long format and clean HMO names
hmo_long <- hmoMeta %>%
  dplyr::select(idbs, timepoint, Secretor, contains("nmol.mL")) %>%
  left_join(row_annotation_idbs, by = "idbs") %>%  # Perform the join
  mutate(sum = SUM_nmol.mL) %>%
  dplyr::select(-Sia_nmol.mL, -Fuc_nmol.mL, -SUM_nmol.mL) %>%
  pivot_longer(cols = contains("nmol.mL"), names_to = "hmo", values_to = "value") %>%
  mutate(hmo = str_remove(hmo, "_nmol\\.mL")) %>%  # Remove the "_nmol.mL" suffix
  filter(!is.na(Cluster))

# Calculate the average value of each HMO by Secretor status and timepoint
hmo_avg <- hmo_long %>%
  group_by(Cluster, timepoint, hmo) %>%
  dplyr::summarise(average_value = mean(value, na.rm = TRUE)) %>%
  ungroup()

# Sort HMOs by the average value (for ordering in plots)
sort_hmo <- hmo_avg %>%
  group_by(hmo) %>%
  dplyr::summarise(total_avg_value = sum(average_value, na.rm = TRUE)) %>%
  arrange(desc(total_avg_value)) %>%
  slice_head(n = 22) %>%
  pull(hmo)

# Create plot using the average values
hmo_avg_plot <- hmo_avg %>%
  mutate(hmo = factor(hmo, levels = sort_hmo)) %>%
  ggplot(aes(x = Cluster, y = average_value, fill = hmo)) +
  geom_bar(stat = 'identity', position = 'stack') +  # Use stat = 'identity' for actual values
  scale_fill_manual(breaks = sort_hmo, values = hmo_colors) + 
  facet_wrap(~ timepoint, ncol = 3) +  # Create separate plots for each Secretor status
  theme(axis.text.x = element_text(size = 8),
        legend.title = element_text(size = 8),
        legend.key.size = unit(0.3, 'cm'),
        legend.text = element_text(size = 8)) +
  labs(x = "", y = "Average Value (nmol/mL)", fill = "HMO") +
  theme(panel.grid = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        axis.ticks.x = element_blank()) +
  guides(fill = guide_legend(ncol = 1))

hmo_avg_plot

#svglite::svglite(
#  filename = "./forISRHML/hmo_avg_plot2.svg",
#  width = 5, height = 3
#)
#hmo_avg_plot
#dev.off()

```

## Fig5B line plot

```{r}

# Filter, reshape, and summarize the dataset
hmo_summary <- hmoMeta %>%
  dplyr::select(idbs, timepoint, Secretor, Diversity, contains("nmol.mL")) %>%
  left_join(row_annotation_idbs, by = "idbs") %>%  # Perform the join
  mutate(sum = SUM_nmol.mL) %>%
  #dplyr::select(-Sia_nmol.mL, -Fuc_nmol.mL, -SUM_nmol.mL) %>%
  pivot_longer(cols = c(Diversity, ends_with("nmol.mL")), names_to = "hmo", values_to = "value") %>%
  mutate(hmo = str_remove(hmo, "_nmol\\.mL")) %>%  # Remove the "_nmol.mL" suffix
  group_by(timepoint, Cluster, hmo) %>%
  dplyr::summarise(
    mean_value = mean(value, na.rm = TRUE),
    se_value = sd(value, na.rm = TRUE) / sqrt(n()), # Standard error
    .groups = "drop" # Ungroup after summarizing
  ) %>%
  filter(!is.na(Cluster))

# Calculate max_value and create ordered levels
hmo_levels <- hmo_summary %>%
  group_by(hmo) %>%
  dplyr::summarise(max_value = max(mean_value, na.rm = TRUE)) %>%
  arrange(desc(max_value)) %>%
  pull(hmo)

hmo_summary <- hmo_summary %>%
  mutate(hmo = factor(hmo, levels = hmo_levels))

# Step 3: Plot with ordered facets
# Step 1: Compute p-values for each variable and timepoint
p_values_data <- hmo_long %>%
  group_by(hmo, timepoint) %>%
  dplyr::summarise(
    p_value = anova(
      lm(value ~ Cluster, data = cur_data())
    )$`Pr(>F)`[1],  # Extract p-value for the 'Cluster' variable
    max_y = max(hmo_summary$mean_value[hmo_summary$hmo == unique(hmo) &
                                         hmo_summary$timepoint == unique(timepoint)], na.rm = TRUE), # Find max y for this facet
    .groups = "drop"
  ) %>%
  # Apply BH FDR correction to p-values
  mutate(adj_p_value = p.adjust(p_value, method = "BH")) %>%
  # Define significance based on adjusted p-values
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      adj_p_value > 0.1 & p_value <= 0.05 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )

# Step 2: Plot with error bars and p-values dynamically placed
hmo_plot <- ggplot(hmo_summary, aes(x = timepoint, y = mean_value, color = Cluster, group = Cluster)) +
  geom_line() +                               # Line for each Cluster
  geom_point() +                              # Points for mean at each visit
  geom_errorbar(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), width = 0.2) + # Error bars
  facet_wrap(~ hmo, scales = "free_y", ncol = 4) +  # Separate panels for each variable
  scale_color_manual(values = COLOR_SCHEME) +  # Apply the custom color scheme
  labs(
    x = "Timepoint",
    y = "HMOs (nmol/mL)",
    color = "Cluster"
  ) +
  theme_bw() +
  theme(
    legend.position = "bottom",
    strip.text = element_text(size = 10),
    panel.grid = element_blank()
  ) +
  
  # Step 4: Add p-values dynamically to each panel at the correct y position
  geom_text(
    data = p_values_data %>%
      mutate(hmo = factor(hmo, levels = levels(hmo_summary$hmo))),  # Match reordered facets
    aes(
      x = as.numeric(as.factor(timepoint)),  # Adjust x position dynamically
      y = max_y + 0.2 * max_y,  # Use max_y + 0.1 for spacing above the highest point
      label = significance
    ),
    inherit.aes = FALSE,
    size = 5,
    color = "darkred"
  )
# Step 4: Display the plot
hmo_plot

#ggsave("./forISRHML/hmo_plot.svg", hmo_plot, width = 8, height = 8, dpi = 300)

```

## FigS1 bar plot cluster per secretor

```{r}

hmo_tem <- hmoMeta %>%  
  dplyr::select(idbs, timepoint, Secretor, Diversity, contains("nmol.mL")) %>%
  left_join(row_annotation_idbs, by = "idbs") %>%
  filter(timepoint == "pn12") %>%
  select(idbs, Secretor, Cluster) %>%
  filter(!is.na(Cluster))

table_cluster_secretor <- table(hmo_tem$Cluster, hmo_tem$Secretor)
prop.table(table_cluster_secretor, margin = 1) * 100
chisq.test(table_cluster_secretor)

# Pairwise proportion test with Bonferroni correction
pairwise.prop.test(
  x = table_cluster_secretor[, "1"],  # count of Secretors
  n = rowSums(table_cluster_secretor), # total per cluster
  p.adjust.method = "bonferroni"
)

hmo_tem_plot <- hmo_tem %>%
  dplyr::count(Cluster, Secretor) %>%
  dplyr::group_by(Cluster) %>%
  dplyr::mutate(perc = 100 * n / sum(n)) %>%
  ggplot(aes(x = Cluster, y = perc, fill = factor(Secretor))) +
  geom_col(position = "stack") +
  scale_y_continuous(labels = scales::percent_format(scale = 1)) +
  labs(
    x = "Infant Gut Cluster",
    y = "% Secretor Status",
    fill = "Secretor"
  ) +
  theme_minimal()
hmo_tem_plot
#ggsave("./forISRHML/Jun2_hmo_secretor_plot.svg", hmo_tem_plot, width = 4, height = 2 , dpi = 300)

table(hmo_tem$Secretor[hmo_tem$Cluster=="C1"])
table(hmo_tem$Secretor[hmo_tem$Cluster=="C2"])
table(hmo_tem$Secretor[hmo_tem$Cluster=="C3"])

hmo_avg <- hmo_long %>%
  group_by(Secretor, timepoint, hmo) %>%
  dplyr::summarise(average_value = mean(value, na.rm = TRUE)) %>%
  ungroup()

hmo_avg_plot <- hmo_avg %>%
  mutate(hmo = factor(hmo, levels = sort_hmo)) %>%
  ggplot(aes(x = timepoint, y = average_value, fill = hmo)) +
  geom_bar(stat = 'identity', position = 'stack') +  # Use stat = 'identity' for actual values
  scale_fill_manual(breaks = sort_hmo, values = hmo_colors) + 
  facet_wrap(~ Secretor, ncol = 3) +  # Create separate plots for each Secretor status
  theme(axis.text.x = element_text(size = 8),
        legend.title = element_text(size = 8),
        legend.key.size = unit(0.3, 'cm'),
        legend.text = element_text(size = 8)) +
  labs(x = "", y = "Average Value (nmol/mL)", fill = "HMO") +
  theme(panel.grid = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        axis.ticks.x = element_blank()) +
  guides(fill = guide_legend(ncol = 1))

hmo_avg_plot

```

# Milk nutrients

## FigS2 line plot individual

```{r}

# Reshape nutrient variables into long format
metadata_vars <- colnames(metadata)

milk_long <- milkMeta %>%
  dplyr::select(idbs, timepoint, !all_of(metadata_vars), -abo) %>%
  pivot_longer(
    cols = -c(idbs, timepoint),
    names_to = "nutrient",
    values_to = "value"
  )

nutrient_order <- c(
  "FAT", "PROTEIN", "CARBOHYDRATE", "Kcal.L",
  "FGF.21", "FSH", "Insulin", "LH", "Leptin", "Calprotectin", "IgA",
  "Na", "Mg", "P.", "K.", "Ca", "Cr", "Fe", "Cu", "Zn", "Mo", "As", "Mn", "Se",
  "Ribo", "FMN", "FAD", "B2", "NAM", "NAD", "NMN", "NR", "B3",
  "Nufa", "PA", "PL", "PM", "PN", "PLP", "B6", "Bio", "TRP",
  "TPP", "TMP", "T", "B1", "B12", "g.tocopherol", "a.tocopherol", "vitamin.A"
)
milk_long$nutrient <- factor(milk_long$nutrient, levels = nutrient_order)

nutrient_lineplot <- ggplot(milk_long, aes(x = timepoint, y = value, group = idbs)) +
  geom_line(alpha = 0.3, color = "gray") +                  # Individual trajectories
  stat_summary(fun = mean, geom = "line", aes(group = 1),   # Mean trend line
               color = "blue", size = 0.8) +
  facet_wrap(~ nutrient, scales = "free_y", ncol = 7) +               # One panel per nutrient
  labs(
    x = "Timepoint",
    y = "Nutrient level",
    title = "Change in Milk Nutrients Over Time"
  ) +
  theme_bw() +
  theme(
    strip.text = element_text(size = 10),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
nutrient_lineplot
#svglite::svglite(
#  filename = "./forISRHML/Jun2_nutrient_lineplot.svg",
#  width = 13, height = 13
#)
#nutrient_lineplot
#dev.off()

```

## Fig6B sig nutrients line plot

```{r}

desired_order <- c("FAT", "PROTEIN", "Kcal.L", "Insulin", "P.", "K.", "Fe", "Zn", "As", "Mn", "FAD", "B2", "NAD", "NR", "TPP")

milkMetaCluster <- milkMeta %>%
    dplyr::select(timepoint, idbs, code, "FAT", "PROTEIN", "Kcal.L", "Insulin", "P.", "K.", "Fe", "Zn", "As", "Mn", "FAD", "B2", "NAD", "NR", "TPP") %>%
  left_join(row_annotation_idbs, by = "idbs") %>%  # Perform the join
  filter(!is.na(Cluster)) %>%
  pivot_longer(cols = c(-timepoint, -idbs, -code, -Cluster), names_to = "milkMetaCluster", values_to = "value")

# Step 1: Summarize data for each nutrient and timepoint
milkMetaCluster_summary <- milkMetaCluster %>% 
  group_by(timepoint, Cluster, milkMetaCluster) %>% 
  dplyr::summarise(
    mean_value = mean(value, na.rm = TRUE),
    se_value = sd(value, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  )

# Ensure the milkMetaCluster variable has the correct order
milkMetaCluster_summary <- milkMetaCluster_summary %>%
  mutate(milkMetaCluster = factor(milkMetaCluster, levels = desired_order)) %>%
  group_by(milkMetaCluster) %>%
  mutate(max_value = max(mean_value, na.rm = TRUE)) %>%
  ungroup()

# Step 2: Calculate p-values and adjusted p-values for significance
p_values_data <- milkMetaCluster %>% 
  group_by(milkMetaCluster, timepoint) %>% 
  dplyr::summarise(
    p_value = { 
      anova_table <- anova(lm(value ~ Cluster + code, data = cur_data())) 
      anova_table$`Pr(>F)`[rownames(anova_table) == "Cluster"] 
    },
    max_y = max(milkMetaCluster_summary$mean_value[milkMetaCluster_summary$milkMetaCluster == unique(milkMetaCluster) & 
                                                   milkMetaCluster_summary$timepoint == unique(timepoint)], na.rm = TRUE),
    min_y = min(milkMetaCluster_summary$mean_value[milkMetaCluster_summary$milkMetaCluster == unique(milkMetaCluster)], na.rm = TRUE),
    .groups = "drop"
  ) %>%
  # Adjust p-values using BH FDR correction
  mutate(adj_p_value = p.adjust(p_value, method = "BH")) %>%

  # Define significance based on adjusted p-values
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value significance
      adj_p_value <= 0.01 ~ "**",
      adj_p_value <= 0.05 ~ "*",
      adj_p_value <= 0.1 ~ ".",
      adj_p_value > 0.1 & p_value <= 0.05 ~ "~",  # This is the new condition for significance
      TRUE ~ ""
    )
  )

# Step 3: Plot with error bars and p-values dynamically placed
milkMetaCluster_plot <- ggplot(milkMetaCluster_summary, aes(x = timepoint, y = mean_value, color = Cluster, group = Cluster)) +
  geom_line() +  # Line for each Cluster
  geom_point() +  # Points for mean at each visit
  geom_errorbar(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), width = 0.2) +  # Error bars
  facet_wrap(~ milkMetaCluster, scales = "free_y", ncol = 8) +  # Separate panels for each variable
  scale_color_manual(values = COLOR_SCHEME) +  # Apply the custom color scheme
  labs(
    x = "Timepoint",
    y = "Important Milk",
    color = "Cluster"
  ) +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    strip.text = element_text(size = 10), 
    panel.grid = element_blank()
  ) +
  
  # Dynamically adjust y-axis limits for better fit
  geom_text(
    data = p_values_data %>%
      mutate(milkMetaCluster = factor(milkMetaCluster, levels = levels(milkMetaCluster_summary$milkMetaCluster))),  # Match reordered facets
    aes(
      x = as.numeric(as.factor(timepoint)),  # Adjust x position dynamically
      y = max_y + 0.4 * (max_y - min_y),  # Adjust based on dynamic data range
      label = significance  # Use the significance labels here
    ),
    inherit.aes = FALSE,
    size = 5,
    color = "darkred"
  )

# Step 4: Display the plot
milkMetaCluster_plot

#svglite::svglite(
#  filename = "./forISRHML/milkMetaClusterLine.svg",
#  width = 14, height = 3.7
#)
#milkMetaCluster_plot
#dev.off()

```

# Milk metabolites

## FigureS9 top xgb 15 important features

```{r}
pn12e_species <- pn12e_meta %>%
  tax_glom(taxrank = "species") %>%  # Aggregate at genus level
  transform_sample_counts(function(x) x / sum(x)) %>%  # Convert to relative abundance
  psmelt() %>%  # Melt the phyloseq object into long format
  filter(Abundance > 0) 

pn12e_species_infantis <- pn12e_species %>%
  dplyr::select(idbs, `Cluster`) %>%
  dplyr::distinct()
pn12e_species_infantis$idbs <- as.character(pn12e_species_infantis$idbs)

metaboliteXG_pn34 <- metabolite_pn34 %>%
  distinct(idbs, .keep_all = TRUE) %>%
  mutate(across(everything(), as.numeric)) %>%
  select(where(~!all(. == 0))) %>%
    left_join(pn12e_species_infantis, by = "idbs") %>%
  select(-idbs) %>%
  dplyr::mutate(class = if_else(Cluster=="C1", 0, if_else(Cluster=="C2", 1, 2))) %>%
  dplyr::select(-Cluster) %>%
  filter(!is.na(class))

# Set seed for reproducibility

set.seed(123)

data <- metaboliteXG_pn34
file_name <- "metaboliteXG_pn34_Oct2"

# Split data into training and testing datasets

splitIndex <- 
  sample(1:nrow(data), size = 0.75 * nrow(data))

# Prepare feature matrix (xMatrix) and target vector (yVector)

xMatrix <- 
  data %>% dplyr::select(-class) %>% 
  as.matrix()

yVector <- 
  data$class

# Create training and testing datasets

trainData <- 
  xMatrix[splitIndex,]

trainLabels <- 
  yVector[splitIndex]

testData <- 
  xMatrix[-splitIndex,]

testLabels <- 
  yVector[-splitIndex]

remove(splitIndex, 
       xMatrix, 
       yVector)


# Set cores

numCores <- 
  detectCores() - 1 # Use one less than the total number of cores

registerDoParallel(cores = numCores)


# XGBoost ¬∑ Train


# Create DMatrix for XGBoost

trainXGBDMatrix <- 
  xgb.DMatrix(data = trainData, 
              label = trainLabels)

# Define number of classes

numberOfClasses <- 
  length(unique(data$class))

# Define XGBoost parameters for multiclass classification

xGBParameters <- 
  list("objective" = "multi:softprob",
       "eval_metric" = "mlogloss",
       "num_class" = numberOfClasses)

# Specify number of rounds for cross-validation

numberRounds <- 
  50 

# Specify number of folds for cross-validation

numberFolds <- 
  5

# Perform cross-validation

modelXGBCvInitial <- 
  xgb.cv(params = xGBParameters,
         data = trainXGBDMatrix, 
         nrounds = numberRounds,
         nfold = numberFolds,
         verbose = FALSE,
         prediction = TRUE)

# Find the best number of rounds

numberRoundsBest <- 
  which.min(modelXGBCvInitial$evaluation_log$test_mlogloss_mean)

# Train final model on the entire training set using the best number of rounds

modelXGBCvFinal <- 
  xgb.train(params = xGBParameters,
            data = trainXGBDMatrix, 
            nrounds = numberRoundsBest)

# Predict using your final model

trainPredictions <- 
  predict(modelXGBCvFinal, 
          trainXGBDMatrix)

# Convert predictions to class labels based on maximum probability

trainPredictionLabels <- 
  max.col(matrix(trainPredictions, 
                 ncol = numberOfClasses)) - 1 # Adjust index if necessary

# Generate confusion matrix

trainConfusionMatrix <- 
  confusionMatrix(factor(trainPredictionLabels), 
                  factor(trainLabels), 
                  mode = "everything")

# Print the confusion matrix

print(trainConfusionMatrix)

# Reshape the predictions into a matrix

trainPredictionsMatrix <- 
  matrix(trainPredictions, 
         ncol = numberOfClasses, byrow = FALSE)

# Ensure the row names match with your original data, if necessary

rownames(trainPredictionsMatrix) <- 
  rownames(trainData)

# Assuming you have 4 classes and predictionsMatrix ready

trainAucList <- 
  lapply(1:3, function(i) 
    {
    actualBinary <- 
      ifelse(trainLabels == (i-1), 1, 0)  # Adjust class labels to match 0 indexing
    rocResult <- 
      roc(response = actualBinary, 
          predictor = trainPredictionsMatrix[, i])
    return(auc(rocResult))
    })

# Calculate the Area Under the Curve (AUC) for the training dataset

trainAuc <- 
  mean(sapply(trainAucList, 
              function(x) x))

print(trainAuc)

# Export confusion matrix

termAndEstimateXGBTrain <-
  tidy(trainConfusionMatrix) %>% 
  filter(term %in% "accuracy") %>% 
  select(conf.low, conf.high, p.value) %>% 
  pivot_longer(everything(),
               names_to = "term",
               values_to = "estimate")

confusionMatrixXGBTrain <-
  tidy(trainConfusionMatrix) %>% 
  mutate(estimate = case_when(
    term == "mcnemar" ~ p.value,
    TRUE ~ estimate)) %>% 
  select(term, class, estimate) %>% 
  bind_rows(termAndEstimateXGBTrain) %>% 
  bind_rows(tibble(term = "auc",
                   estimate = as.numeric(trainAuc))) %>% 
  mutate(cellSpot = file_name) %>% 
  mutate(model = "train") %>% 
  arrange(match(term, c("accuracy", "conf.low", "conf.high", "p.value"))) %>% 
  mutate(term = case_when(
    term == "conf.low" ~ "ciLow",
    term == "conf.high" ~ "ciHigh",
    term == "p.value" ~ "pValue",
    term == "pos_pred_value" ~ "positivePredictiveValue",
    term == "neg_pred_value" ~ "negativePredictiveValue",
    term == "detection_rate" ~ "dectectionRate",
    term == "detection_prevalence" ~ "dectectionPrevalence",
    term == "balanced_accuracy" ~ "balancedAccuracy",
    TRUE ~ term))



# XGBoost ¬∑ Test


# Create test DMatrix for XGBoost

testXGBDMatrix <- 
  xgb.DMatrix(data = testData, 
              label = testLabels)

# Predict on the testing dataset

testPredictions <- 
  predict(modelXGBCvFinal, 
          newdata = testXGBDMatrix)

# Convert predictions to class labels based on maximum probability

testPredictionLabels <- 
  max.col(matrix(testPredictions, 
                 ncol = numberOfClasses)) - 1 # Adjust index if necessary

# Generate confusion matrix

testConfusionMatrix <- 
  confusionMatrix(factor(testPredictionLabels), 
                  factor(testLabels), 
                  mode = "everything")

# Print the confusion matrix

print(testConfusionMatrix)

# Reshape the predictions into a matrix

testPredictionsMatrix <- 
  matrix(testPredictions, 
         ncol = numberOfClasses,
         byrow = FALSE)

# Ensure the row names match with your original data, if necessary

rownames(testPredictionsMatrix) <- 
  rownames(testData)

# Assuming you have 4 classes and predictionsMatrix ready

testAucList <- 
  lapply(1:3, function(i) 
    {
    actualBinary <- 
      ifelse(testLabels == (i-1), 1, 0)  # Adjust class labels to match 0 indexing
    rocResult <- 
      roc(response = actualBinary, 
          predictor = testPredictionsMatrix[, i])
    return(auc(rocResult))
    })

# Calculate the Area Under the Curve (AUC) for the training dataset

testAuc <- 
  mean(sapply(testAucList, 
              function(x) x))

print(testAuc)

termAndEstimateXGBTest <-
  tidy(testConfusionMatrix)%>% 
  filter(term %in% "accuracy") %>% 
  select(conf.low, conf.high, p.value) %>% 
  pivot_longer(everything(),
               names_to = "term",
               values_to = "estimate")

confusionMatrixXGBTest <-
  tidy(testConfusionMatrix) %>% 
  mutate(estimate = case_when(
    term == "mcnemar" ~ p.value,
    TRUE ~ estimate)) %>% 
  select(term, class, estimate) %>% 
  bind_rows(termAndEstimateXGBTest) %>% 
  bind_rows(tibble(term = "auc",
                   estimate = as.numeric(testAuc))) %>% 
  mutate(cellSpot = file_name) %>% 
  mutate(model = "test") %>% 
  arrange(match(term, c("accuracy", "conf.low", "conf.high", "p.value"))) %>% 
  mutate(term = case_when(
    term == "conf.low" ~ "ciLow",
    term == "conf.high" ~ "ciHigh",
    term == "p.value" ~ "pValue",
    term == "pos_pred_value" ~ "positivePredictiveValue",
    term == "neg_pred_value" ~ "negativePredictiveValue",
    term == "detection_rate" ~ "dectectionRate",
    term == "detection_prevalence" ~ "dectectionPrevalence",
    term == "balanced_accuracy" ~ "balancedAccuracy",
    TRUE ~ term))


## pn34
# Get feature importance
feature_importance <- xgb.importance(feature_names = colnames(testData), model = modelXGBCvFinal)

# Print the top important features
print(head(feature_importance, 15))  # Show top 20 important features

feature_importance_df <- as.data.frame(feature_importance)

xgboostMetabpn34 <- feature_importance_df[1:15, 1]
# pn34: AUC 0.6874446

metabolite_feature_pn34 <- ggplot(feature_importance_df[1:15, ], aes(x = reorder(Feature, Gain), y = Gain)) +
  geom_bar(stat = "identity", fill = "blue") +
  coord_flip() +  # Flip for better readability
  labs(title = "Top 15 Important Features", x = "Features", y = "Importance (Gain)") +
  theme_minimal()
metabolite_feature_pn34
#ggsave("./forISRHML/metabolite_feature_pn34.svg", metabolite_feature_pn34, width = 4, height = 4, dpi = 300)

```

## FigureS9 bottom heatmaps

```{r}

metabolite_pn34_imp <- metabolite_pn34 %>%
  select(idbs, xgboostMetabpn34)

infant12_metabolitepn34 <- metabolite_pn34_imp %>%
  left_join(infant_species_pn12, by = "idbs") %>%
  #left_join(row_annotation_idbs, by = "idbs")  %>% # Perform the join
  #left_join(metadata %>% dplyr::select(idbs, code, GWG, hh_child5)) %>%
  left_join(metadata %>% dplyr::select(idbs, code)) %>%
  mutate(code = as.factor(code)) %>%
  select(-idbs)

# Step 1: Reshape the data
# Assuming infant_hmo_pn12milk1421 is your dataframe with species and HMO columns

results_list <- lapply(names(infant12_metabolitepn34)[grepl("Hex2Cer.d18.1.24.0.|Spermine|Ala|TG.18.3_32.0.|PC.ae.C40.4|Cer.d18.1.16.0.|DG.14.0_18.1.|Taurine|TG.16.0_34.1.|TG.22.6_32.1.|Putrescine|Hex2Cer.d18.1.16.0.|TrpBetaine|X1.Met.His|TG.16.1_32.1.", names(infant12_metabolitepn34))], function(hmo_column) {
  lapply(names(infant12_metabolitepn34)[grepl("Bifidobacterium infantis|Escherichia coli|Bacteroides fragilis_A|Klebsiella pneumoniae|Prevotella sp900544825|Streptococcus sp000187445|Parolsenella uli_B|Bifidobacterium longum|Prevotella sp900551985|Veillonella_A sp000431435|Bifidobacterium bifidum", names(infant12_metabolitepn34))], function(species_column) {
    
    # Log-transform species data before performing linear regression
    log_species <- log1p(infant12_metabolitepn34[[species_column]])  # Apply log(1 + x) transformation
    
    # Log-transform HMO levels before performing linear regression
    log_hmo <- log1p(infant12_metabolitepn34[[hmo_column]])  # Apply log(1 + x) transformation
    
    # Perform linear regression for each species vs each HMO 
    lm_result <- lm(log_hmo ~ log_species + infant12_metabolitepn34$code)
    # Extract coefficient and p-value
    coef_val <- coef(lm_result)[2]  # Coefficient of the HMO
    p_val <- summary(lm_result)$coefficients[2, 4]  # p-value for HMO
    
    # Return results as a data frame
    tibble(species = species_column, HMO = hmo_column, coefficient = coef_val, p_value = p_val)
  })
})

# Flatten the list into a single data frame
results_df <- bind_rows(unlist(results_list, recursive = TRUE))

# Step 1: Convert the dataframe to a matrix
results_matrix <- as.matrix(results_df)

# Step 2: Reshape the matrix into a new matrix where each row has 4 columns
reshaped_matrix <- matrix(results_matrix, ncol = 4, byrow = TRUE)

# Step 3: Convert the reshaped matrix back into a dataframe
results_table <- as.data.frame(reshaped_matrix)

# Optionally, assign column names (optional step)
colnames(results_table) <- c("Species", "HMO", "Coefficient", "P_value")

# View the resulting table
print(results_table)

# Step 3: FDR correction of p-values using BH method
results_adj <- results_table %>%
  dplyr::mutate(adj_p_value = p.adjust(P_value, method = "BH"))

hmo_order <- c("Hex2Cer.d18.1.24.0.", "Spermine", "Ala", "TG.18.3_32.0.",
"PC.ae.C40.4", "Cer.d18.1.16.0.", "DG.14.0_18.1.", "Taurine", 
"TG.16.0_34.1.", "TG.22.6_32.1.", "Putrescine", "Hex2Cer.d18.1.16.0.", 
"TrpBetaine", "X1.Met.His", "TG.16.1_32.1.")
results_adj$HMO <- factor(results_adj$HMO, levels = hmo_order)


# Step 4: Define significance based on adjusted p-values
results_adj <- results_adj %>%
  mutate(Coefficient = as.numeric(Coefficient)) %>%
  mutate(
    significance = case_when(
      adj_p_value <= 0.001 ~ "***",  # Adjusted p-value <= 0.001
      adj_p_value <= 0.01 ~ "**",    # Adjusted p-value <= 0.01
      adj_p_value <= 0.05 ~ "*",     # Adjusted p-value <= 0.05
      adj_p_value <= 0.1 ~ ".",      # Adjusted p-value <= 0.1
      P_value <= 0.05 & adj_p_value > 0.1 ~ "~",  # Unadjusted p-value <= 0.05 but adjusted p-value > 0.1
      TRUE ~ ""  # Exclude non-significant comparisons
    )
  )
# Check the output
head(results_adj)

# Plot the heatmap using ggplot2
infant12_metabolitepn34_Heatmap <- ggplot(results_adj, aes(x = HMO, y = Species, fill = Coefficient)) +
  geom_tile(color = "black", width = 0.9, height = 0.9) +  # Create heatmap tiles
  geom_text(aes(label = significance), color = "darkred", size = 6) +  # Add significance labels inside cells
    scale_fill_gradientn(
    colours = divergingx_hcl(5, palette = "RdBu"),  # perceptually uniform
    limits = c(-12,12),
    name = "Coefficient"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        axis.text.y = element_text(size = 10), 
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        ) +
  labs(
       x = "Metabolites at 3-4 months", 
       y = "Infant gut at 1-2 months")
infant12_metabolitepn34_Heatmap

# Save as SVG with a 1.5 aspect ratio
#ggsave("./forISRHML/Jun2_infant12_metabolitepn34_heatmap_code2.svg", infant12_metabolitepn34_Heatmap, width = 5.8, height = 5, dpi = 300)

```

# RDA

## gut pn12e

```{r message=FALSE}

set.seed(1992)

infant_species_pn12 <- pn12e_meta %>%
  tax_glom(taxrank = "species") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  filter(Abundance > 0)

# Process gut microbiome data and add 'gut_' prefix to species names
gut_microbiome_pn12 <- infant_species_pn12 %>%
  dplyr::select(idbs, Cluster, species, Abundance, lbw, sga_new, preterm, code, gravidity, HH_food_insecurity, w_age, m_weightincl, m_heightincl, m_bmiincl, m_hbincl, mddw_10_ave, asset1comp_10, m_muacincl, GWG, GAbirthweeks, c_weight0, c_height0, c_headc0, c_muac0, season_lean, iycf_ebf_age, pn12e_evpu, hh_size, hh_child5) %>%
  mutate(parity = if_else(gravidity == 1, 1, 0)) %>%
  mutate(
         C_Weight=c_weight0,
         C_Height=c_height0,
         C_HeadCircumference=c_headc0,
         C_MUAC=c_muac0,
         M_BMI=m_bmiincl,
         M_Weight=m_weightincl,
         M_Height=m_heightincl,
         M_MUAC=m_muacincl,
         M_Age=w_age,
         M_Hemoglobin=m_hbincl,
         M_DietaryDiversity=mddw_10_ave,
         M_WealthIndex=asset1comp_10,
         M_GestationalWeightGain=GWG,
         C_GestationalAge=GAbirthweeks,
         ExclusivelyBFmonths=iycf_ebf_age,
         M_BEP=code,
         FirstPregnancy=parity,
         FoodInsecurity=HH_food_insecurity,
         LeanSeason=season_lean,
         LBW=lbw,
         SGA=sga_new,
         Preterm=preterm,
         Purge=pn12e_evpu,
         HH_Size=hh_size,
         HH_Child5=hh_child5
         ) %>%
  select(idbs, species, Cluster, Abundance, C_Weight, C_Height, C_HeadCircumference, C_MUAC, M_BMI, M_Weight, M_Height, M_MUAC, M_Age, M_Hemoglobin, M_DietaryDiversity, M_WealthIndex, M_GestationalWeightGain, C_GestationalAge,ExclusivelyBFmonths, M_BEP, FirstPregnancy, LeanSeason, LBW, SGA, Preterm, Purge, HH_Size, HH_Child5) %>%
  
  pivot_wider(
    names_from = species,  # Use species as the new column names
    values_from = Abundance # Use Abundance as the values for the new columns
  ) %>%
  replace(is.na(.), 0) %>%  # Replace NA with 0
  mutate(idbs2 = as.character(idbs)) %>%  # Ensure 'idbs' is character
  column_to_rownames("idbs2")

gut_microbiome_pn12$idbs <- as.character(gut_microbiome_pn12$idbs)
```

### RDA and plot

```{r}

set.seed(1992)

# Define the explanatory variables explicitly (list of column names)
explanatory_variable_names <- c("C_Weight", "C_Height", "C_HeadCircumference", "C_MUAC", "M_BMI", "M_Weight", "M_Height", "M_MUAC", "M_Age", "M_Hemoglobin", "M_DietaryDiversity", "M_WealthIndex", "M_GestationalWeightGain", "C_GestationalAge","ExclusivelyBFmonths", "M_BEP", "FirstPregnancy", "LeanSeason", "LBW", "SGA", "Preterm", "Purge", "HH_Size", "HH_Child5")

# Subset the explanatory variables
explanatory_variables <- gut_microbiome_pn12 %>%
  dplyr::select(all_of(explanatory_variable_names))

# Subset the response matrix by excluding the explanatory variables
response_matrix <- gut_microbiome_pn12 %>%
  dplyr::select(-all_of(explanatory_variable_names), -idbs, -Cluster) %>%
  dplyr::select(where(~ mean(. == 0, na.rm = TRUE) < 0.9))  # Remove columns with >90% zeros# Retain only numeric columns

# Run RDA
rda_model <- rda(response_matrix ~ ., data = explanatory_variables)

# Summarize the model
summary(rda_model)

# Check variance explained by each component
R2 <- RsquareAdj(rda_model)$adj.r.squared
R2

# Test significance of the full model
anova_rda <- anova.cca(rda_model, permutations = 999)
anova_rda

# Test significance of individual terms (HMOs, pathogens, etc.)
anova_terms <- anova.cca(rda_model, by = "terms", permutations = 999)
anova_terms
```

### plot

```{r}
# Extract the percentage of variance explained by RDA1 and RDA2
summary_rda <- summary(rda_model)
rda1_variance <- round(summary_rda$cont$importance[2, 1] * 100, 1)  # RDA1 percentage
rda2_variance <- round(summary_rda$cont$importance[2, 2] * 100, 1)  # RDA2 percentage

# Add the percentages to the axis labels
xlabel <- paste0("RDA1 (", rda1_variance, "%)")
ylabel <- paste0("RDA2 (", rda2_variance, "%)")

# Extract sample scores and add Cluster information
sample_scores <- as.data.frame(scores(rda_model, display = "sites", scaling = 2))
sample_scores$idbs <- rownames(sample_scores)  # Add SampleID column
sample_scores <- sample_scores %>%
  left_join(gut_microbiome_pn12 %>% dplyr::select(idbs, Cluster), by = "idbs")  # Add Cluster

# Define cluster colors
cluster_colors <- c("C1" = "#00A98F", "C2" = "#FFC000", "C3" = "#1565A9")  # Adjust as needed

# Create the plot function
create_rda_plot <- function() {
  # Create the base plot
  plot(rda_model, scaling = 2, type = "n", xlab = xlabel, ylab = ylabel)

  # Add sample points colored by Cluster
  points(
    scores(rda_model, display = "sites", scaling = 2),
    pch = 20,
    col = cluster_colors[sample_scores$Cluster],
    cex = 0.8
  )


  # Add explanatory variable arrows
  significant_vars <- which(anova_terms$`Pr(>F)` < 0.1)
  non_significant_vars <- setdiff(1:nrow(scores(rda_model, display = "bp")), significant_vars)

  arrows(0, 0, 
         scores(rda_model, display = "bp")[non_significant_vars, 1], 
         scores(rda_model, display = "bp")[non_significant_vars, 2], 
         length = 0.1, col = "grey", lwd = 1)

  # Label non-significant variables
  text(scores(rda_model, display = "bp")[non_significant_vars, 1] * 1.1, 
       scores(rda_model, display = "bp")[non_significant_vars, 2] * 1.1, 
       labels = rownames(scores(rda_model, display = "bp"))[non_significant_vars], 
       col = "grey", cex = 0.8)

  # Add species points (red crosses for taxa)
  points(scores(rda_model, display = "species", scaling = 2), 
         pch = 3, col = "darkgreen")
  
  # Add significant explanatory variable arrows
  arrows(0, 0, 
         scores(rda_model, display = "bp")[significant_vars, 1], 
         scores(rda_model, display = "bp")[significant_vars, 2], 
         length = 0.1, col = "darkred", lwd = 2)

  # Highlight labels for significant variables
  text(scores(rda_model, display = "bp")[significant_vars, 1] * 1.2, 
       scores(rda_model, display = "bp")[significant_vars, 2] * 1.2, 
       labels = rownames(scores(rda_model, display = "bp"))[significant_vars], 
       col = "darkred", font = 2, cex = 1)

  # Add legends for Clusters
  legend("bottomright", 
         legend = names(cluster_colors), 
         col = cluster_colors, 
         pch = 20, 
         cex = 0.8, 
         box.lty = 0)
}

# Call the function to create the plot
create_rda_plot()

#svglite::svglite(
#  filename = "./forISRHML/rda_infant_pn12_feb12_2.svg",
#  width = 7, height = 7
#)
#create_rda_plot()
#dev.off()

# Extract the ANOVA table from the RDA result
anova_df <- as.data.frame(anova_terms) %>%
  dplyr::mutate(Variance = Variance *100) %>%
  rownames_to_column("Feature") %>%
  filter(Feature != "Residual")

all_variance <- anova_df %>%
    dplyr::summarise(total_variance = sum(Variance, na.rm = TRUE))

all_variance

```

## gut pn56e

```{r message=FALSE}

set.seed(1992)

infant_species_pn56 <- pn56e_meta %>%
  tax_glom(taxrank = "species") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  filter(Abundance > 0)

# Process gut microbiome data and add 'gut_' prefix to species names
gut_microbiome_pn56 <- infant_species_pn56 %>%
  dplyr::select(idbs, Cluster, species, Abundance, lbw, sga_new, preterm, code, gravidity, HH_food_insecurity, w_age, m_weightincl, m_heightincl, m_bmiincl, m_hbincl, mddw_10_ave, asset1comp_10, m_muacincl, GWG, GAbirthweeks, c_weight0, c_height0, c_headc0, c_muac0, season_lean, iycf_ebf_age, pn12e_evpu, hh_size, hh_child5) %>%
  mutate(parity = if_else(gravidity == 1, 1, 0)) %>%
  mutate(
         C_Weight=c_weight0,
         C_Height=c_height0,
         C_HeadCircumference=c_headc0,
         C_MUAC=c_muac0,
         M_BMI=m_bmiincl,
         M_Weight=m_weightincl,
         M_Height=m_heightincl,
         M_MUAC=m_muacincl,
         M_Age=w_age,
         M_Hemoglobin=m_hbincl,
         M_DietaryDiversity=mddw_10_ave,
         M_WealthIndex=asset1comp_10,
         M_GestationalWeightGain=GWG,
         C_GestationalAge=GAbirthweeks,
         ExclusivelyBFmonths=iycf_ebf_age,
         M_BEP=code,
         FirstPregnancy=parity,
         FoodInsecurity=HH_food_insecurity,
         LeanSeason=season_lean,
         LBW=lbw,
         SGA=sga_new,
         Preterm=preterm,
         Purge=pn12e_evpu,
         HH_Size=hh_size,
         HH_Child5=hh_child5
         ) %>%
  select(idbs, species, Cluster, Abundance, C_Weight, C_Height, C_HeadCircumference, C_MUAC, M_BMI, M_Weight, M_Height, M_MUAC, M_Age, M_Hemoglobin, M_DietaryDiversity, M_WealthIndex, M_GestationalWeightGain, C_GestationalAge,ExclusivelyBFmonths, M_BEP, FirstPregnancy, LeanSeason, LBW, SGA, Preterm, Purge, HH_Size, HH_Child5) %>%
  
  pivot_wider(
    names_from = species,  # Use species as the new column names
    values_from = Abundance # Use Abundance as the values for the new columns
  ) %>%
  replace(is.na(.), 0) %>%  # Replace NA with 0
  mutate(idbs2 = as.character(idbs)) %>%  # Ensure 'idbs' is character
  column_to_rownames("idbs2")

gut_microbiome_pn56$idbs <- as.character(gut_microbiome_pn56$idbs)
```

### RDA and plot

```{r}

set.seed(1992)

# Define the explanatory variables explicitly (list of column names)
explanatory_variable_names <- c("C_Weight", "C_Height", "C_HeadCircumference", "C_MUAC", "M_BMI", "M_Weight", "M_Height", "M_MUAC", "M_Age", "M_Hemoglobin", "M_DietaryDiversity", "M_WealthIndex", "M_GestationalWeightGain", "C_GestationalAge","ExclusivelyBFmonths", "M_BEP", "FirstPregnancy", "LeanSeason", "LBW", "SGA", "Preterm", "Purge", "HH_Size", "HH_Child5")

# Subset the explanatory variables
explanatory_variables <- gut_microbiome_pn56 %>%
  dplyr::select(all_of(explanatory_variable_names))

# Subset the response matrix by excluding the explanatory variables
response_matrix <- gut_microbiome_pn56 %>%
  dplyr::select(-all_of(explanatory_variable_names), -idbs, -Cluster) %>%
  dplyr::select(where(~ mean(. == 0, na.rm = TRUE) < 0.9))  # Remove columns with >90% zeros# Retain only numeric columns

# Run RDA
rda_model <- rda(response_matrix ~ ., data = explanatory_variables)

# Summarize the model
summary(rda_model)

# Check variance explained by each component
R2 <- RsquareAdj(rda_model)$adj.r.squared
R2

# Test significance of the full model
anova_rda <- anova.cca(rda_model, permutations = 999)
anova_rda

# Test significance of individual terms (HMOs, pathogens, etc.)
anova_terms <- anova.cca(rda_model, by = "terms", permutations = 999)
anova_terms
```

### plot

```{r}
# Extract the percentage of variance explained by RDA1 and RDA2
summary_rda <- summary(rda_model)
rda1_variance <- round(summary_rda$cont$importance[2, 1] * 100, 1)  # RDA1 percentage
rda2_variance <- round(summary_rda$cont$importance[2, 2] * 100, 1)  # RDA2 percentage

# Add the percentages to the axis labels
xlabel <- paste0("RDA1 (", rda1_variance, "%)")
ylabel <- paste0("RDA2 (", rda2_variance, "%)")

# Extract sample scores and add Cluster information
sample_scores <- as.data.frame(scores(rda_model, display = "sites", scaling = 2))
sample_scores$idbs <- rownames(sample_scores)  # Add SampleID column
sample_scores <- sample_scores %>%
  left_join(gut_microbiome_pn56 %>% dplyr::select(idbs, Cluster), by = "idbs")  # Add Cluster

# Define cluster colors
cluster_colors <- c("C1" = "#00A98F", "C2" = "#FFC000", "C3" = "#1565A9")  # Adjust as needed

# Create the plot function
create_rda_plot <- function() {
  # Create the base plot
  plot(rda_model, scaling = 2, type = "n", xlab = xlabel, ylab = ylabel)

  # Add sample points colored by Cluster
  points(
    scores(rda_model, display = "sites", scaling = 2),
    pch = 20,
    col = cluster_colors[sample_scores$Cluster],
    cex = 0.8
  )


  # Add explanatory variable arrows
  significant_vars <- which(anova_terms$`Pr(>F)` < 0.1)
  non_significant_vars <- setdiff(1:nrow(scores(rda_model, display = "bp")), significant_vars)

  arrows(0, 0, 
         scores(rda_model, display = "bp")[non_significant_vars, 1], 
         scores(rda_model, display = "bp")[non_significant_vars, 2], 
         length = 0.1, col = "grey", lwd = 1)

  # Label non-significant variables
  text(scores(rda_model, display = "bp")[non_significant_vars, 1] * 1.1, 
       scores(rda_model, display = "bp")[non_significant_vars, 2] * 1.1, 
       labels = rownames(scores(rda_model, display = "bp"))[non_significant_vars], 
       col = "grey", cex = 0.8)

  # Add species points (red crosses for taxa)
  points(scores(rda_model, display = "species", scaling = 2), 
         pch = 3, col = "darkgreen")
  
  # Add significant explanatory variable arrows
  arrows(0, 0, 
         scores(rda_model, display = "bp")[significant_vars, 1], 
         scores(rda_model, display = "bp")[significant_vars, 2], 
         length = 0.1, col = "darkred", lwd = 2)

  # Highlight labels for significant variables
  text(scores(rda_model, display = "bp")[significant_vars, 1] * 1.2, 
       scores(rda_model, display = "bp")[significant_vars, 2] * 1.2, 
       labels = rownames(scores(rda_model, display = "bp"))[significant_vars], 
       col = "darkred", font = 2, cex = 1)

  # Add legends for Clusters
  legend("bottomright", 
         legend = names(cluster_colors), 
         col = cluster_colors, 
         pch = 20, 
         cex = 0.8, 
         box.lty = 0)
}

# Call the function to create the plot
create_rda_plot()

#svglite::svglite(
#  filename = "./forISRHML/rda_infant_pn56.svg",
#  width = 7, height = 7
#)
#create_rda_plot()
#dev.off()

# Extract the ANOVA table from the RDA result
anova_df <- as.data.frame(anova_terms) %>%
  dplyr::mutate(Variance = Variance *100) %>%
  rownames_to_column("Feature") %>%
  filter(Feature != "Residual")

all_variance <- anova_df %>%
    dplyr::summarise(total_variance = sum(Variance, na.rm = TRUE))

all_variance


```

## gut pn12e all others

```{r message=FALSE}
hmo_1421_more <- hmoMeta %>%
  filter(timepoint == "1421") %>%
  rename_with(~ str_replace(., "_nmol\\.mL$", ""), contains("_nmol.mL")) %>%
  select(idbs, "SUM", "Sia", "Fuc", "Diversity", "Evenness", "Secretor","X2.FL", "X3FL","LNT", "LNFP.II", "LNFP.I","X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", "X3.SL", "LSTc","DSLNT","FDSLNH", "DSLNH", "LNH","LSTb","DFLNH", "LNFP.III") %>%
  rename_with(~ paste0("D1421_", .), -idbs)  # Add "Tri3_" to all columns except "idbs"

hmo_pn12_more <- hmoMeta %>%
  filter(timepoint == "pn12") %>%
  rename_with(~ str_replace(., "_nmol\\.mL$", ""), contains("_nmol.mL")) %>%
  select(idbs, "SUM", "Sia", "Fuc", "Diversity", "Evenness", "Secretor","X2.FL", "X3FL","LNT", "LNFP.II", "LNFP.I","X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", "X3.SL", "LSTc","DSLNT","FDSLNH", "DSLNH", "LNH","LSTb","DFLNH", "LNFP.III") %>%
  rename_with(~ paste0("Pn12_", .), -idbs)  # Add "Tri3_" to all columns except "idbs"

mother_species_tri3 <- tri3_meta %>%
  tax_glom(taxrank = "species") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  filter(Abundance > 0)
mother_species_tri3$idbs <- as.character(mother_species_tri3$idbs)

tri3_diversity <- diversity_mother %>%
  filter(timepoint == "Tri3") %>%
  dplyr::select(idbs, Shannon, Observed) 

mother_species_tri3_wide2 <- mother_species_tri3 %>%
  dplyr::select(idbs, species, Abundance) %>%
  pivot_wider(
    names_from = species,  # Use species as the new column names
    values_from = Abundance # Use Abundance as the values for the new columns
  ) %>%
  dplyr::select("idbs", "Prevotella sp002299635", "Prevotella sp000436035", "RC9 sp000433355", "Prevotella sp000434515", "C941 sp004557565", "Unknown_Prevotella", "Prevotella sp900551275", "Prevotella sp900548535", "Prevotella copri", "Prevotella sp900556795", "Evtepia sp004556345", "Parabacteroides sp900549585", "UBA6398 sp003150315", "Unknown_UMGS1603", "Faecalibacterium sp900539945", "Angelakisella sp004557855", "Unknown_CAG-1000_1", "Methanosphaera stadtmanae", "UBA1436 sp900541355", "Unknown_Oribacterium") %>%
  replace(is.na(.), 0)  %>%  # Replace NA with 0
  left_join(tri3_diversity, by = "idbs") %>%
  rename_with(~ paste0("Tri3_", .), -idbs)  # Add "Tri3_" to all columns except "idbs"

pn12h_diversity <- diversity_milk %>%
  filter(timepoint == "Pn12") %>%
  dplyr::select(idbs, Shannon, Observed) 

milk_species_pn12_wide2 <- milk_Pn12_genus %>%
  dplyr::select(idbs, genus, Abundance) %>%
  pivot_wider(
    names_from = genus,  # Use species as the new column names
    values_from = Abundance # Use Abundance as the values for the new columns
  ) %>%
  dplyr::select("idbs",  "Prevotella",  "Streptococcus", "Parolsenella", "Veillonella_A", "Lactobacillus",   "Collinsella",  "Rothia", "Erysipelatoclostridium", "Limosilactobacillus", "Pauljensenia", "Bacillus_P_294101", "Staphylococcus", "Anaerococcus", "Micrococcus", "Bifidobacterium_388775", "JC017", "Corynebacterium", "Acinetobacter" ) %>%
  replace(is.na(.), 0)  %>%  # Replace NA with 0
  mutate(idbs = as.factor(idbs)) %>%
  left_join(pn12h_diversity, by = "idbs") %>%
  rename_with(~ paste0("Milk_", .), -idbs)  # Add "Tri3_" to all columns except "idbs"

infant_species_pn12 <- pn12e_meta %>%
  tax_glom(taxrank = "species") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  filter(Abundance > 0)
infant_species_pn12$idbs <- as.character(infant_species_pn12$idbs)

mother_species_tri3_wide <- mother_species_tri3 %>%
  dplyr::select(idbs, species, Abundance) %>%
  pivot_wider(
    names_from = species,  # Use species as the new column names
    values_from = Abundance # Use Abundance as the values for the new columns
  ) %>%
  dplyr::select("idbs", "Prevotella sp002299635", "Prevotella sp000436035", "RC9 sp000433355", "Prevotella sp000434515", "C941 sp004557565", "Unknown_Prevotella", "Prevotella sp900551275", "Prevotella sp900548535", "Prevotella copri", "Prevotella sp900556795") %>%
  replace(is.na(.), 0)  %>%  # Replace NA with 0
  left_join(tri3_diversity, by = "idbs") %>%
  rename_with(~ paste0("Tri3_", .), -idbs)  # Add "Tri3_" to all columns except "idbs"

milk_species_pn12_wide <- milk_Pn12_genus %>%
  dplyr::select(idbs, genus, Abundance) %>%
  pivot_wider(
    names_from = genus,  # Use species as the new column names
    values_from = Abundance # Use Abundance as the values for the new columns
  ) %>%
  dplyr::select("idbs",  "Prevotella",  "Streptococcus", "Parolsenella", "Veillonella_A", "Lactobacillus",   "Collinsella",  "Rothia", "Erysipelatoclostridium", "Limosilactobacillus", "Pauljensenia") %>%
  replace(is.na(.), 0)  %>%  # Replace NA with 0
  mutate(idbs = as.factor(idbs)) %>%
  left_join(pn12h_diversity, by = "idbs") %>%
  rename_with(~ paste0("Milk_", .), -idbs)  # Add "Tri3_" to all columns except "idbs"

# Process gut microbiome data and add 'gut_' prefix to species names
gut_microbiome_pn12 <- infant_species_pn12 %>%
  dplyr::select(idbs, Cluster, species, Abundance, lbw, sga_new, preterm, code, gravidity, HH_food_insecurity, w_age, m_weightincl, m_heightincl, m_bmiincl, m_hbincl, mddw_10_ave, asset1comp_10, m_muacincl, GWG, GAbirthweeks, c_weight0, c_height0, c_headc0, c_muac0, season_lean, iycf_ebf_age, pn12e_evpu, hh_size, hh_child5) %>%
  mutate(parity = if_else(gravidity == 1, 1, 0)) %>%
  mutate(
         C_Weight=c_weight0,
         C_Height=c_height0,
         C_HeadCircumference=c_headc0,
         C_MUAC=c_muac0,
         M_BMI=m_bmiincl,
         M_Weight=m_weightincl,
         M_Height=m_heightincl,
         M_MUAC=m_muacincl,
         M_Age=w_age,
         M_Hemoglobin=m_hbincl,
         M_DietaryDiversity=mddw_10_ave,
         M_WealthIndex=asset1comp_10,
         M_GestationalWeightGain=GWG,
         C_GestationalAge=GAbirthweeks,
         ExclusivelyBFmonths=iycf_ebf_age,
         M_BEP=code,
         FirstPregnancy=parity,
         FoodInsecurity=HH_food_insecurity,
         LeanSeason=season_lean,
         LBW=lbw,
         SGA=sga_new,
         Preterm=preterm,
         Purge=pn12e_evpu,         
         HH_Size=hh_size,
         HH_Child5=hh_child5
         ) %>%
  select(idbs, species, Cluster, Abundance 
         , C_Weight, C_Height, C_HeadCircumference, C_MUAC, M_BMI, M_Weight, M_Height, M_MUAC, M_Age, M_Hemoglobin, M_DietaryDiversity, M_WealthIndex, M_GestationalWeightGain, C_GestationalAge,ExclusivelyBFmonths, M_BEP, FirstPregnancy, LeanSeason, LBW, SGA, Preterm, Purge, HH_Size, HH_Child5
         ) %>%
  
  pivot_wider(
    names_from = species,  # Use species as the new column names
    values_from = Abundance # Use Abundance as the values for the new columns
  ) %>%
  replace(is.na(.), 0) %>%  # Replace NA with 0
  left_join(mother_species_tri3_wide, by = "idbs") %>%
  left_join(milk_species_pn12_wide, by = "idbs") %>%
  #left_join(milk_pn12, by = "idbs") %>%
  left_join(hmo_1421_more, by = "idbs") %>%
  left_join(hmo_pn12_more, by = "idbs") %>%
  mutate(idbs2 = as.character(idbs)) %>%  # Ensure 'idbs' is character
  column_to_rownames("idbs2") %>%
  drop_na()



```

## RDA and plot

```{r}

set.seed(1992)

# Define the explanatory variables explicitly (list of column names)
explanatory_variable_names <- c("C_Weight", "C_Height", "C_HeadCircumference", "C_MUAC", "M_BMI", "M_Weight", "M_Height", "M_MUAC", "M_Age", "M_Hemoglobin", "M_DietaryDiversity", "M_WealthIndex", "M_GestationalWeightGain", "C_GestationalAge","ExclusivelyBFmonths", "M_BEP", "FirstPregnancy", "LeanSeason", "LBW", "SGA", "Preterm", "Purge", "HH_Size", "HH_Child5", colnames(mother_species_tri3_wide)[grepl("^Tri3", colnames(mother_species_tri3_wide))], colnames(milk_species_pn12_wide)[grepl("^Milk", colnames(milk_species_pn12_wide))], setdiff(colnames(hmo_1421_more), "idbs"), setdiff(colnames(hmo_pn12_more), "idbs"))

#explanatory_variable_names <- c(colnames(mother_species_tri3_wide)[grepl("^Tri3", colnames(mother_species_tri3_wide))], colnames(milk_species_pn12_wide)[grepl("^Milk", colnames(milk_species_pn12_wide))], setdiff(colnames(hmo_1421_more), "idbs"), setdiff(colnames(hmo_pn12_more), "idbs"))

#explanatory_variable_names <- c("C_Weight", "C_Height", "C_HeadCircumference", "C_MUAC", "M_BMI", "M_Weight", "M_Height", "M_MUAC", "M_Age", "M_Hemoglobin", "M_DietaryDiversity", "M_WealthIndex", "M_GestationalWeightGain", "C_GestationalAge","ExclusivelyBFmonths", "M_BEP", "FirstPregnancy", "LeanSeason", "LBW", "SGA", "Preterm", "Purge", "HH_Size", "HH_Child5", setdiff(colnames(milk_pn12), "idbs"))

# Subset the explanatory variables
explanatory_variables <- gut_microbiome_pn12 %>%
  dplyr::select(all_of(explanatory_variable_names))

# Subset the response matrix by excluding the explanatory variables
response_matrix <- gut_microbiome_pn12 %>%
  dplyr::select(-all_of(explanatory_variable_names), -idbs, -Cluster) %>%
  dplyr::select(where(~ mean(. == 0, na.rm = TRUE) < 0.9))  # Remove columns with >90% zeros# Retain only numeric columns

# Run RDA
rda_model <- rda(response_matrix ~ ., data = explanatory_variables)

# Summarize the model
summary(rda_model)

# Check variance explained by each component
R2 <- RsquareAdj(rda_model)$adj.r.squared
R2

# Test significance of the full model
anova_rda <- anova.cca(rda_model, permutations = 999)
anova_rda

# Test significance of individual terms (HMOs, pathogens, etc.)
anova_terms <- anova.cca(rda_model, by = "terms", permutations = 999)
anova_terms
```

### Fig7A arrow plot

```{r}
# Extract the percentage of variance explained by RDA1 and RDA2
summary_rda <- summary(rda_model)
rda1_variance <- round(summary_rda$cont$importance[2, 1] * 100, 1)  # RDA1 percentage
rda2_variance <- round(summary_rda$cont$importance[2, 2] * 100, 1)  # RDA2 percentage

# Add the percentages to the axis labels
xlabel <- paste0("RDA1 (", rda1_variance, "%)")
ylabel <- paste0("RDA2 (", rda2_variance, "%)")

# Extract sample scores and add Cluster information
sample_scores <- as.data.frame(scores(rda_model, display = "sites", scaling = 2))
sample_scores$idbs <- rownames(sample_scores)  # Add SampleID column
sample_scores <- sample_scores %>%
  left_join(gut_microbiome_pn12 %>% dplyr::select(idbs, Cluster), by = "idbs")  # Add Cluster

# Define cluster colors
cluster_colors <- c("C1" = "#00A98F", "C2" = "#FFC000", "C3" = "#1565A9")  # Adjust as needed

# Create the plot function
create_rda_plot <- function() {
  # Create the base plot
  plot(rda_model, scaling = 2, type = "n", xlab = xlabel, ylab = ylabel)

  # Add sample points colored by Cluster
  points(
    scores(rda_model, display = "sites", scaling = 2),
    pch = 20,
    col = cluster_colors[sample_scores$Cluster],
    cex = 0.8
  )


  # Add explanatory variable arrows
  significant_vars <- which(anova_terms$`Pr(>F)` < 0.1)
  non_significant_vars <- setdiff(1:nrow(scores(rda_model, display = "bp")), significant_vars)

  arrows(0, 0, 
         scores(rda_model, display = "bp")[non_significant_vars, 1], 
         scores(rda_model, display = "bp")[non_significant_vars, 2], 
         length = 0.1, col = "grey", lwd = 1, alpha = 0.3)

  # Label non-significant variables
  text(scores(rda_model, display = "bp")[non_significant_vars, 1] * 1.1, 
       scores(rda_model, display = "bp")[non_significant_vars, 2] * 1.1, 
       labels = rownames(scores(rda_model, display = "bp"))[non_significant_vars], 
       col = "grey", cex = 0.8, alpha = 0.3)

  # Add species points (red crosses for taxa)
  points(scores(rda_model, display = "species", scaling = 2), 
         pch = 3, col = "darkgreen")
  
  # Add significant explanatory variable arrows
  arrows(0, 0, 
         scores(rda_model, display = "bp")[significant_vars, 1], 
         scores(rda_model, display = "bp")[significant_vars, 2], 
         length = 0.1, col = "darkred", lwd = 2)

  # Highlight labels for significant variables
  text(scores(rda_model, display = "bp")[significant_vars, 1] * 1.2, 
       scores(rda_model, display = "bp")[significant_vars, 2] * 1.2, 
       labels = rownames(scores(rda_model, display = "bp"))[significant_vars], 
       col = "darkred", font = 2, cex = 1)

  # Add legends for Clusters
  legend("bottomright", 
         legend = names(cluster_colors), 
         col = cluster_colors, 
         pch = 20, 
         cex = 0.8, 
         box.lty = 0)
}

# Call the function to create the plot
create_rda_plot()

#svglite::svglite(
#  filename = "./forISRHML/rda_infant_pn12_allTogether_Mar17.svg",
#  width = 13, height = 13
#)
#create_rda_plot()
#dev.off()

```

### Fig7B bar plot TableS4

```{r}
# Filter the dataset for Pr(>F) > 0.1 and sort by Variance in descending order
filtered_data_rda_pn12 <- anova_terms %>%
  rownames_to_column(var = "Feature") %>%  # Convert row names to a column
  #filter(`Pr(>F)` < 0.1) %>%  # Filter based on Pr(>F)
  filter(Feature != "Residual") %>%
  mutate(Variance = Variance * 100) %>%
  arrange(desc(Variance)) %>%
  filter(`Pr(>F)` < 0.05)

# Create the barplot
barplot_plot <- ggplot(filtered_data_rda_pn12, aes(x = reorder(Feature, Variance), y = Variance)) +
  geom_bar(stat = "identity", fill = "lightgrey") +
  coord_flip() +  # Flip coordinates for better readability
  labs(
    title = "Variance of All Features",
    x = "",
    y = "Variance"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12),
    plot.title = element_text(size = 14),
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank()   # Remove minor grid lines
  )

# Display the plot
print(barplot_plot)

#svglite::svglite(
#  filename = "./forISRHML/Jun2_rda_infant_pn12_allTogether_barplot.svg",
#  width = 7, height = 4
#)
#barplot_plot
#dev.off()


# Extract the ANOVA table from the RDA result
anova_df <- as.data.frame(anova_terms) %>%
  dplyr::mutate(Variance = Variance *100) %>%
  rownames_to_column("Feature")

#write.xlsx(anova_df, "./forISRHML/Jun2_rda_milk_pn12_all.xlsx")

anova_df$Feature <- gsub("`", "", anova_df$Feature)

# Filter terms that start with "Tri3" and sum their variance
tri3_variance_sum <- anova_df %>%
  filter(grepl("^Tri3", Feature)) %>%
  dplyr::summarise(total_variance = sum(Variance, na.rm = TRUE))

tri3_variance_sum

milk_variance_sum <- anova_df %>%
  filter(grepl("^Milk", Feature)) %>%
  dplyr::summarise(total_variance = sum(Variance, na.rm = TRUE))

milk_variance_sum

hmo1421_variance_sum <- anova_df %>%
  filter(grepl("^D1421", Feature)) %>%
  dplyr::summarise(total_variance = sum(Variance, na.rm = TRUE))

hmo1421_variance_sum

hmopn12_variance_sum <- anova_df %>%
  filter(grepl("^Pn12", Feature)) %>%
  dplyr::summarise(total_variance = sum(Variance, na.rm = TRUE))

hmopn12_variance_sum

all_variance <- anova_df %>%
  filter(Feature!= "Residual") %>%
    dplyr::summarise(total_variance = sum(Variance, na.rm = TRUE))

all_variance
```

## RDA pn56e all others

```{r message=FALSE}
hmo_pn34_more <- hmoMeta %>%
  filter(timepoint == "pn34") %>%
  rename_with(~ str_replace(., "_nmol\\.mL$", ""), contains("_nmol.mL")) %>%
  select(idbs, "SUM", "Sia", "Fuc", "Diversity", "Evenness", "Secretor","X2.FL", "X3FL","LNT", "LNFP.II", "LNFP.I","X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", "X3.SL", "LSTc","DSLNT","FDSLNH", "DSLNH", "LNH","LSTb","DFLNH", "LNFP.III")

hmo_pn12_more <- hmoMeta %>%
  filter(timepoint == "pn12") %>%
  rename_with(~ str_replace(., "_nmol\\.mL$", ""), contains("_nmol.mL")) %>%
  select(idbs, "SUM", "Sia", "Fuc", "Diversity", "Evenness", "Secretor","X2.FL", "X3FL","LNT", "LNFP.II", "LNFP.I","X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", "X3.SL", "LSTc","DSLNT","FDSLNH", "DSLNH", "LNH","LSTb","DFLNH", "LNFP.III")

milk_Pn34_genus <- pn34h_meta %>%
  tax_glom(taxrank = "genus") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt()

milk_species_pn34_wide <- milk_Pn34_genus %>%
  dplyr::select(idbs, genus, Abundance) %>%
  pivot_wider(
    names_from = genus,  # Use species as the new column names
    values_from = Abundance # Use Abundance as the values for the new columns
  ) %>%
  replace(is.na(.), 0)  %>%  # Replace NA with 0
  mutate(idbs = as.factor(idbs))

infant_species <- infant_meta %>%
  tax_glom(taxrank = "species") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  filter(Abundance > 0)

infant_species_pn56 <- infant_species %>%
  filter(timepoint == "pn56") %>%
  select(idbs, species, Cluster, Abundance) %>%
  pivot_wider(names_from = species, values_from = Abundance) %>%
  dplyr::select(idbs, Cluster, where(~ mean(is.na(.)) <= 0.95))
infant_species_pn56$idbs <- as.character(infant_species_pn56$idbs)

results_cluster_pn34_sig  <- results_cluster_pn34 %>%
  filter(p_value_Cluster_adj < 0.05) %>%
  rownames()

rda_infant56_milk34 <- infant_species_pn56 %>%
    left_join(metadata %>% dplyr::select(idbs, code, gravidity, HH_food_insecurity, w_age, m_weightincl, m_heightincl, m_bmiincl, m_hbincl, mddw_10_ave, asset1comp_10, m_muacincl, GWG, GAbirthweeks, season_lean, iycf_ebf_age, hh_size, hh_child5) %>%
  mutate(parity = if_else(gravidity == 1, 1, 0))) %>%
 left_join(milk_pn34, by = "idbs") %>%  # Replace NA with 0
  left_join(milk_species_pn34_wide %>% dplyr::select(idbs, Parolsenella, Veillonella_A, Collinsella), by = "idbs") %>%
  left_join(hmo_pn34_more, by = "idbs") %>%
  left_join(metabolite_pn34 %>% dplyr::select(idbs, xgboostMetabpn34), by = "idbs") %>%
  mutate(idbs2 = as.character(idbs)) %>%  # Ensure 'idbs' is character
  column_to_rownames("idbs2") %>%
  replace(is.na(.), 0) %>%
  select(where(~ any(. != 0)))

```

## RDA and plot

```{r}

set.seed(1992)


response_variables <- infant_species_pn56 %>%
  select(-idbs, -Cluster) %>%  # Exclude the idbs column
  colnames()  # Get the variable names

# Check which columns in response_variables exist in the dataframe
existing_columns <- response_variables[response_variables %in% colnames(rda_infant56_milk34)]

# Select the columns that exist in the dataframe
response_matrix <- rda_infant56_milk34 %>%
  select(all_of(existing_columns))

# Check which columns in response_variables exist in the dataframe
existing_response_variables <- response_variables[response_variables %in% colnames(rda_infant56_milk34)]

# Exclude idbs and the columns that exist in response_variables
explanatory_matrix <- rda_infant56_milk34 %>%
  select(-all_of(existing_response_variables), -idbs, -Cluster)

# Convert to matrices if needed
explanatory_matrix <- as.data.frame(explanatory_matrix)


# Run RDA
rda_model <- rda(response_matrix ~ ., data = explanatory_matrix)

# Summarize the model
summary(rda_model)

# Check variance explained by each component
R2 <- RsquareAdj(rda_model)$adj.r.squared
R2

# Test significance of the full model
anova_rda <- anova.cca(rda_model, permutations = 999)
anova_rda

# Test significance of individual terms (HMOs, pathogens, etc.)
anova_terms <- anova.cca(rda_model, by = "terms", permutations = 999)
anova_terms
```

### Fig7C arrow plot TableS5

```{r}
# Extract the percentage of variance explained by RDA1 and RDA2
summary_rda <- summary(rda_model)
rda1_variance <- round(summary_rda$cont$importance[2, 1] * 100, 1)  # RDA1 percentage
rda2_variance <- round(summary_rda$cont$importance[2, 2] * 100, 1)  # RDA2 percentage

# Add the percentages to the axis labels
xlabel <- paste0("RDA1 (", rda1_variance, "%)")
ylabel <- paste0("RDA2 (", rda2_variance, "%)")

# Extract sample scores and add Cluster information
sample_scores <- as.data.frame(scores(rda_model, display = "sites", scaling = 2))
sample_scores$idbs <- rownames(sample_scores)  # Add SampleID column
sample_scores <- sample_scores %>%
  left_join(rda_infant56_milk34 %>% dplyr::select(idbs, Cluster), by = "idbs")  # Add Cluster

# Define cluster colors
cluster_colors <- c("C1" = "#00A98F", "C2" = "#FFC000", "C3" = "#1565A9")  # Adjust as needed

# Create the plot function
create_rda_plot <- function() {
  # Create the base plot
  plot(rda_model, scaling = 2, type = "n", xlab = xlabel, ylab = ylabel)

  # Add sample points colored by Cluster
  points(
    scores(rda_model, display = "sites", scaling = 2),
    pch = 20,
    col = cluster_colors[sample_scores$Cluster],
    cex = 0.8
  )


  # Add explanatory variable arrows
  significant_vars <- which(anova_terms$`Pr(>F)` < 0.05)
  non_significant_vars <- setdiff(1:nrow(scores(rda_model, display = "bp")), significant_vars)

  arrows(0, 0, 
         scores(rda_model, display = "bp")[non_significant_vars, 1], 
         scores(rda_model, display = "bp")[non_significant_vars, 2], 
         length = 0.1, col = "grey", lwd = 1, alpha = 0.3)

  # Label non-significant variables
  text(scores(rda_model, display = "bp")[non_significant_vars, 1] * 1.1, 
       scores(rda_model, display = "bp")[non_significant_vars, 2] * 1.1, 
       labels = rownames(scores(rda_model, display = "bp"))[non_significant_vars], 
       col = "grey", cex = 0.8, alpha = 0.3)

  # Add species points (red crosses for taxa)
  points(scores(rda_model, display = "species", scaling = 2), 
         pch = 3, col = "darkgreen")
  
  # Add significant explanatory variable arrows
  arrows(0, 0, 
         scores(rda_model, display = "bp")[significant_vars, 1], 
         scores(rda_model, display = "bp")[significant_vars, 2], 
         length = 0.1, col = "darkred", lwd = 2)

  # Highlight labels for significant variables
  text(scores(rda_model, display = "bp")[significant_vars, 1] * 1.2, 
       scores(rda_model, display = "bp")[significant_vars, 2] * 1.2, 
       labels = rownames(scores(rda_model, display = "bp"))[significant_vars], 
       col = "darkred", font = 2, cex = 1)

  # Add legends for Clusters
  legend("bottomright", 
         legend = names(cluster_colors), 
         col = cluster_colors, 
         pch = 20, 
         cex = 0.8, 
         box.lty = 0)
}

# Call the function to create the plot
create_rda_plot()

#svglite::svglite(
#  filename = "./forISRHML/rda_infant_pn56_allTogether_Mar17.svg",
#  width = 13, height = 13
#)
#create_rda_plot()
#dev.off()

# Extract the ANOVA table from the RDA result
anova_df <- as.data.frame(anova_terms) %>%
  dplyr::mutate(Variance = Variance *100) %>%
  rownames_to_column("Feature") %>%
  filter(Feature != "Residual")
#write.xlsx(anova_df, "./forISRHML/Jun2_rda_milk_pn56_all.xlsx")

all_variance <- anova_df %>%
    dplyr::summarise(total_variance = sum(Variance, na.rm = TRUE))

all_variance

# Extract the ANOVA table from the RDA result
anova_df <- as.data.frame(anova_terms) %>%
  dplyr::mutate(Variance = Variance *100) %>%
  rownames_to_column("Feature")

metabolite_variance_sum <- anova_df %>%
  filter(Feature %in% colnames(metabolite_pn34)) %>%
  dplyr::summarise(total_variance = sum(Variance, na.rm = TRUE))

metabolite_variance_sum

milk_variance_sum <- anova_df %>%
  filter(Feature %in% colnames(milk_pn34)) %>%
  dplyr::summarise(total_variance = sum(Variance, na.rm = TRUE))

milk_variance_sum

hmo_variance_sum <- anova_df %>%
  filter(Feature %in% colnames(hmo_pn34)) %>%
  dplyr::summarise(total_variance = sum(Variance, na.rm = TRUE))

hmo_variance_sum

```

### Fig7D bar plot

```{r}
# Filter the dataset for Pr(>F) > 0.1 and sort by Variance in descending order
filtered_data_rda_pn56 <- anova_terms %>%
  rownames_to_column(var = "Feature") %>%  # Convert row names to a column
  #filter(`Pr(>F)` < 0.05) %>%  # Filter based on Pr(>F)
  filter(Feature != "Residual") %>%
  mutate(Variance = Variance * 100) %>%
  arrange(desc(Variance)) %>%
  filter(`Pr(>F)` < 0.05)

# Create the barplot
barplot_plot <- ggplot(filtered_data_rda_pn56, aes(x = reorder(Feature, Variance), y = Variance)) +
  geom_bar(stat = "identity", fill = "lightgrey") +
  coord_flip() +  # Flip coordinates for better readability
  labs(
    title = "Variance of All Features",
    x = "",
    y = "Variance"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12),
    plot.title = element_text(size = 14),
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank()   # Remove minor grid lines
  ) 

# Display the plot
print(barplot_plot)

#svglite::svglite(
#  filename = "./forISRHML/Jun2_rda_infant_pn56_allTogether_barplot.svg",
#  width = 6, height = 5
#)
#barplot_plot
#dev.off()

```

## 1-2 mo

```{r message=FALSE}
hmo_1421_more <- hmoMeta %>%
  filter(timepoint == "1421") %>%
  rename_with(~ str_replace(., "_nmol\\.mL$", ""), contains("_nmol.mL")) %>%
  select(idbs, "SUM", "Sia", "Fuc", "Diversity", "Evenness", "Secretor","X2.FL", "X3FL","LNT", "LNFP.II", "LNFP.I","X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", "X3.SL", "LSTc","DSLNT","FDSLNH", "DSLNH", "LNH","LSTb","DFLNH", "LNFP.III") %>%
  rename_with(~ paste0("D1421_", .), -idbs)  # Add "Tri3_" to all columns except "idbs"

hmo_pn12_more <- hmoMeta %>%
  filter(timepoint == "pn12") %>%
  rename_with(~ str_replace(., "_nmol\\.mL$", ""), contains("_nmol.mL")) %>%
  select(idbs, "SUM", "Sia", "Fuc", "Diversity", "Evenness", "Secretor","X2.FL", "X3FL","LNT", "LNFP.II", "LNFP.I","X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", "X3.SL", "LSTc","DSLNT","FDSLNH", "DSLNH", "LNH","LSTb","DFLNH", "LNFP.III") %>%
  rename_with(~ paste0("Pn12_", .), -idbs)  # Add "Tri3_" to all columns except "idbs"

mother_species_tri3_wide2 <- mother_species_tri3 %>%
  dplyr::select(idbs, species, Abundance) %>%
  pivot_wider(
    names_from = species,  # Use species as the new column names
    values_from = Abundance # Use Abundance as the values for the new columns
  ) %>%
  dplyr::select("idbs", "Prevotella sp002299635", "Prevotella sp000436035", "RC9 sp000433355", "Prevotella sp000434515", "C941 sp004557565", "Unknown_Prevotella", "Prevotella sp900551275", "Prevotella sp900548535", "Prevotella copri", "Prevotella sp900556795", "Evtepia sp004556345", "Parabacteroides sp900549585", "UBA6398 sp003150315", "Unknown_UMGS1603", "Faecalibacterium sp900539945", "Angelakisella sp004557855", "Unknown_CAG-1000_1", "Methanosphaera stadtmanae", "UBA1436 sp900541355", "Unknown_Oribacterium") %>%
  replace(is.na(.), 0)  %>%  # Replace NA with 0
  left_join(tri3_diversity, by = "idbs") %>%
  rename_with(~ paste0("Tri3_", .), -idbs)  # Add "Tri3_" to all columns except "idbs"

milk_species_pn12_wide2 <- milk_Pn12_genus %>%
  dplyr::select(idbs, genus, Abundance) %>%
  pivot_wider(
    names_from = genus,  # Use species as the new column names
    values_from = Abundance # Use Abundance as the values for the new columns
  ) %>%
  dplyr::select("idbs",  "Prevotella",  "Streptococcus", "Parolsenella", "Veillonella_A", "Lactobacillus",   "Collinsella",  "Rothia", "Erysipelatoclostridium", "Limosilactobacillus", "Pauljensenia", "Bacillus_P_294101", "Staphylococcus", "Anaerococcus", "Micrococcus", "Bifidobacterium_388775", "JC017", "Corynebacterium", "Acinetobacter" ) %>%
  replace(is.na(.), 0)  %>%  # Replace NA with 0
  mutate(idbs = as.factor(idbs)) %>%
  left_join(pn12h_diversity, by = "idbs") %>%
  rename_with(~ paste0("Milk_", .), -idbs)  # Add "Tri3_" to all columns except "idbs"

infant_species_pn12 <- pn12e_meta %>%
  tax_glom(taxrank = "species") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  filter(Abundance > 0)
infant_species_pn12$idbs <- as.character(infant_species_pn12$idbs)

# Process gut microbiome data and add 'gut_' prefix to species names
gut_microbiome_pn12 <- infant_species_pn12 %>%
  dplyr::select(idbs, Cluster, species, Abundance) %>%
  pivot_wider(
    names_from = species,  # Use species as the new column names
    values_from = Abundance # Use Abundance as the values for the new columns
  ) %>%
  replace(is.na(.), 0) %>%  # Replace NA with 0
  #left_join(mother_species_tri3_wide, by = "idbs") %>%
  #left_join(milk_species_pn12_wide, by = "idbs") %>%
  left_join(milk_pn12, by = "idbs") %>%
  #left_join(hmo_1421_more, by = "idbs") %>%
  #left_join(hmo_pn12_more, by = "idbs") %>%
  mutate(idbs2 = as.character(idbs)) %>%  # Ensure 'idbs' is character
  column_to_rownames("idbs2") %>%
  drop_na()



```

## RDA and plot

```{r}

set.seed(1992)

explanatory_variable_names <- c(setdiff(colnames(milk_pn12), "idbs"))

# Subset the explanatory variables
explanatory_variables <- gut_microbiome_pn12 %>%
  dplyr::select(all_of(explanatory_variable_names))

# Subset the response matrix by excluding the explanatory variables
response_matrix <- gut_microbiome_pn12 %>%
  dplyr::select(-all_of(explanatory_variable_names), -idbs, -Cluster) %>%
  dplyr::select(where(~ mean(. == 0, na.rm = TRUE) < 0.9))  # Remove columns with >90% zeros# Retain only numeric columns

# Run RDA
rda_model <- rda(response_matrix ~ ., data = explanatory_variables)

# Summarize the model
summary(rda_model)

# Check variance explained by each component
R2 <- RsquareAdj(rda_model)$adj.r.squared
R2

# Test significance of the full model
anova_rda <- anova.cca(rda_model, permutations = 999)
anova_rda

# Test significance of individual terms (HMOs, pathogens, etc.)
anova_terms <- anova.cca(rda_model, by = "terms", permutations = 999)
anova_terms
```

### plot

```{r}
# Extract the percentage of variance explained by RDA1 and RDA2
summary_rda <- summary(rda_model)
rda1_variance <- round(summary_rda$cont$importance[2, 1] * 100, 1)  # RDA1 percentage
rda2_variance <- round(summary_rda$cont$importance[2, 2] * 100, 1)  # RDA2 percentage

# Add the percentages to the axis labels
xlabel <- paste0("RDA1 (", rda1_variance, "%)")
ylabel <- paste0("RDA2 (", rda2_variance, "%)")

# Extract sample scores and add Cluster information
sample_scores <- as.data.frame(scores(rda_model, display = "sites", scaling = 2))
sample_scores$idbs <- rownames(sample_scores)  # Add SampleID column
sample_scores <- sample_scores %>%
  left_join(gut_microbiome_pn12 %>% dplyr::select(idbs, Cluster), by = "idbs")  # Add Cluster

# Define cluster colors
cluster_colors <- c("C1" = "#00A98F", "C2" = "#FFC000", "C3" = "#1565A9")  # Adjust as needed

# Create the plot function
create_rda_plot <- function() {
  # Create the base plot
  plot(rda_model, scaling = 2, type = "n", xlab = xlabel, ylab = ylabel)

  # Add sample points colored by Cluster
  points(
    scores(rda_model, display = "sites", scaling = 2),
    pch = 20,
    col = cluster_colors[sample_scores$Cluster],
    cex = 0.8
  )


  # Add explanatory variable arrows
  significant_vars <- which(anova_terms$`Pr(>F)` < 0.05)
  non_significant_vars <- setdiff(1:nrow(scores(rda_model, display = "bp")), significant_vars)

  arrows(0, 0, 
         scores(rda_model, display = "bp")[non_significant_vars, 1], 
         scores(rda_model, display = "bp")[non_significant_vars, 2], 
         length = 0.1, col = "grey", lwd = 1, alpha = 0.3)

  # Label non-significant variables
  text(scores(rda_model, display = "bp")[non_significant_vars, 1] * 1.1, 
       scores(rda_model, display = "bp")[non_significant_vars, 2] * 1.1, 
       labels = rownames(scores(rda_model, display = "bp"))[non_significant_vars], 
       col = "grey", cex = 0.8, alpha = 0.3)

  # Add species points (red crosses for taxa)
  points(scores(rda_model, display = "species", scaling = 2), 
         pch = 3, col = "darkgreen")
  
  # Add significant explanatory variable arrows
  arrows(0, 0, 
         scores(rda_model, display = "bp")[significant_vars, 1], 
         scores(rda_model, display = "bp")[significant_vars, 2], 
         length = 0.1, col = "darkred", lwd = 2)

  # Highlight labels for significant variables
  text(scores(rda_model, display = "bp")[significant_vars, 1] * 1.2, 
       scores(rda_model, display = "bp")[significant_vars, 2] * 1.2, 
       labels = rownames(scores(rda_model, display = "bp"))[significant_vars], 
       col = "darkred", font = 2, cex = 1)

  # Add legends for Clusters
  legend("bottomright", 
         legend = names(cluster_colors), 
         col = cluster_colors, 
         pch = 20, 
         cex = 0.8, 
         box.lty = 0)
}

# Call the function to create the plot
create_rda_plot()

#svglite::svglite(
#  filename = "./forISRHML/Jun2_rda_infant_pn12_milk.svg",
#  width = 13, height = 13
#)
#create_rda_plot()
#dev.off()

```

### TableS2

```{r}
# Filter the dataset for Pr(>F) > 0.1 and sort by Variance in descending order
filtered_data_rda_pn12 <- anova_terms %>%
  rownames_to_column(var = "Feature") %>%  # Convert row names to a column
  #filter(`Pr(>F)` < 0.1) %>%  # Filter based on Pr(>F)
  filter(Feature != "Residual") %>%
  mutate(Variance = Variance * 100) %>%
  arrange(desc(Variance)) 

# Create the barplot
barplot_plot <- ggplot(filtered_data_rda_pn12, aes(x = reorder(Feature, Variance), y = Variance)) +
  geom_bar(stat = "identity", fill = "lightgrey") +
  coord_flip() +  # Flip coordinates for better readability
  labs(
    title = "Variance of All Features",
    x = "",
    y = "Variance"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12),
    plot.title = element_text(size = 14),
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank()   # Remove minor grid lines
  ) 

# Display the plot
print(barplot_plot)

#svglite::svglite(
#  filename = "./forISRHML/Jun2_rda_infant_pn12_barplot.svg",
#  width = 7, height = 4
#)
#barplot_plot
#dev.off()


# Extract the ANOVA table from the RDA result
anova_df <- as.data.frame(anova_terms) %>%
  dplyr::mutate(Variance = Variance *100) %>%
  rownames_to_column("Feature")

all_variance <- anova_df %>%
  filter(Feature!= "Residual") %>%
    dplyr::summarise(total_variance = sum(Variance, na.rm = TRUE))

all_variance

#write.xlsx(anova_df, "./forISRHML/Jun2_rda_milk_pn12.xlsx")

```

## 1421

```{r}

milk_1421 <- milkMeta %>%
  filter(timepoint == "1421") %>%
  select(idbs, "FAT", "PROTEIN", "CARBOHYDRATE", "Kcal.L", "FGF.21", "FSH", "Insulin", "LH", "Leptin", "Calprotectin", "IgA", "Na", "Mg", "P.", "K.", "Ca", "Cr", "Fe", "Cu", "Zn", "Mo", "As", "Mn", "Se", "Ribo", "FMN", "FAD", "B2", "NAM", "NAD", "NMN", "NR", "B3", "Nufa", "PA", "PL", "PM", "PN", "PLP", "B6", "Bio", "TRP", "TPP", "TMP", "T", "B1", "B12", "g.tocopherol", "a.tocopherol", "vitamin.A")

# Process gut microbiome data and add 'gut_' prefix to species names
gut_microbiome_pn12 <- infant_species_pn12 %>%
  dplyr::select(idbs, Cluster, species, Abundance) %>%
  pivot_wider(
    names_from = species,  # Use species as the new column names
    values_from = Abundance # Use Abundance as the values for the new columns
  ) %>%
  replace(is.na(.), 0) %>%  # Replace NA with 0
  #left_join(mother_species_tri3_wide, by = "idbs") %>%
  #left_join(milk_species_pn12_wide, by = "idbs") %>%
  left_join(milk_1421, by = "idbs") %>%
  #left_join(hmo_1421_more, by = "idbs") %>%
  #left_join(hmo_pn12_more, by = "idbs") %>%
  mutate(idbs2 = as.character(idbs)) %>%  # Ensure 'idbs' is character
  column_to_rownames("idbs2") %>%
  drop_na()



```

## RDA and plot

```{r}

set.seed(1992)

explanatory_variable_names <- c(setdiff(colnames(milk_1421), "idbs"))

# Subset the explanatory variables
explanatory_variables <- gut_microbiome_pn12 %>%
  dplyr::select(all_of(explanatory_variable_names))

# Subset the response matrix by excluding the explanatory variables
response_matrix <- gut_microbiome_pn12 %>%
  dplyr::select(-all_of(explanatory_variable_names), -idbs, -Cluster) %>%
  dplyr::select(where(~ mean(. == 0, na.rm = TRUE) < 0.9))  # Remove columns with >90% zeros# Retain only numeric columns

# Run RDA
rda_model <- rda(response_matrix ~ ., data = explanatory_variables)

# Summarize the model
summary(rda_model)

# Check variance explained by each component
R2 <- RsquareAdj(rda_model)$adj.r.squared
R2

# Test significance of the full model
anova_rda <- anova.cca(rda_model, permutations = 999)
anova_rda

# Test significance of individual terms (HMOs, pathogens, etc.)
anova_terms <- anova.cca(rda_model, by = "terms", permutations = 999)
anova_terms
```

### plot

```{r}
# Extract the percentage of variance explained by RDA1 and RDA2
summary_rda <- summary(rda_model)
rda1_variance <- round(summary_rda$cont$importance[2, 1] * 100, 1)  # RDA1 percentage
rda2_variance <- round(summary_rda$cont$importance[2, 2] * 100, 1)  # RDA2 percentage

# Add the percentages to the axis labels
xlabel <- paste0("RDA1 (", rda1_variance, "%)")
ylabel <- paste0("RDA2 (", rda2_variance, "%)")

# Extract sample scores and add Cluster information
sample_scores <- as.data.frame(scores(rda_model, display = "sites", scaling = 2))
sample_scores$idbs <- rownames(sample_scores)  # Add SampleID column
sample_scores <- sample_scores %>%
  left_join(gut_microbiome_pn12 %>% dplyr::select(idbs, Cluster), by = "idbs")  # Add Cluster

# Define cluster colors
cluster_colors <- c("C1" = "#00A98F", "C2" = "#FFC000", "C3" = "#1565A9")  # Adjust as needed

# Create the plot function
create_rda_plot <- function() {
  # Create the base plot
  plot(rda_model, scaling = 2, type = "n", xlab = xlabel, ylab = ylabel)

  # Add sample points colored by Cluster
  points(
    scores(rda_model, display = "sites", scaling = 2),
    pch = 20,
    col = cluster_colors[sample_scores$Cluster],
    cex = 0.8
  )


  # Add explanatory variable arrows
  significant_vars <- which(anova_terms$`Pr(>F)` < 0.05)
  non_significant_vars <- setdiff(1:nrow(scores(rda_model, display = "bp")), significant_vars)

  arrows(0, 0, 
         scores(rda_model, display = "bp")[non_significant_vars, 1], 
         scores(rda_model, display = "bp")[non_significant_vars, 2], 
         length = 0.1, col = "grey", lwd = 1, alpha = 0.3)

  # Label non-significant variables
  text(scores(rda_model, display = "bp")[non_significant_vars, 1] * 1.1, 
       scores(rda_model, display = "bp")[non_significant_vars, 2] * 1.1, 
       labels = rownames(scores(rda_model, display = "bp"))[non_significant_vars], 
       col = "grey", cex = 0.8, alpha = 0.3)

  # Add species points (red crosses for taxa)
  points(scores(rda_model, display = "species", scaling = 2), 
         pch = 3, col = "darkgreen")
  
  # Add significant explanatory variable arrows
  arrows(0, 0, 
         scores(rda_model, display = "bp")[significant_vars, 1], 
         scores(rda_model, display = "bp")[significant_vars, 2], 
         length = 0.1, col = "darkred", lwd = 2)

  # Highlight labels for significant variables
  text(scores(rda_model, display = "bp")[significant_vars, 1] * 1.2, 
       scores(rda_model, display = "bp")[significant_vars, 2] * 1.2, 
       labels = rownames(scores(rda_model, display = "bp"))[significant_vars], 
       col = "darkred", font = 2, cex = 1)

  # Add legends for Clusters
  legend("bottomright", 
         legend = names(cluster_colors), 
         col = cluster_colors, 
         pch = 20, 
         cex = 0.8, 
         box.lty = 0)
}

# Call the function to create the plot
create_rda_plot()

#svglite::svglite(
#  filename = "./forISRHML/Jun2_rda_infant_1421_milk.svg",
#  width = 13, height = 13
#)
#create_rda_plot()
#dev.off()

```

### TableS3

```{r}
# Filter the dataset for Pr(>F) > 0.1 and sort by Variance in descending order
filtered_data_rda_pn12 <- anova_terms %>%
  rownames_to_column(var = "Feature") %>%  # Convert row names to a column
  #filter(`Pr(>F)` < 0.1) %>%  # Filter based on Pr(>F)
  filter(Feature != "Residual") %>%
  mutate(Variance = Variance * 100) %>%
  arrange(desc(Variance)) 

# Create the barplot
barplot_plot <- ggplot(filtered_data_rda_pn12, aes(x = reorder(Feature, Variance), y = Variance)) +
  geom_bar(stat = "identity", fill = "lightgrey") +
  coord_flip() +  # Flip coordinates for better readability
  labs(
    title = "Variance of All Features",
    x = "",
    y = "Variance"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12),
    plot.title = element_text(size = 14),
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank()   # Remove minor grid lines
  ) 

# Display the plot
print(barplot_plot)

#svglite::svglite(
#  filename = "./forISRHML/Jun2_rda_infant_1421_barplot.svg",
#  width = 7, height = 4
#)
#barplot_plot
#dev.off()


# Extract the ANOVA table from the RDA result
anova_df <- as.data.frame(anova_terms) %>%
  dplyr::mutate(Variance = Variance *100) %>%
  rownames_to_column("Feature")

all_variance <- anova_df %>%
  filter(Feature!= "Residual") %>%
    dplyr::summarise(total_variance = sum(Variance, na.rm = TRUE))

all_variance

#write.xlsx(anova_df, "./forISRHML/Jun2_rda_milk_1421.xlsx")

```

# ü§ç FigureS10 Lavaan

## infant gut12 pc1

```{r message=FALSE}
infant_species <- infant_meta %>%
  tax_glom(taxrank = "species") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  filter(Abundance > 0)


infant_gut12_dist <- phyloseq::distance(pn12e_meta, method="unifrac", weighted=TRUE)

# Perform PCoA ordination using the calculated distance matrix
infant_gut12_ord <- ordinate(pn12e_meta, method="PCoA", distance=infant_gut12_dist)

ncol(infant_gut12_ord$vectors)
nrow(infant_gut12_ord$vectors)

plot_scree_trimmed <- function(ord) {
  k <- ncol(ord$vectors)          # number of PCs/axes
  ord2 <- ord
  ord2$values <- ord2$values[seq_len(k), , drop = FALSE]
  phyloseq::plot_scree(ord2) + labs(x = "\nAxis", y = "Proportion of Variance\n")
}

infant_gut12_pc_plot <- plot_scree_trimmed(infant_gut12_ord)
infant_gut12_pc_plot

#ggsave("./forISRHML/Revision/infant_gut12_pc1.svg", infant_gut12_pc_plot, width = 13, height = 5)

head(infant_gut12_ord)

infant_gut12_pc <- infant_gut12_ord$vectors

infant_gut12_pc1 <- infant_gut12_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.1") %>%
  dplyr::rename("infant_gut12_pc1" = "Axis.1")

infant_gut12_pc2 <- infant_gut12_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.2") %>%
  dplyr::rename("infant_gut12_pc2" = "Axis.2")

var_explained <- infant_gut12_ord$values$Eigenvalues/sum(infant_gut12_ord$values$Eigenvalues)
var_explained[1] * 100
var_explained[2] * 100
var_explained[1] * 100 + var_explained[2] * 100

```

## infant gut56 pc1

```{r message=FALSE}

infant_gut56_dist <- phyloseq::distance(pn56e_meta, method="unifrac", weighted=TRUE)

# Perform PCoA ordination using the calculated distance matrix
infant_gut56_ord <- ordinate(pn56e_meta, method="PCoA", distance=infant_gut56_dist)

plot_scree_trimmed <- function(ord) {
  k <- ncol(ord$vectors)          # number of PCs/axes
  ord2 <- ord
  ord2$values <- ord2$values[seq_len(k), , drop = FALSE]
  phyloseq::plot_scree(ord2) + labs(x = "\nAxis", y = "Proportion of Variance\n")
}

infant_gut56_pc_plot <- plot_scree_trimmed(infant_gut56_ord)
infant_gut56_pc_plot

#ggsave("./forISRHML/Revision/infant_gut56_pc.svg", infant_gut56_pc_plot, width = 13, height = 5)

head(infant_gut56_ord)

infant_gut56_pc <- infant_gut56_ord$vectors

infant_gut56_pc1 <- infant_gut56_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.1") %>%
  dplyr::rename("infant_gut56_pc1" = "Axis.1")

infant_gut56_pc2 <- infant_gut56_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.2") %>%
  dplyr::rename("infant_gut56_pc2" = "Axis.2")

var_explained <- infant_gut56_ord$values$Eigenvalues/sum(infant_gut56_ord$values$Eigenvalues)
var_explained[1] * 100
var_explained[2] * 100
var_explained[1] * 100 + var_explained[2] * 100

```

## mother gut tri3 pc1

```{r message=FALSE}
mother_species <- mother_meta %>%
  tax_glom(taxrank = "species") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  filter(Abundance > 0)


mother_tri3_dist <- phyloseq::distance(tri3_meta, method="unifrac", weighted=TRUE)

# Perform PCoA ordination using the calculated distance matrix
mother_tri3_ord <- ordinate(tri3_meta, method="PCoA", distance=mother_tri3_dist)

plot_scree_trimmed <- function(ord) {
  k <- ncol(ord$vectors)          # number of PCs/axes
  ord2 <- ord
  ord2$values <- ord2$values[seq_len(k), , drop = FALSE]
  phyloseq::plot_scree(ord2) + labs(x = "\nAxis", y = "Proportion of Variance\n")
}

mother_tri3_pc_plot <- plot_scree_trimmed(mother_tri3_ord)
mother_tri3_pc_plot

#ggsave("./forISRHML/Revision/mother_tri3_pc.svg", mother_tri3_pc_plot, width = 13, height = 5)

head(mother_tri3_ord)

mother_tri3_pc <- mother_tri3_ord$vectors

mother_tri3_pc1 <- mother_tri3_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.1") %>%
  dplyr::rename("mother_tri3_pc1" = "Axis.1")

mother_tri3_pc2 <- mother_tri3_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.2") %>%
  dplyr::rename("mother_tri3_pc2" = "Axis.2")


var_explained <- mother_tri3_ord$values$Eigenvalues/sum(mother_tri3_ord$values$Eigenvalues)
var_explained[1] * 100
var_explained[2] * 100
var_explained[1] * 100 + var_explained[2] * 100


```

## mother gut12 pc1

```{r}

mother_gut12_dist <- phyloseq::distance(pn12m_meta, method="unifrac", weighted=TRUE)

# Perform PCoA ordination using the calculated distance matrix
mother_gut12_ord <- ordinate(pn12m_meta, method="PCoA", distance=mother_gut12_dist)

plot_scree_trimmed <- function(ord) {
  k <- ncol(ord$vectors)          # number of PCs/axes
  ord2 <- ord
  ord2$values <- ord2$values[seq_len(k), , drop = FALSE]
  phyloseq::plot_scree(ord2) + labs(x = "\nAxis", y = "Proportion of Variance\n")
}

mother_gut12_pc_plot <- plot_scree_trimmed(mother_gut12_ord)
mother_gut12_pc_plot

#ggsave("./forISRHML/Revision/mother_gut12_pc.svg", mother_gut12_pc_plot, width = 13, height = 5)

head(mother_gut12_ord)

mother_gut12_pc <- mother_gut12_ord$vectors

mother_gut12_pc1 <- mother_gut12_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.1") %>%
  dplyr::rename("mother_gut12_pc1" = "Axis.1")

mother_gut12_pc2 <- mother_gut12_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.2") %>%
  dplyr::rename("mother_gut12_pc2" = "Axis.2")


var_explained <- mother_gut12_ord$values$Eigenvalues/sum(mother_gut12_ord$values$Eigenvalues)
var_explained[1] * 100
var_explained[2] * 100
var_explained[1] * 100 + var_explained[2] * 100 

```

## mother gut56 pc1

```{r}

mother_gut56_dist <- phyloseq::distance(pn56m_meta, method="unifrac", weighted=TRUE)

# Perform PCoA ordination using the calculated distance matrix
mother_gut56_ord <- ordinate(pn56m_meta, method="PCoA", distance=mother_gut56_dist)

plot_scree_trimmed <- function(ord) {
  k <- ncol(ord$vectors)          # number of PCs/axes
  ord2 <- ord
  ord2$values <- ord2$values[seq_len(k), , drop = FALSE]
  phyloseq::plot_scree(ord2) + labs(x = "\nAxis", y = "Proportion of Variance\n")
}

mother_gut56_pc_plot <- plot_scree_trimmed(mother_gut56_ord)
mother_gut56_pc_plot

#ggsave("./forISRHML/Revision/mother_gut56_pc.svg", mother_gut56_pc_plot, width = 13, height = 5)

head(mother_gut56_ord)

mother_gut56_pc <- mother_gut56_ord$vectors

mother_gut56_pc1 <- mother_gut56_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.1") %>%
  dplyr::rename("mother_gut56_pc1" = "Axis.1")

mother_gut56_pc2 <- mother_gut56_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.2") %>%
  dplyr::rename("mother_gut56_pc2" = "Axis.2")

var_explained <- mother_gut56_ord$values$Eigenvalues/sum(mother_gut56_ord$values$Eigenvalues)
var_explained[1] * 100
var_explained[2] * 100
var_explained[1] * 100 + var_explained[2] * 100 

```

## mother milk1421 pc1

```{r message=FALSE}
milk_species <- milkps_meta %>%
  tax_glom(taxrank = "species") %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  psmelt() %>%
  filter(Abundance > 0)

mother_milk1421_dist <- phyloseq::distance(X1421h_meta, method="unifrac", weighted=TRUE)

# Perform PCoA ordination using the calculated distance matrix
mother_milk1421_ord <- ordinate(X1421h_meta, method="PCoA", distance=mother_milk1421_dist)

plot_scree_trimmed <- function(ord) {
  k <- ncol(ord$vectors)          # number of PCs/axes
  ord2 <- ord
  ord2$values <- ord2$values[seq_len(k), , drop = FALSE]
  phyloseq::plot_scree(ord2) + labs(x = "\nAxis", y = "Proportion of Variance\n")
}

mother_milk1421_pc_plot <- plot_scree_trimmed(mother_milk1421_ord)
mother_milk1421_pc_plot

#ggsave("./forISRHML/Revision/mother_milk1421_pc.svg", mother_milk1421_pc_plot, width = 13, height = 5)

head(mother_milk1421_ord)

mother_milk1421_pc <- mother_milk1421_ord$vectors

mother_milk1421_pc1 <- mother_milk1421_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.1") %>%
  dplyr::rename("mother_milk1421_pc1" = "Axis.1") %>%
  mutate(idbs = gsub("A", "", idbs)) %>%
  mutate(idbs = gsub("B", "", idbs))

mother_milk1421_pc2 <- mother_milk1421_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.2")%>%
  dplyr::rename("mother_milk1421_pc2" = "Axis.2") %>%
  mutate(idbs = gsub("A", "", idbs)) %>%
  mutate(idbs = gsub("B", "", idbs))


var_explained <- mother_milk1421_ord$values$Eigenvalues/sum(mother_milk1421_ord$values$Eigenvalues)
var_explained[1] * 100
var_explained[2] * 100
var_explained[1] * 100 + var_explained[2] * 100 

```

## mother milk12 pc1

```{r message=FALSE}

mother_milk12_dist <- phyloseq::distance(pn12h_meta, method="unifrac", weighted=TRUE)

# Perform PCoA ordination using the calculated distance matrix
mother_milk12_ord <- ordinate(pn12h_meta, method="PCoA", distance=mother_milk12_dist)

plot_scree_trimmed <- function(ord) {
  k <- ncol(ord$vectors)          # number of PCs/axes
  ord2 <- ord
  ord2$values <- ord2$values[seq_len(k), , drop = FALSE]
  phyloseq::plot_scree(ord2) + labs(x = "\nAxis", y = "Proportion of Variance\n")
}

mother_milk12_pc_plot <- plot_scree_trimmed(mother_milk12_ord)
mother_milk12_pc_plot

#ggsave("./forISRHML/Revision/mother_milk12_pc.svg", mother_milk12_pc_plot, width = 13, height = 5)

head(mother_milk12_ord)

mother_milk12_pc <- mother_milk12_ord$vectors

mother_milk12_pc1 <- mother_milk12_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.1") %>%
  dplyr::rename("mother_milk12_pc1" = "Axis.1") %>%
  mutate(idbs = gsub("A", "", idbs)) %>%
  mutate(idbs = gsub("B", "", idbs))

mother_milk12_pc2 <- mother_milk12_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.2") %>%
  dplyr::rename("mother_milk12_pc2" = "Axis.2") %>%
  mutate(idbs = gsub("A", "", idbs)) %>%
  mutate(idbs = gsub("B", "", idbs))

var_explained <- mother_milk12_ord$values$Eigenvalues/sum(mother_milk12_ord$values$Eigenvalues)
var_explained[1] * 100
var_explained[2] * 100
var_explained[1] * 100 + var_explained[2] * 100

```

## mother milk34 pc1

```{r message=FALSE}

mother_milk34_dist <- phyloseq::distance(pn34h_meta, method="unifrac", weighted=TRUE)

# Perform PCoA ordination using the calculated distance matrix
mother_milk34_ord <- ordinate(pn34h_meta, method="PCoA", distance=mother_milk34_dist)

plot_scree_trimmed <- function(ord) {
  k <- ncol(ord$vectors)          # number of PCs/axes
  ord2 <- ord
  ord2$values <- ord2$values[seq_len(k), , drop = FALSE]
  phyloseq::plot_scree(ord2) + labs(x = "\nAxis", y = "Proportion of Variance\n")
}

mother_milk34_pc_plot <- plot_scree_trimmed(mother_milk34_ord)
mother_milk34_pc_plot

#ggsave("./forISRHML/Revision/mother_milk34_pc.svg", mother_milk34_pc_plot, width = 13, height = 5)

head(mother_milk34_ord)

mother_milk34_pc <- mother_milk34_ord$vectors

mother_milk34_pc1 <- mother_milk34_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.1") %>%
  dplyr::rename("mother_milk34_pc1" = "Axis.1") %>%
  mutate(idbs = gsub("A", "", idbs)) %>%
  mutate(idbs = gsub("B", "", idbs))

mother_milk34_pc2 <- mother_milk34_pc %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  separate(sample, into = c("timepoint", "sample","idbs", "dyads"), sep = "_") %>%
  dplyr::select("idbs", "Axis.2") %>%
  dplyr::rename("mother_milk34_pc2" = "Axis.2") %>%
  mutate(idbs = gsub("A", "", idbs)) %>%
  mutate(idbs = gsub("B", "", idbs))

var_explained <- mother_milk34_ord$values$Eigenvalues/sum(mother_milk34_ord$values$Eigenvalues)
var_explained[1] * 100
var_explained[2] * 100
var_explained[1] * 100 + var_explained[2] * 100 

```

## mother hmo1421 pc1

```{r}

hmo_1421 <- hmoMeta %>%
  filter(timepoint == "1421") %>%
  rename_with(~ str_replace(., "_nmol\\.mL$", ""), contains("_nmol.mL")) %>%
  select(idbs, "Secretor","X2.FL", "X3FL","LNT", "LNFP.II", "LNFP.I","X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", "X3.SL", "LSTc","DSLNT","FDSLNH", "DSLNH", "LNH","LSTb","DFLNH", "LNFP.III")

hmo1421_nos <- hmo_1421 %>% 
  select(-Secretor) %>%
  column_to_rownames("idbs")

hmo_pca1421 <- prcomp(hmo1421_nos, scale. = TRUE)

# Step 3: Extract PC1 scores
hmo1421_pc1 <- data.frame(
  idbs = rownames(hmo_pca1421$x),
  hmo1421_pc1 = hmo_pca1421$x[, 1]
)
hmo1421_pc2 <- data.frame(
  idbs = rownames(hmo_pca1421$x),
  hmo1421_pc2 = hmo_pca1421$x[, 2]
)

# Compute variance explained and sort
pca_var_explained <- hmo_pca1421$sdev^2 / sum(hmo_pca1421$sdev^2)
scree_df <- data.frame(PC = paste0("PC", seq_along(pca_var_explained)),
                       Variance = pca_var_explained) |>
  dplyr::arrange(desc(Variance))
scree_df

# Plot
hmo1421_pc1_plot <- ggplot(scree_df, aes(x = reorder(PC, -Variance), y = Variance)) +
  geom_bar(stat = "identity", fill = "#595959ff") +
  labs(x = "Principal Component", y = "Variance Explained") +
  theme_minimal()

#ggsave("./forISRHML/Revision/hmo1421_pc.svg", hmo1421_pc1_plot, width = 13, height = 5)
scree_df$Variance[scree_df$PC=="PC1"] + scree_df$Variance[scree_df$PC=="PC2"] 
```

## mother hmo12 pc1

```{r}
hmo_pn12 <- hmoMeta %>%
  filter(timepoint == "pn12") %>%
  rename_with(~ str_replace(., "_nmol\\.mL$", ""), contains("_nmol.mL")) %>%
  select(idbs, "Secretor","X2.FL", "X3FL","LNT", "LNFP.II", "LNFP.I","X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", "X3.SL", "LSTc","DSLNT","FDSLNH", "DSLNH", "LNH","LSTb","DFLNH", "LNFP.III")

hmo12_nos <- hmo_pn12 %>% 
  select(-Secretor) %>%
  column_to_rownames("idbs")

hmo_pca12 <- prcomp(hmo12_nos, scale. = TRUE)

# Step 3: Extract PC1 scores
hmo12_pc1 <- data.frame(
  idbs = rownames(hmo_pca12$x),
  hmo12_pc1 = hmo_pca12$x[, 1]
)

hmo12_pc2 <- data.frame(
  idbs = rownames(hmo_pca12$x),
  hmo12_pc2 = hmo_pca12$x[, 2]
)

# Compute variance explained and sort
pca_var_explained <- hmo_pca12$sdev^2 / sum(hmo_pca12$sdev^2)
scree_df <- data.frame(PC = paste0("PC", seq_along(pca_var_explained)),
                       Variance = pca_var_explained) |>
  dplyr::arrange(desc(Variance))
scree_df

# Plot
hmo12_pc1_plot <- ggplot(scree_df, aes(x = reorder(PC, -Variance), y = Variance)) +
  geom_bar(stat = "identity", fill = "#595959ff") +
  labs(x = "Principal Component", y = "Variance Explained") +
  theme_minimal()

#ggsave("./forISRHML/Revision/hmo12_pc1.svg", hmo12_pc1_plot, width = 13, height = 5)

scree_df$Variance[scree_df$PC=="PC1"] + scree_df$Variance[scree_df$PC=="PC2"] 

```

## mother hmo34 pc1

```{r}
hmo_pn34 <- hmoMeta %>%
  filter(timepoint == "pn34") %>%
  rename_with(~ str_replace(., "_nmol\\.mL$", ""), contains("_nmol.mL")) %>%
  select(idbs, "Secretor","X2.FL", "X3FL","LNT", "LNFP.II", "LNFP.I","X6.SL", "DFLNT", "DFLac", "LNnT", "FLNH", "X3.SL", "LSTc","DSLNT","FDSLNH", "DSLNH", "LNH","LSTb","DFLNH", "LNFP.III")

hmo34_nos <- hmo_pn34 %>% 
  select(-Secretor) %>%
  column_to_rownames("idbs")

hmo_pca34 <- prcomp(hmo34_nos, scale. = TRUE)

# Step 3: Extract PC1 scores
hmo34_pc1 <- data.frame(
  idbs = rownames(hmo_pca34$x),
  hmo34_pc1 = hmo_pca34$x[, 1]
)

hmo34_pc2 <- data.frame(
  idbs = rownames(hmo_pca34$x),
  hmo34_pc2 = hmo_pca34$x[, 2]
)

# Compute variance explained and sort
pca_var_explained <- hmo_pca34$sdev^2 / sum(hmo_pca34$sdev^2)
scree_df <- data.frame(PC = paste0("PC", seq_along(pca_var_explained)),
                       Variance = pca_var_explained) |>
  dplyr::arrange(desc(Variance))
scree_df

# Plot
hmo34_pc1_plot <- ggplot(scree_df, aes(x = reorder(PC, -Variance), y = Variance)) +
  geom_bar(stat = "identity", fill = "#595959ff") +
  labs(x = "Principal Component", y = "Variance Explained") +
  theme_minimal()

#ggsave("./forISRHML/Revision/hmo34_pc1.svg", hmo34_pc1_plot, width = 13, height = 5)

scree_df$Variance[scree_df$PC=="PC1"] + scree_df$Variance[scree_df$PC=="PC2"] 

```

## metabolomic1421 pc1

```{r}
metabolomics <- metab_raw %>%
  separate(X, into = c("timepoint", "idbs"), sep = "_") %>%
  left_join(metadata %>% select("idbs", "code_bep_n"), by = "idbs")%>%
  filter(code_bep_n == 1 | code_bep_n == 4) %>%
  #filter(idbs != "619") %>%
  select(-code_bep_n)
metabolomics$idbs <- as.numeric(metabolomics$idbs)


```

```{r}

metabolomic1421 <- metabolomics %>%
  filter(timepoint == "1421") %>%
  select(-timepoint) %>%
  column_to_rownames("idbs")


metabolomic1421_pca <- prcomp(metabolomic1421, scale. = TRUE)

# Step 3: Extract PC1 scores
metabolomic1421_pc1 <- data.frame(
  idbs = rownames(metabolomic1421_pca$x),
  metabolomic1421_pc1 = metabolomic1421_pca$x[, 1]
)

metabolomic1421_pc2 <- data.frame(
  idbs = rownames(metabolomic1421_pca$x),
  metabolomic1421_pc2 = metabolomic1421_pca$x[, 2]
)

# Compute variance explained and sort
pca_var_explained <- metabolomic1421_pca$sdev^2 / sum(metabolomic1421_pca$sdev^2)
scree_df <- data.frame(PC = paste0("PC", seq_along(pca_var_explained)),
                       Variance = pca_var_explained) |>
  dplyr::arrange(desc(Variance))
scree_df

# Plot
metabolomic1421_pc1_plot <- ggplot(scree_df, aes(x = reorder(PC, -Variance), y = Variance)) +
  geom_bar(stat = "identity", fill = "#595959ff") +
  labs(x = "Principal Component", y = "Variance Explained") +
  theme_minimal()

#ggsave("./forISRHML/Revision/metabolomic1421_pc1.svg", metabolomic1421_pc1_plot, width = 13, height = 5)

scree_df$Variance[scree_df$PC=="PC1"] + scree_df$Variance[scree_df$PC=="PC2"] 

```

## metabolomic12 pc1

```{r}
metabolomic12 <- metabolomics %>%
  filter(timepoint == "pn12") %>%
  select(-timepoint) %>%
  column_to_rownames("idbs")


metabolomic12_pca <- prcomp(metabolomic12, scale. = TRUE)

# Step 3: Extract PC1 scores
metabolomic12_pc1 <- data.frame(
  idbs = rownames(metabolomic12_pca$x),
  metabolomic12_pc1 = metabolomic12_pca$x[, 1]
)

metabolomic12_pc2 <- data.frame(
  idbs = rownames(metabolomic12_pca$x),
  metabolomic12_pc2 = metabolomic12_pca$x[, 2]
)

# Compute variance explained and sort
pca_var_explained <- metabolomic12_pca$sdev^2 / sum(metabolomic12_pca$sdev^2)
scree_df <- data.frame(PC = paste0("PC", seq_along(pca_var_explained)),
                       Variance = pca_var_explained) |>
  dplyr::arrange(desc(Variance))
scree_df

# Plot
metabolomic12_pc1_plot <- ggplot(scree_df, aes(x = reorder(PC, -Variance), y = Variance)) +
  geom_bar(stat = "identity", fill = "#595959ff") +
  labs(x = "Principal Component", y = "Variance Explained") +
  theme_minimal()

#ggsave("./forISRHML/Revision/metabolomic12_pc1.svg", metabolomic12_pc1_plot, width = 13, height = 5)

scree_df$Variance[scree_df$PC=="PC1"] 


```

## metabolomic34 pc1

```{r}
metabolomic34 <- metabolomics %>%
  filter(timepoint == "pn34") %>%
  select(-timepoint) %>%
  column_to_rownames("idbs")


metabolomic34_pca <- prcomp(metabolomic34, scale. = TRUE)

# Step 3: Extract PC1 scores
metabolomic34_pc1 <- data.frame(
  idbs = rownames(metabolomic34_pca$x),
  metabolomic34_pc1 = metabolomic34_pca$x[, 1]
)

metabolomic34_pc2 <- data.frame(
  idbs = rownames(metabolomic34_pca$x),
  metabolomic34_pc2 = metabolomic34_pca$x[, 2]
)

# Compute variance explained and sort
pca_var_explained <- metabolomic34_pca$sdev^2 / sum(metabolomic34_pca$sdev^2)
scree_df <- data.frame(PC = paste0("PC", seq_along(pca_var_explained)),
                       Variance = pca_var_explained) |>
  dplyr::arrange(desc(Variance))
scree_df

# Plot
metabolomic34_pc1_plot <- ggplot(scree_df, aes(x = reorder(PC, -Variance), y = Variance)) +
  geom_bar(stat = "identity", fill = "#595959ff") +
  labs(x = "Principal Component", y = "Variance Explained") +
  theme_minimal()

#ggsave("./forISRHML/Revision/metabolomic34_pc1.svg", metabolomic34_pc1_plot, width = 13, height = 5)

scree_df$Variance[scree_df$PC=="PC1"] 

```

## mother milk nutrient 1421 pc1

```{r}
milkNutrients <- milkMeta %>%
  select(idbs, timepoint, "FAT", "PROTEIN", "CARBOHYDRATE", "Kcal.L", "FGF.21", "FSH", "Insulin", "LH", "Leptin", "Calprotectin", "IgA", "Na", "Mg", "P.", "K.", "Ca", "Cr", "Fe", "Cu", "Zn", "Mo", "As", "Mn", "Se", "Ribo", "FMN", "FAD", "B2", "NAM", "NAD", "NMN", "NR", "B3", "Nufa", "PA", "PL", "PM", "PN", "PLP", "B6", "Bio", "TRP", "TPP", "TMP", "T", "B1", "B12", "g.tocopherol", "a.tocopherol", "vitamin.A") 

# Identify columns to impute (excluding idbs and timepoint)
columns_to_impute <- setdiff(colnames(milkNutrients), c("idbs", "timepoint"))

# Convert selected columns to numeric and impute missing values
milkNutrients[columns_to_impute] <- lapply(
  milkNutrients[columns_to_impute],
  function(x) {
    x <- as.numeric(x)
    x[is.na(x)] <- min(x, na.rm = TRUE)
    return(x)
  }
)

```

```{r}
nutrients1421 <- milkNutrients %>%
  filter(timepoint == "1421") %>%
  select(-timepoint) %>%
  column_to_rownames("idbs")

nutrients1421_pca <- prcomp(nutrients1421, scale. = TRUE)

# Step 3: Extract PC1 scores
nutrients1421_pc1 <- data.frame(
  idbs = rownames(nutrients1421_pca$x),
  nutrients1421_pc1 = nutrients1421_pca$x[, 1]
)

nutrients1421_pc2 <- data.frame(
  idbs = rownames(nutrients1421_pca$x),
  nutrients1421_pc2 = nutrients1421_pca$x[, 2]
)

nutrients1421_pc3 <- data.frame(
  idbs = rownames(nutrients1421_pca$x),
  nutrients1421_pc3 = nutrients1421_pca$x[, 3]
)

nutrients1421_pc4 <- data.frame(
  idbs = rownames(nutrients1421_pca$x),
  nutrients1421_pc4 = nutrients1421_pca$x[, 4]
)

# Compute variance explained and sort
pca_var_explained <- nutrients1421_pca$sdev^2 / sum(nutrients1421_pca$sdev^2)
scree_df <- data.frame(PC = paste0("PC", seq_along(pca_var_explained)),
                       Variance = pca_var_explained) |>
  dplyr::arrange(desc(Variance))
scree_df

# Plot
nutrients1421_pc1_plot <- ggplot(scree_df, aes(x = reorder(PC, -Variance), y = Variance)) +
  geom_bar(stat = "identity", fill = "#595959ff") +
  labs(x = "Principal Component", y = "Variance Explained") +
  theme_minimal()

#ggsave("./forISRHML/Revision/nutrients1421_pc1.svg", nutrients1421_pc1_plot, width = 13, height = 5)

scree_df$Variance[scree_df$PC=="PC1"] + scree_df$Variance[scree_df$PC=="PC2"] 

```

## mother milk nutrients12 pc1

```{r}
nutrients12 <- milkNutrients %>%
  filter(timepoint == "pn12") %>%
  select(-timepoint) %>%
  column_to_rownames("idbs")

nutrients12_pca <- prcomp(nutrients12, scale. = TRUE)

# Step 3: Extract PC1 scores
nutrients12_pc1 <- data.frame(
  idbs = rownames(nutrients12_pca$x),
  nutrients12_pc1 = nutrients12_pca$x[, 1]
)

nutrients12_pc2 <- data.frame(
  idbs = rownames(nutrients12_pca$x),
  nutrients12_pc2 = nutrients12_pca$x[, 2]
)

nutrients12_pc3 <- data.frame(
  idbs = rownames(nutrients12_pca$x),
  nutrients12_pc3 = nutrients12_pca$x[, 3]
)

nutrients12_pc4 <- data.frame(
  idbs = rownames(nutrients12_pca$x),
  nutrients12_pc4 = nutrients12_pca$x[, 4]
)

# Compute variance explained and sort
pca_var_explained <- nutrients12_pca$sdev^2 / sum(nutrients12_pca$sdev^2)
scree_df <- data.frame(PC = paste0("PC", seq_along(pca_var_explained)),
                       Variance = pca_var_explained) |>
  dplyr::arrange(desc(Variance))
scree_df

# Plot
nutrients12_pc1_plot <- ggplot(scree_df, aes(x = reorder(PC, -Variance), y = Variance)) +
  geom_bar(stat = "identity", fill = "#595959ff") +
  labs(x = "Principal Component", y = "Variance Explained") +
  theme_minimal()

#ggsave("./forISRHML/Revision/nutrients12_pc1.svg", nutrients12_pc1_plot, width = 13, height = 5)

scree_df$Variance[scree_df$PC=="PC1"] + scree_df$Variance[scree_df$PC=="PC2"] 

```

## mother milk nutrients34 pc1

```{r}
nutrients34 <- milkNutrients %>%
  filter(timepoint == "pn34") %>%
  select(-timepoint) %>%
  column_to_rownames("idbs")

nutrients34_pca <- prcomp(nutrients34, scale. = TRUE)

# Step 3: Extract PC1 scores
nutrients34_pc1 <- data.frame(
  idbs = rownames(nutrients34_pca$x),
  nutrients34_pc1 = nutrients34_pca$x[, 1]
)

nutrients34_pc2 <- data.frame(
  idbs = rownames(nutrients34_pca$x),
  nutrients34_pc2 = nutrients34_pca$x[, 2]
)

nutrients34_pc3 <- data.frame(
  idbs = rownames(nutrients34_pca$x),
  nutrients34_pc3 = nutrients34_pca$x[, 3]
)

nutrients34_pc4 <- data.frame(
  idbs = rownames(nutrients34_pca$x),
  nutrients34_pc4 = nutrients34_pca$x[, 4]
)

# Compute variance explained and sort
pca_var_explained <- nutrients34_pca$sdev^2 / sum(nutrients34_pca$sdev^2)
scree_df <- data.frame(PC = paste0("PC", seq_along(pca_var_explained)),
                       Variance = pca_var_explained) |>
  dplyr::arrange(desc(Variance))
scree_df

# Plot
nutrients34_pc1_plot <- ggplot(scree_df, aes(x = reorder(PC, -Variance), y = Variance)) +
  geom_bar(stat = "identity", fill = "#595959ff") +
  labs(x = "Principal Component", y = "Variance Explained") +
  theme_minimal()

#ggsave("./forISRHML/Revision/nutrients34_pc1.svg", nutrients34_pc1_plot, width = 13, height = 5)

scree_df$Variance[scree_df$PC=="PC1"] + scree_df$Variance[scree_df$PC=="PC2"] 

```

# ü§ç lavaan with time-order

```{r}

all_data_pc12 <- list(
  infant_gut12_pc1, infant_gut12_pc2, infant_gut56_pc1, infant_gut56_pc2,
  mother_tri3_pc1, mother_tri3_pc2, mother_gut12_pc1, mother_gut12_pc2, mother_gut56_pc1, mother_gut56_pc2,
  mother_milk1421_pc1, mother_milk1421_pc2, mother_milk12_pc1, mother_milk12_pc2, mother_milk34_pc1, mother_milk34_pc2,
  hmo1421_pc1, hmo1421_pc2, hmo12_pc1, hmo12_pc2, hmo34_pc1, hmo34_pc2,
  metabolomic1421_pc1, metabolomic1421_pc2, metabolomic12_pc1, metabolomic12_pc2, metabolomic34_pc1, metabolomic34_pc2,
  nutrients1421_pc1, nutrients1421_pc2, nutrients12_pc1, nutrients12_pc2, nutrients34_pc1, nutrients34_pc2
)

# Join all datasets by "idbs"
merged_pc12 <- reduce(all_data_pc12, full_join, by = "idbs") %>% filter(!is.na(infant_gut12_pc1))

sum(complete.cases(merged_pc12))

library(lavaan)
library(dplyr)

# 1) Scale all numeric columns (except ID)
scale_numeric <- function(df, id_cols = "idbs") {
  out <- df
  num_idx <- sapply(out, is.numeric)
  if (length(id_cols)) num_idx[colnames(out) %in% id_cols] <- FALSE
  out[, num_idx] <- scale(out[, num_idx])
  out
}

merged_pc12_scaled <- scale_numeric(merged_pc12, id_cols = "idbs")

# 2) Measurement model (same structure you had; scaled inputs stabilize estimation)
meas <- '
  Infant_Gut_12m =~ infant_gut12_pc1 + infant_gut12_pc2
  Infant_Gut_56m =~ infant_gut56_pc1 + infant_gut56_pc2
  Mother_Gut_Tri3 =~ mother_tri3_pc1
  Mother_Gut_12m =~ mother_gut12_pc1
  Mother_Gut_56m =~ mother_gut56_pc1 
  Milk_Microbiome_1421d =~ mother_milk1421_pc1 + mother_milk1421_pc2 
  Milk_Microbiome_12m   =~ mother_milk12_pc1   + mother_milk12_pc2
  Milk_Microbiome_34m   =~ mother_milk34_pc1   + mother_milk34_pc2 
  Milk_HMO_1421d        =~ hmo1421_pc1 + hmo1421_pc2
  Milk_HMO_12m          =~ hmo12_pc1  + hmo12_pc2
  Milk_HMO_34m          =~ hmo34_pc1  + hmo34_pc2
  Milk_Metabolite_1421d =~ metabolomic1421_pc1 + metabolomic1421_pc2
  Milk_Metabolite_12m   =~ metabolomic12_pc1 + metabolomic12_pc2
  Milk_Metabolite_34m   =~ metabolomic34_pc1 + metabolomic34_pc2
  Milk_Nutrient_1421d   =~ nutrients1421_pc1 + nutrients1421_pc2 
  Milk_Nutrient_12m     =~ nutrients12_pc1   + nutrients12_pc2 
  Milk_Nutrient_34m     =~ nutrients34_pc1   + nutrients34_pc2
'

fit_meas <- cfa(meas, data = merged_pc12_scaled,
                estimator = "MLR", std.lv = TRUE, missing = "fiml")
summary(fit_meas, fit.measures = TRUE, standardized = TRUE)

# 3) Factor scores (on the scaled metric)
fscores <- lavPredict(fit_meas, method = "regression")
fscores_df <- cbind(merged_pc12_scaled["idbs"], as.data.frame(fscores))

# (Optional) quick sanity check of scales
# apply(fscores_df[-1], 2, sd)  # should be ~1 if std.lv=TRUE

# 4) Structural model (your original)
struct <- '
  Infant_Gut_12m ~ Milk_Metabolite_1421d + Milk_Nutrient_1421d +
                   Milk_Microbiome_12m + Milk_Metabolite_12m +
                   Mother_Gut_12m + Mother_Gut_Tri3 

  Infant_Gut_56m ~ Milk_Microbiome_1421d + Milk_Metabolite_34m + Milk_Nutrient_34m +
                   Mother_Gut_56m

  Milk_Metabolite_34m ~ Infant_Gut_12m

'

fit_struct <- sem(struct, data = fscores_df,
                  estimator = "MLR", std.lv = TRUE, missing = "fiml")
summary(fit_struct, fit.measures = TRUE, standardized = TRUE)

fitMeasures(fit_struct, c("cfi","rmsea","srmr"))

```

## auto
```{r}

library(lavaan)

# ---------- 1) Helper: time rank from variable name ----------
time_rank <- function(var) {
  v <- tolower(var)
  if (grepl("tri3",  v)) return(0L)
  if (grepl("1421d", v)) return(1L)
  if (grepl("12m",   v)) return(2L)
  if (grepl("34m",   v)) return(3L)
  if (grepl("56m",   v)) return(4L)
  return(NA_integer_)   # unknown -> disallow
}

# allow_within_time = TRUE  => same-time or earlier is OK
# allow_within_time = FALSE => strictly earlier only
temporal_ok <- function(lhs, rhs, allow_within_time = TRUE) {
  tl <- time_rank(lhs); tr <- time_rank(rhs)
  if (is.na(tl) || is.na(tr)) return(FALSE)
  if (allow_within_time) return(tr <= tl)
  return(tr < tl)
}

# crude duplicate check for "lhs ~ rhs"
has_path <- function(model_text, lhs, rhs) {
  patt <- sprintf("\\b%s\\s*~\\s*%s\\b", lhs, rhs)
  grepl(patt, model_text)
}

# ---------- 2) Time-respecting auto improvement ----------
auto_improve_temporal <- function(
  initial_model_text,
  data,
  cfi_thr   = 0.95,
  rmsea_thr = 0.06,
  srmr_thr  = 0.08,
  max_steps = 40,
  min_mi    = 3.84,         # ~ p=0.05 for 1 df
  allow_within_time = TRUE, # permit same-time edges
  estimator = "MLR",
  std.lv    = TRUE,
  missing   = "fiml",
  verbose   = TRUE
) {
  stopifnot(is.character(initial_model_text), length(initial_model_text) == 1)

  current <- initial_model_text
  fit <- sem(current, data = data, estimator = estimator, std.lv = std.lv, missing = missing)

  step <- 0L
  repeat {
    fm <- try(fitMeasures(fit, c("cfi","rmsea","srmr")), silent = TRUE)
    if (inherits(fm, "try-error")) {
      if (verbose) cat("‚ö†Ô∏è  Fit measures unavailable (non-converged?).\n")
      break
    }
    if (verbose) cat(sprintf("Step %d | CFI=%.3f RMSEA=%.3f SRMR=%.3f\n", step, fm["cfi"], fm["rmsea"], fm["srmr"]))

    # stop if thresholds met
    if (!any(is.na(fm)) && fm["cfi"] >= cfi_thr && fm["rmsea"] <= rmsea_thr && fm["srmr"] <= srmr_thr) {
      if (verbose) cat("‚úÖ Model fit is acceptable. Stopping.\n")
      break
    }
    if (step >= max_steps) {
      if (verbose) cat("‚õî Reached max steps. Stopping.\n")
      break
    }

    # collect candidate regression paths by MI
    mi <- try(modindices(fit, sort. = TRUE), silent = TRUE)
    if (inherits(mi, "try-error") || is.null(mi) || nrow(mi) == 0L) {
      if (verbose) cat("‚ö†Ô∏è No modification indices available. Stopping.\n")
      break
    }
    mi_reg <- subset(mi, op == "~" & !grepl("\\|", lhs) & !grepl("\\|", rhs) & mi >= min_mi)

    if (!nrow(mi_reg)) {
      if (verbose) cat("‚ö†Ô∏è No MI above threshold. Stopping.\n")
      break
    }

    # filter to time-allowed and not already present
    keep <- mapply(function(L, R) temporal_ok(L, R, allow_within_time) && !has_path(current, L, R),
                   mi_reg$lhs, mi_reg$rhs)
    mi_allowed <- mi_reg[keep, , drop = FALSE]

    if (!nrow(mi_allowed)) {
      if (verbose) cat("‚ö†Ô∏è All high-MI paths violate temporality or already exist. Stopping.\n")
      break
    }

    # try candidates in order; accept the first that converges AND improves fit
    added <- FALSE
    base_fm <- fm
    for (i in seq_len(nrow(mi_allowed))) {
      L <- mi_allowed$lhs[i]; R <- mi_allowed$rhs[i]
      new_path <- sprintf("%s ~ %s", L, R)
      trial_model <- paste(current, new_path, sep = "\n")
      trial_fit <- try(sem(trial_model, data = data, estimator = estimator, std.lv = std.lv, missing = missing), silent = TRUE)
      if (inherits(trial_fit, "try-error")) next

      trial_fm <- try(fitMeasures(trial_fit, c("cfi","rmsea","srmr")), silent = TRUE)
      if (inherits(trial_fm, "try-error")) next

      # simple improvement rule: CFI up or RMSEA/SRMR down
      improves <- (!is.na(trial_fm["cfi"])  && trial_fm["cfi"]  > base_fm["cfi"])  ||
                  (!is.na(trial_fm["rmsea"])&& trial_fm["rmsea"]< base_fm["rmsea"])||
                  (!is.na(trial_fm["srmr"]) && trial_fm["srmr"] < base_fm["srmr"])

      if (improves) {
        if (verbose) cat(sprintf("‚ûï Adding: %s  [MI=%.2f]  -> CFI %.3f‚Üí%.3f, RMSEA %.3f‚Üí%.3f, SRMR %.3f‚Üí%.3f\n",
                                 new_path, mi_allowed$mi[i],
                                 base_fm["cfi"], trial_fm["cfi"],
                                 base_fm["rmsea"], trial_fm["rmsea"],
                                 base_fm["srmr"], trial_fm["srmr"]))
        current <- trial_model
        fit <- trial_fit
        step <- step + 1L
        added <- TRUE
        break
      }
    }

    if (!added) {
      if (verbose) cat("‚ö†Ô∏è No candidate path both respected time and improved fit. Stopping.\n")
      break
    }
  }

  if (verbose) {
    cat("\nüìù Final model after", step, "steps:\n")
    cat(current, "\n")
  }
  invisible(list(model_text = current, fit = fit))
}

# 0) (Recommended) standardize numeric columns to avoid scale issues
num <- sapply(fscores_df, is.numeric)
fs_scaled <- cbind(fscores_df[ , !num], as.data.frame(scale(fscores_df[ , num])))

# 1) Fit your baseline (struct) once if you want to see starting fit
fit0 <- sem(struct, data = fs_scaled, estimator = "MLR", std.lv = TRUE)
fitMeasures(fit0, c("cfi","rmsea","srmr"))

# 2) Auto-improve without reverse-time edges
res <- auto_improve_temporal(
  initial_model_text = struct,
  data               = fs_scaled,
  cfi_thr = 0.95, rmsea_thr = 0.06, srmr_thr = 0.08,
  max_steps = 50,
  min_mi = 3.84,              # raise to 6.64 or 10.83 to be more conservative
  allow_within_time = TRUE,   # allow same-time edges (e.g., 12m ~ 12m)
  estimator = "MLR", std.lv = TRUE, missing = "fiml",
  verbose = TRUE
)

# 3) Inspect result
summary(res$fit, fit.measures = TRUE, standardized = TRUE)
fitMeasures(res$fit, c("cfi","rmsea","srmr"))
cat(res$model_text)

```

## draw Fig7E TableS6

```{r}
# Define updated model
model <- res$model_text

# Split numeric and non-numeric columns
numeric_cols <- sapply(fscores_df, is.numeric)
scaled_numeric <- scale(fscores_df[, numeric_cols])

# Combine back with non-numeric columns (e.g., ID)
scaled_df <- cbind(fscores_df[, !numeric_cols], as.data.frame(scaled_numeric))

# Fit model as before
fit <- sem(model, data = scaled_df, std.lv = T)
summary(fit)
fitMeasures(fit, c("cfi", "rmsea", "srmr"))

lavInspect(fit, "nobs")  # gives the actual sample size used under FIML

fit_boot <- sem(model, data = scaled_df, se = "bootstrap", bootstrap = 1000)
summary(fit_boot, standardized = TRUE)
fitMeasures(fit_boot, c("cfi", "rmsea", "srmr"))

lavInspect(fit_boot, "nobs")  # check FIML effective sample size
lavInspect(fit_boot, "npar")  # number of parameters being estimated
summary(fit_boot, standardized = TRUE)
modindices(fit_boot, sort.=TRUE)[1:10, ]


# Timepoint-based coloring
# Get underlying semPlot model structure
plot_model <- semPlot::semPlotModel(fit_boot)

layout_matrix <- matrix(c(
  # Row 1
  # Row 2
  NA,   "Milk_HMO_1421d", "Milk_HMO_12m", NA, "Milk_HMO_34m",    NA,
  # Row 3
  NA,   "Milk_Metabolite_1421d",   "Milk_Metabolite_12m",  NA, "Milk_Metabolite_34m",   NA,
  # Row 4
  NA,       "Milk_Nutrient_1421d",     "Milk_Nutrient_12m", NA, "Milk_Nutrient_34m",     NA,
  NA,      "Milk_Microbiome_1421d",   "Milk_Microbiome_12m",  NA, "Milk_Microbiome_34m",   NA,
  # Row 5
  NA,        NA,  NA,  "Infant_Gut_12m",        NA,     "Infant_Gut_56m",
  # Row 6 (lower row)
  "Mother_Gut_Tri3",         NA,  NA,  "Mother_Gut_12m",          NA,    "Mother_Gut_56m"
), ncol = 6, byrow = TRUE)

# Extract node labels
node_labels <- plot_model@Vars$name
node_colors <- rep("white", length(node_labels))
names(node_colors) <- node_labels
# Assign colors by timepoint
node_colors[c("Mother_Gut_Tri3")] <- "#f0f0f0"           # Tri3
node_colors[grep("1421d", names(node_colors))] <- "#b3cde3"  # 1421d
node_colors[grep("12m", names(node_colors))] <- "#ccebc5"     # 12m
node_colors[grep("34m", names(node_colors))] <- "#ffffcc"     # 34m
node_colors[grep("56m", names(node_colors))] <- "#fbb4ae"     # 56m

# Redefine layout_matrix from earlier (same 5-column layout)

# Plot
p_pa <- semPaths(fit_boot,
                 whatLabels = "std",
                 style = "ram",
                 layout = layout_matrix,
                 nCharNodes = 0,
                 nCharEdges = 0,
                 intercepts = FALSE,
                 curvePivot = 0.8,
                 fade = TRUE,
                 edge.label.cex = 0.4,
                 edge.label.position = 0.55,
                 sizeMan = 8,
                 edge.width = 0.6,
                 label.prop = 1,
                 residuals = FALSE,
                 edge.color = "black",
                 color = node_colors,
                 rescale = FALSE,
                 mar = c(7, 7, 7, 7))# Mark significant paths
p_pa2 <- mark_sig(p_pa, fit_boot)

 #Save the diagram to PNG
# svglite::svglite(
#   filename = "./sem_path_diagram_pc1pc2_139_SAVE_sept22_2.svg",
#   width = 13, height = 12
# )
# plot(p_pa2)
# dev.off()

 # Extract standardized parameter estimates
std_estimates <- parameterEstimates(fit_boot, standardized = TRUE)

# View only the standardized coefficients (std.all)
std_estimates_selected <- std_estimates[, c("lhs", "op", "rhs", "est", "std.all", "pvalue")]

# Optional: filter only regressions (i.e., "~") and significant ones
significant_paths <- subset(std_estimates_selected, op == "~" & pvalue < 0.05)

# View
print(significant_paths)

#write.csv(std_estimates_selected, "./sem_model_paths_PC1PC2_139_SAVE_sept22_2.csv", row.names = FALSE)

```

